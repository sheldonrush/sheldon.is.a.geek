{"meta":{"version":1,"warehouse":"1.0.1"},"models":{"Asset":[{"_id":"source/imgs/winetricks3.png","path":"imgs/winetricks3.png","modified":1},{"_id":"source/imgs/winetricks2.png","path":"imgs/winetricks2.png","modified":1},{"_id":"source/imgs/winetricks1.png","path":"imgs/winetricks1.png","modified":1},{"_id":"source/imgs/readelf_S.png","path":"imgs/readelf_S.png","modified":1},{"_id":"source/imgs/qt_tutoral.png","path":"imgs/qt_tutoral.png","modified":1},{"_id":"source/imgs/pthread_v2.png","path":"imgs/pthread_v2.png","modified":1},{"_id":"source/imgs/pthread_v1.png","path":"imgs/pthread_v1.png","modified":1},{"_id":"source/imgs/ifconfig.jpeg","path":"imgs/ifconfig.jpeg","modified":1},{"_id":"source/imgs/fping.jpeg","path":"imgs/fping.jpeg","modified":1},{"_id":"source/imgs/People.jpg","path":"imgs/People.jpg","modified":1},{"_id":"source/imgs/IMG_1252.JPG","path":"imgs/IMG_1252.JPG","modified":1},{"_id":"source/imgs/IMG_1251.JPG","path":"imgs/IMG_1251.JPG","modified":1},{"_id":"source/imgs/IMG_1250.JPG","path":"imgs/IMG_1250.JPG","modified":1},{"_id":"source/imgs/IMG_1249.JPG","path":"imgs/IMG_1249.JPG","modified":1},{"_id":"source/imgs/IMG_1242.JPG","path":"imgs/IMG_1242.JPG","modified":1},{"_id":"source/imgs/11245.jpg","path":"imgs/11245.jpg","modified":1},{"_id":"source/favicon.png","path":"favicon.png","modified":1},{"_id":"source/doc/raspberry_case.pdf","path":"doc/raspberry_case.pdf","modified":1},{"_id":"source/doc/Pi_is_client_PC_is_server.tar.7z","path":"doc/Pi_is_client_PC_is_server.tar.7z","modified":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/landscape/source/css/images/banner_backup.jpg","path":"css/images/banner_backup.jpg","modified":1},{"_id":"themes/landscape/source/css/images/banner.xcf","path":"css/images/banner.xcf","modified":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1}],"Cache":[{"_id":"source/_posts/-C-ELF-Attribute-Section.md","shasum":"6a3be20667c25467ae7f34e84417807485016ae6","modified":1515426266950},{"_id":"source/_posts/-C-Virtual-Function-Exercisels.md","shasum":"6ca11b2e3bfe19cff74d5b247958db5702a82b38","modified":1515426266950},{"_id":"source/_posts/-C-Virtual-Function-Inherit-My-Animal-World.md","shasum":"d52566a73f0e69e054eb6966fbca9ad0c95fdf6e","modified":1515426266950},{"_id":"source/_posts/-GCC-MACRO-LOG.md","shasum":"02eb735a6e6506560f4f4f1de7d6877dfb872c7f","modified":1515426266950},{"_id":"source/_posts/-GDB-基本指令.md","shasum":"8dc9e10fede0aa93d9a18f32db8ba156a2180d1c","modified":1515426266950},{"_id":"source/_posts/-Network-fping的用法.md","shasum":"74b4b51035800dd235c191c098b7f7182430f9da","modified":1515426266950},{"_id":"source/_posts/-Pointer-Simple-concept.md","shasum":"6c3014c6352ca196482bcda1b37bff9071fddcc5","modified":1515426266950},{"_id":"source/_posts/-QT-GUI-Hello-World.md","shasum":"fe0830c50c1f8225c26b1d51340732d7fea4d241","modified":1515426266950},{"_id":"source/_posts/-Raspberry-Pi-Cam-Module-行車記錄器.md","shasum":"c7096b190ddbe0260c3616bd725916fea4bcbb47","modified":1515426266950},{"_id":"source/_posts/-Raspberry-Pi-Demod-Video.md","shasum":"687f49ca9bab2a67b5d1756f9dd443c968cb51fa","modified":1515426266950},{"_id":"source/_posts/-Raspberry-Pi-How-to-get-the-root.md","shasum":"d9eebec1abbcaef111dab4eea2988691998dc03f","modified":1515426266950},{"_id":"source/_posts/-Raspberry-Pi-Socket-Programming-and-GPIO.md","shasum":"802af2cdd2094c7ff9de2e33f6f09330e2c487fd","modified":1515426266950},{"_id":"source/_posts/-Raspberry-Pi-Socket-Programming-and-GPIO.md~","shasum":"25c5d25f9edf4750e214f1dc605376ae7e729dc8","modified":1515426266950},{"_id":"source/_posts/-Raspberry-Pi-製作PI的衣服-Case.md","shasum":"cd07c96c23008c85f07389b831be43e170a6ffe1","modified":1515426266950},{"_id":"source/_posts/-Raspberry-Pi-要如何自動的進入shell裏面-而不需要輸入密碼.md","shasum":"f82544b791066ac2ca8a771578b3326ca3c75753","modified":1515426266950},{"_id":"source/_posts/-Ubuntu-如何在Ubuntu底下安裝LINE.md","shasum":"3cee021396855f8fe8197733bf0365f926ecd7a8","modified":1515426266950},{"_id":"source/_posts/AtoI-ItoA-Sample-Code.md","shasum":"e538f822cd7166a694607e06a3e9822686a74918","modified":1515426266950},{"_id":"source/_posts/C-DB-Double-Link-List-Exercise-the-Double-Link-List.md","shasum":"3128c8f17c5369ffaac2127ee99e7aca868bf069","modified":1515426266950},{"_id":"source/_posts/C-Dynamic-Array-Exercise-to-operate-the-dyanmic-array.md","shasum":"7dfc904e341cf95c0dfbb2400b6ed36a06d3fa48","modified":1515426266950},{"_id":"source/_posts/C-Multi-Thread-How-to-use-pthread-create-and-pthread-join-to-operate-multi-thread.md","shasum":"4477f8f8fbdfc4ad6640eb23bf34f1db0f6dec50","modified":1515426266950},{"_id":"source/_posts/C-Mutex-Pthread-Interface-A-sample-code-for-pthread-mutex-interface.md","shasum":"d819b4c9e0726d030c8c0f610adf37ba3c08e854","modified":1515426266950},{"_id":"source/_posts/C-readlink.md","shasum":"fe3dd5dae14a4c9cd0e40327654531e2b190de3a","modified":1515426266950},{"_id":"source/_posts/HTTP-ASP-POST-分析網頁原始碼.md","shasum":"55c7750cc0c6a19552d3812ed299aa98fb6df5d3","modified":1515426266950},{"_id":"source/_posts/How-to-call-C-calss-member-function-from-C.md","shasum":"b30fc53576d519b10b641c7cfad482c09d72d6e3","modified":1515426266950},{"_id":"source/_posts/My-First-Post.md","shasum":"593229e01b51f2a72f400b986b3febef2ca17e01","modified":1515426266950},{"_id":"source/_posts/Netwoek-Scan-IP-nmap.md","shasum":"10ffd894f68d0f41a77e9be5f0fed48e064bf559","modified":1515426266950},{"_id":"source/_posts/Queue-Create-the-Queue-structure-by-the-Double-Link-List.md","shasum":"c7a7557721148b8bbec9761dc867771fdcbd5458","modified":1515426266950},{"_id":"source/_posts/Read-Write-Lock-Mutex-exercise-to-implement-the-read-write-lock-in-the-mutex.md","shasum":"9af3956a3bf3aca38f64713711c6045a2e80e3d2","modified":1515426266950},{"_id":"source/_posts/Stack-Create-the-Stack-Structure-by-Double-Link-List.md","shasum":"cb2ceed7a13ed0bf4a56a618a7130d6ea82b744b","modified":1515426266950},{"_id":"source/_posts/VIM-Backup-the-setting-of-VIM.md","shasum":"d464b3fc5fed9a18aa35f2da0486faacec0afcd8","modified":1515426266950},{"_id":"source/_posts/VIM-How-to-Copy-Paste-in-different-VIM-terminal.md","shasum":"43bc7b6017adf3e7b8097a7890e2eaa720d7dd0a","modified":1515426266950},{"_id":"source/_posts/test.md","shasum":"f644190ec22da87de7e1c0f3b7601891ca9daf1d","modified":1515426266950},{"_id":"source/_posts/test2.md","shasum":"1612893a0afe61352cfaf53d8a635208691a4fd5","modified":1515426295072},{"_id":"source/_posts/安裝R語言.md","shasum":"46d339d35b6b5f08de4252807c32a2f61b6b6b6f","modified":1515426266950},{"_id":"source/_posts/理財-基本面名詞.md","shasum":"e07082d535613fb4d43d644ebefae4d700699450","modified":1515426266950},{"_id":"source/doc/Pi_is_client_PC_is_server.tar.7z","shasum":"27475f4b4069045847230888214c67d61f0ce0d7","modified":1515426266950},{"_id":"source/doc/raspberry_case.pdf","shasum":"ab30580ab9874e61d975183e1ba35dad7483a8ed","modified":1515426266950},{"_id":"source/favicon.png","shasum":"d58cbd61973ae12029fba356561e677fbbcea800","modified":1515426266950},{"_id":"source/imgs/11245.jpg","shasum":"c92b186abaf5ba770bdb0c08e2d953eea95f5728","modified":1515426266950},{"_id":"source/imgs/fping.jpeg","shasum":"94666614b68792adffd14ccd6e8ec8b95db7b039","modified":1515426266986},{"_id":"source/imgs/ifconfig.jpeg","shasum":"3d57f7eda3d4f6ba0250a7c8af831a5be4bcb37e","modified":1515426266986},{"_id":"source/imgs/People.jpg","shasum":"85b7e88a3fe5063508167a83be5ad395bc5a98fa","modified":1515426266986},{"_id":"source/imgs/qt_tutoral.png","shasum":"442bfcdd100f9de76b16d8d19d416fccde24915a","modified":1515426266986},{"_id":"source/imgs/pthread_v1.png","shasum":"cc892be12de77f955006a7c3558c5c963d1487d9","modified":1515426266986},{"_id":"source/imgs/pthread_v2.png","shasum":"1b390da88503266a6fda5634ff64cd4fa182e919","modified":1515426266986},{"_id":"source/imgs/readelf_S.png","shasum":"6eb4bbf18b23455187a02298ffe4b9bcbd6306d9","modified":1515426266990},{"_id":"source/imgs/winetricks1.png","shasum":"0f0e04203e365cadd00dae1c33452e20f739cda9","modified":1515426266990},{"_id":"source/imgs/winetricks2.png","shasum":"e4f877c1ffea940de652af6a0d832905b85b0691","modified":1515426266990},{"_id":"source/imgs/winetricks3.png","shasum":"73cb804c644ef10649aee1bf11e1573556bce095","modified":1515426266994},{"_id":"themes/landscape/Gruntfile.js","shasum":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1515426266994},{"_id":"themes/landscape/LICENSE","shasum":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1515426266994},{"_id":"themes/landscape/README.md","shasum":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1515426266994},{"_id":"themes/landscape/_config.yml","shasum":"cd2de23aae81c5af9aa72e10de2d4561376c1504","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","shasum":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","shasum":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/archive.ejs","shasum":"d7de6421497ffaf65e4f5fe4bed71fcea51fde80","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/article.ejs","shasum":"4cbc085ab837dd9d23c4c532e9ae5ecd5e503887","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/footer.ejs","shasum":"6dd0503a764cfff4b36bde74b99ccd60a7341adc","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/head.ejs","shasum":"69c296de34e0d9370f6a9724d1673620ed98c44c","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/header.ejs","shasum":"1a8e3c2605dd8ec383a7e54221cfdb6642a2a0df","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","shasum":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/post/category.ejs","shasum":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/post/date.ejs","shasum":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","shasum":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","shasum":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","shasum":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1515426266994},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","shasum":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1515426266994},{"_id":"themes/landscape/layout/_widget/archive.ejs","shasum":"985fbeb01142b9d526cda8ebc372c1d361d69a6b","modified":1515426266994},{"_id":"themes/landscape/layout/_widget/category.ejs","shasum":"36ab37878129d152e3cbdeb839c08e52af1acd58","modified":1515426266994},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","shasum":"feba7c00fa59ba13bf870b358a499fde4473d335","modified":1515426266994},{"_id":"themes/landscape/layout/_widget/tag.ejs","shasum":"b3f321ddda6be2702a286d5b11af9533509506fb","modified":1515426266994},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","shasum":"34dc8cdd96cdb41dd11cb7513f13714373e5104a","modified":1515426266994},{"_id":"themes/landscape/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1515426266994},{"_id":"themes/landscape/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1515426266994},{"_id":"themes/landscape/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1515426266994},{"_id":"themes/landscape/layout/layout.ejs","shasum":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1515426266994},{"_id":"themes/landscape/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1515426266994},{"_id":"themes/landscape/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1515426266994},{"_id":"themes/landscape/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1515426266994},{"_id":"themes/landscape/package.json","shasum":"85358dc34311c6662e841584e206a4679183943f","modified":1515426266994},{"_id":"themes/landscape/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1515426266994},{"_id":"themes/landscape/source/css/_extend.styl","shasum":"4d726748335ea17af49facff56a9134d0f167376","modified":1515426266994},{"_id":"themes/landscape/source/css/_partial/archive.styl","shasum":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1515426266994},{"_id":"themes/landscape/source/css/_partial/article.styl","shasum":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1515426266994},{"_id":"themes/landscape/source/css/_partial/comment.styl","shasum":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1515426266994},{"_id":"themes/landscape/source/css/_partial/footer.styl","shasum":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1515426266994},{"_id":"themes/landscape/source/css/_partial/header.styl","shasum":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1515426266994},{"_id":"themes/landscape/source/css/_partial/highlight.styl","shasum":"36eefe6332b86b66023a9884b754d305235846b4","modified":1515426266994},{"_id":"themes/landscape/source/css/_partial/mobile.styl","shasum":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1515426266994},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","shasum":"890349df5145abf46ce7712010c89237900b3713","modified":1515426266994},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","shasum":"bc5487b9a0bfe5f745423331824d3f3637ccd430","modified":1515426266994},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","shasum":"b7bdc11effa98c6d88850eff75634e2ea9207c14","modified":1515426266994},{"_id":"themes/landscape/source/css/_util/grid.styl","shasum":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1515426266994},{"_id":"themes/landscape/source/css/_util/mixin.styl","shasum":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1515426266994},{"_id":"themes/landscape/source/css/_variables.styl","shasum":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1515426266994},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1515426266994},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1515426266994},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1515426267002},{"_id":"themes/landscape/source/css/style.styl","shasum":"278d1458b968a151c27b87643191d2d7a8129511","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1515426267082},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1515426267082},{"_id":"themes/landscape/source/js/script.js","shasum":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1515426267082},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1515426267002},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1515426267002},{"_id":"themes/landscape/source/css/images/banner_backup.jpg","shasum":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1515426267082},{"_id":"themes/landscape/source/css/images/banner.jpg","shasum":"f2911eafb3d025f037bc203fa9686bea07b935e3","modified":1515426267002},{"_id":"source/imgs/IMG_1252.JPG","shasum":"a4658f7426261f6ea84cad19e1994c9c6a2bf4fb","modified":1515426266986},{"_id":"source/imgs/IMG_1242.JPG","shasum":"52370637dd9848ed14190e30e8a492e745912b28","modified":1515426266958},{"_id":"source/imgs/IMG_1250.JPG","shasum":"b58fc944443754df5d5cfc7a5acbaf239947ac2f","modified":1515426266970},{"_id":"source/imgs/IMG_1251.JPG","shasum":"00a567ae11c6748d9c075f51970e01902e6999c0","modified":1515426266978},{"_id":"source/imgs/IMG_1249.JPG","shasum":"30a142f354db89c47243f6b32ff2ab84d50bcfaf","modified":1515426266958},{"_id":"themes/landscape/source/css/images/banner.xcf","shasum":"22e06f41c03a676a29c8cfab913f419b861fe9af","modified":1515426267078},{"_id":"public/imgs/winetricks3.png","modified":1515426332755,"shasum":"73cb804c644ef10649aee1bf11e1573556bce095"},{"_id":"public/imgs/winetricks2.png","modified":1515426332779,"shasum":"e4f877c1ffea940de652af6a0d832905b85b0691"},{"_id":"public/imgs/winetricks1.png","modified":1515426332806,"shasum":"0f0e04203e365cadd00dae1c33452e20f739cda9"},{"_id":"public/imgs/readelf_S.png","modified":1515426332815,"shasum":"6eb4bbf18b23455187a02298ffe4b9bcbd6306d9"},{"_id":"public/imgs/qt_tutoral.png","modified":1515426332824,"shasum":"442bfcdd100f9de76b16d8d19d416fccde24915a"},{"_id":"public/imgs/pthread_v2.png","modified":1515426332832,"shasum":"1b390da88503266a6fda5634ff64cd4fa182e919"},{"_id":"public/imgs/pthread_v1.png","modified":1515426332835,"shasum":"cc892be12de77f955006a7c3558c5c963d1487d9"},{"_id":"public/imgs/ifconfig.jpeg","modified":1515426332843,"shasum":"3d57f7eda3d4f6ba0250a7c8af831a5be4bcb37e"},{"_id":"public/imgs/fping.jpeg","modified":1515426332861,"shasum":"94666614b68792adffd14ccd6e8ec8b95db7b039"},{"_id":"public/imgs/People.jpg","modified":1515426332870,"shasum":"85b7e88a3fe5063508167a83be5ad395bc5a98fa"},{"_id":"public/imgs/IMG_1252.JPG","modified":1515426332922,"shasum":"a4658f7426261f6ea84cad19e1994c9c6a2bf4fb"},{"_id":"public/imgs/IMG_1251.JPG","modified":1515426333005,"shasum":"00a567ae11c6748d9c075f51970e01902e6999c0"},{"_id":"public/imgs/IMG_1250.JPG","modified":1515426333101,"shasum":"b58fc944443754df5d5cfc7a5acbaf239947ac2f"},{"_id":"public/imgs/IMG_1249.JPG","modified":1515426333148,"shasum":"30a142f354db89c47243f6b32ff2ab84d50bcfaf"},{"_id":"public/imgs/IMG_1242.JPG","modified":1515426333193,"shasum":"52370637dd9848ed14190e30e8a492e745912b28"},{"_id":"public/imgs/11245.jpg","modified":1515426333202,"shasum":"c92b186abaf5ba770bdb0c08e2d953eea95f5728"},{"_id":"public/favicon.png","modified":1515426333220,"shasum":"d58cbd61973ae12029fba356561e677fbbcea800"},{"_id":"public/doc/raspberry_case.pdf","modified":1515426333225,"shasum":"ab30580ab9874e61d975183e1ba35dad7483a8ed"},{"_id":"public/doc/Pi_is_client_PC_is_server.tar.7z","modified":1515426333229,"shasum":"27475f4b4069045847230888214c67d61f0ce0d7"},{"_id":"public/js/script.js","modified":1515426333244,"shasum":"2876e0b19ce557fca38d7c6f49ca55922ab666a1"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1515426333246,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1515426333258,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1515426333262,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1515426333285,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1515426333286,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1515426333288,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1515426333294,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1515426333296,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1515426333318,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1515426333354,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1515426333358,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1515426333366,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1515426333368,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1515426333374,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1515426333379,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1515426334679,"shasum":"72c689503ad51bdd97a5f8e68c5961afac8d4a37"},{"_id":"public/css/images/banner_backup.jpg","modified":1515426335135,"shasum":"843d9d47bf2b7b75495db11b3d765efaaae442a9"},{"_id":"public/css/images/banner.xcf","modified":1515426335245,"shasum":"22e06f41c03a676a29c8cfab913f419b861fe9af"},{"_id":"public/css/images/banner.jpg","modified":1515426335309,"shasum":"f2911eafb3d025f037bc203fa9686bea07b935e3"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1515426335337,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1515426335346,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1515426335361,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1515426335364,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/css/fonts/FontAwesome.otf","modified":1515426335370,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/2018/01/08/test2/index.html","modified":1515426335662,"shasum":"f6c80b8a39168713ac7c06be4acf504abe06eb35"},{"_id":"public/2018/01/08/test/index.html","modified":1515426335707,"shasum":"74ae7e9c03c287ad162b31ce08e8d68f9ddefef4"},{"_id":"public/2015/06/27/How-to-call-C-calss-member-function-from-C/index.html","modified":1515426335902,"shasum":"b8830ee3af61b0c2ddcafef95f0e0b7630dd05fe"},{"_id":"public/2015/06/21/安裝R語言/index.html","modified":1515426335970,"shasum":"0a332887fee46d5915c49d12d5c7faad27077d34"},{"_id":"public/2015/06/13/VIM-How-to-Copy-Paste-in-different-VIM-terminal/index.html","modified":1515426336060,"shasum":"608f9ba8bd6a88d778824f53b8e5f62212cc4008"},{"_id":"public/2015/05/28/AtoI-ItoA-Sample-Code/index.html","modified":1515426336132,"shasum":"48b831a6c1a922b6801ced84e4bba1f89cc0466f"},{"_id":"public/2015/05/07/Stack-Create-the-Stack-Structure-by-Double-Link-List/index.html","modified":1515426336225,"shasum":"c1bcfed19d8d4e19262b8c934e59dd13d89ebc6e"},{"_id":"public/2015/05/05/VIM-Backup-the-setting-of-VIM/index.html","modified":1515426336309,"shasum":"d06e0e60d606e811de65c34b3a7fc308c05d071b"},{"_id":"public/2015/05/05/Queue-Create-the-Queue-structure-by-the-Double-Link-List/index.html","modified":1515426336406,"shasum":"e8480aa4c458bb39a98fd4cf223c8118767764a1"},{"_id":"public/2015/05/02/C-DB-Double-Link-List-Exercise-the-Double-Link-List/index.html","modified":1515426336474,"shasum":"0c8fcc52fba5347a52dbbe9b7d862c3dac58b795"},{"_id":"public/2015/04/13/Read-Write-Lock-Mutex-exercise-to-implement-the-read-write-lock-in-the-mutex/index.html","modified":1515426336567,"shasum":"148c19ce07b7b9c9cddbe1ee80a91dbdbf12a06c"},{"_id":"public/2015/04/04/C-Mutex-Pthread-Interface-A-sample-code-for-pthread-mutex-interface/index.html","modified":1515426336634,"shasum":"8f9e44da8e47428a55c8487e6c220853a9a2524f"},{"_id":"public/2015/03/28/HTTP-ASP-POST-分析網頁原始碼/index.html","modified":1515426336695,"shasum":"8c61b05dd90648c8686bed8b3e10056e611b0fdb"},{"_id":"public/2015/03/24/Netwoek-Scan-IP-nmap/index.html","modified":1515426336715,"shasum":"2f1a4e78ccac55e848344e1ec398a75d38b25fb0"},{"_id":"public/2015/03/23/C-Multi-Thread-How-to-use-pthread-create-and-pthread-join-to-operate-multi-thread/index.html","modified":1515426336768,"shasum":"a7931ea1d3813c0c5001bfe87baa117adc52df2b"},{"_id":"public/2015/03/21/C-Dynamic-Array-Exercise-to-operate-the-dyanmic-array/index.html","modified":1515426336850,"shasum":"9f270c214438cb2ae31b5f51ed1af47ca37486d2"},{"_id":"public/2015/03/18/C-readlink/index.html","modified":1515426336904,"shasum":"1aec72c1659b93b471867dbf3f362b15243cf405"},{"_id":"public/2015/03/15/-QT-GUI-Hello-World/index.html","modified":1515426336964,"shasum":"6b31db35da1c7d5ac85311441c7ff33ebdc6cafe"},{"_id":"public/2015/03/13/-C-ELF-Attribute-Section/index.html","modified":1515426337020,"shasum":"ac4e25f359c61c122358bc5713b0bffad94c19e5"},{"_id":"public/2015/03/10/-C-Virtual-Function-Exercisels/index.html","modified":1515426337076,"shasum":"fc05b8128589c92585c372642188cf9282339ea2"},{"_id":"public/2015/03/10/-C-Virtual-Function-Inherit-My-Animal-World/index.html","modified":1515426337132,"shasum":"9fbd3ec5dcc828d314b3ebd235441f4212e51635"},{"_id":"public/2015/03/01/-Raspberry-Pi-Socket-Programming-and-GPIO/index.html","modified":1515426337215,"shasum":"39304d113abfd8f7307884369a03ea029df3fe3d"},{"_id":"public/2015/03/01/-Raspberry-Pi-Demod-Video/index.html","modified":1515426337271,"shasum":"3b34da8dea3b9a9241aabe0f13b28efe796f3c98"},{"_id":"public/2015/03/01/-Raspberry-Pi-Cam-Module-行車記錄器/index.html","modified":1515426337314,"shasum":"2d14b8e8b90693fff184426e42b46d2d8859125d"},{"_id":"public/2015/03/01/-Ubuntu-如何在Ubuntu底下安裝LINE/index.html","modified":1515426337354,"shasum":"85bf9dd661c67cf423b2a0f7464a69c79239198f"},{"_id":"public/2015/02/26/-Raspberry-Pi-製作PI的衣服-Case/index.html","modified":1515426337385,"shasum":"9986ecd8ead3599c03834f62ed6fdbb73b3e5c5d"},{"_id":"public/2015/02/25/-Raspberry-Pi-要如何自動的進入shell裏面-而不需要輸入密碼/index.html","modified":1515426337413,"shasum":"7e1e50ca946bd93819d3fdd1daba5cb54af86c1f"},{"_id":"public/2015/02/25/-Raspberry-Pi-How-to-get-the-root/index.html","modified":1515426337450,"shasum":"21313e407864f0d57960ad742b00f3d0ba82034c"},{"_id":"public/2015/02/25/-Network-fping的用法/index.html","modified":1515426337471,"shasum":"d200f333c2e0dd54d455b839d4484f997498fd5d"},{"_id":"public/2015/02/04/-GDB-基本指令/index.html","modified":1515426337484,"shasum":"08a5157fbed09a6611bd129d7260090e9113c4c6"},{"_id":"public/2015/01/29/-Pointer-Simple-concept/index.html","modified":1515426337525,"shasum":"9289efb76826ee4ee577d01fbf3d0ce9e2cf8d36"},{"_id":"public/2015/01/29/-GCC-MACRO-LOG/index.html","modified":1515426337563,"shasum":"9fc30fb6b662e9429acbb924882e0aac4c0507e3"},{"_id":"public/2015/01/16/理財-基本面名詞/index.html","modified":1515426337579,"shasum":"860a2058efb099c95d49db0e7178e5b8e681c71c"},{"_id":"public/2015/01/14/My-First-Post/index.html","modified":1515426337600,"shasum":"5bc482edc7f065df2db449c58d4a702c1dc34edd"},{"_id":"public/archives/index.html","modified":1515426337945,"shasum":"812d243fa334c15714c11de8705b6c0867c6ee75"},{"_id":"public/archives/page/2/index.html","modified":1515426338168,"shasum":"dec84f6aa2d571eb17d894ca2623fdc0b43a0e2d"},{"_id":"public/archives/page/3/index.html","modified":1515426338340,"shasum":"2e0beaff29846682629e6e147d2247a73776d3db"},{"_id":"public/archives/page/4/index.html","modified":1515426338398,"shasum":"7b8b11367463e01654e5c665ca06e71182ba7b4e"},{"_id":"public/archives/2015/index.html","modified":1515426338697,"shasum":"347ef6d5bc33ff29f0acebbea9eab424b0f77ef3"},{"_id":"public/archives/2015/page/2/index.html","modified":1515426338947,"shasum":"e0cc4a1519904c2c5d6c2bc7bb8e4e23303bc8e3"},{"_id":"public/archives/2015/page/3/index.html","modified":1515426339105,"shasum":"6ee3da2af061666c62be5c77ca9770cc258828b6"},{"_id":"public/archives/2015/page/4/index.html","modified":1515426339129,"shasum":"60cbb0cc85356b01849f26bed193033653dc0fc8"},{"_id":"public/archives/2015/01/index.html","modified":1515426339215,"shasum":"21eaf3bd4cb316042ba7840882d048cac1625da3"},{"_id":"public/archives/2015/02/index.html","modified":1515426339305,"shasum":"5b8a331c6ea5d524f78810e3111eaa7aee77a7da"},{"_id":"public/archives/2015/03/index.html","modified":1515426339522,"shasum":"fb0b2583c4db5633d351b89377352406732fed75"},{"_id":"public/archives/2015/03/page/2/index.html","modified":1515426339553,"shasum":"45fa5aced0d6ae0dc77a4b1ddc7dc69a770cc7a6"},{"_id":"public/archives/2015/04/index.html","modified":1515426339650,"shasum":"a9a53c1a876c3044886642a7452962f287c3efe3"},{"_id":"public/archives/2015/05/index.html","modified":1515426339929,"shasum":"fd35f6f0a47fd9f75efd11f0eec722384fce3548"},{"_id":"public/archives/2015/06/index.html","modified":1515426339991,"shasum":"59d54bc8a74d68026e619aa7b1557e18d383e043"},{"_id":"public/archives/2018/index.html","modified":1515426340032,"shasum":"50cc2c2a7fada5bf261ed3ea8c9daa84a1331591"},{"_id":"public/archives/2018/01/index.html","modified":1515426340101,"shasum":"1effeb54af08af6b9976693e0aa5385955190fe7"},{"_id":"public/categories/ELF/index.html","modified":1515426340132,"shasum":"d70641dbfa28ee283d99d687d23617afa277fcde"},{"_id":"public/categories/理財/index.html","modified":1515426340146,"shasum":"f6740f21de8caff82b44aaceff3bb6e328bdba5f"},{"_id":"public/categories/R/index.html","modified":1515426340168,"shasum":"dd7b9ea452b7be110900976a60016fac1d8bc360"},{"_id":"public/categories/VIM/index.html","modified":1515426340196,"shasum":"f88f923a509608207c002edf0fe130508171c2aa"},{"_id":"public/categories/vim/index.html","modified":1515426340240,"shasum":"819e85516440caf7aa6f17579a252b8b6c19db66"},{"_id":"public/categories/stack/index.html","modified":1515426340305,"shasum":"d9d5c1b10648b55bee41de670f0d2d40c71cf27f"},{"_id":"public/categories/Mutex/index.html","modified":1515426340381,"shasum":"59286396e8dec2accddf4f3e2227f8b155be33c6"},{"_id":"public/categories/Mutex/Read-Write-Lock/index.html","modified":1515426340433,"shasum":"ba68e9092105e7f73034a605e2c65baccd3654e2"},{"_id":"public/categories/queue/index.html","modified":1515426340544,"shasum":"ad24f0abb75490b6ed8c6a9826eae78aadb1a4c1"},{"_id":"public/categories/nmap/index.html","modified":1515426340564,"shasum":"250ee8cbf6d30d7f753552c3f2c68d84b987972a"},{"_id":"public/categories/ME/index.html","modified":1515426340575,"shasum":"12708cbb0b467907feab47357979b57b9574bd27"},{"_id":"public/categories/C/index.html","modified":1515426340683,"shasum":"476ecd314b9f81f88727291d82dda124f07e6989"},{"_id":"public/categories/POST/index.html","modified":1515426340696,"shasum":"edbc107e2394d0bb6dea6da0f7458ed946e217e5"},{"_id":"public/categories/C/uinstd/index.html","modified":1515426340731,"shasum":"50617b7cb6ecbfa7839971dd3a6e873713a66733"},{"_id":"public/categories/Pthread-Mutex/index.html","modified":1515426340782,"shasum":"99f0c52c1e3c1a509f2102efd16aba076755d25c"},{"_id":"public/categories/Multi-Thread/index.html","modified":1515426340807,"shasum":"d5b11a0cd255c0ba114640e476c2dac3a7447b1d"},{"_id":"public/categories/Dynamic-Array/index.html","modified":1515426340853,"shasum":"fd6b06a80d2791e77e06f77fc014015fa747cfb8"},{"_id":"public/categories/Double-Link-List/index.html","modified":1515426340908,"shasum":"6f5df876e2b4765ee6608f0131415277c7ea1339"},{"_id":"public/categories/c/index.html","modified":1515426340932,"shasum":"dd7afef1b9fd0ec2671facff4108a1dd6cdfdaf8"},{"_id":"public/categories/Ubuntu/index.html","modified":1515426340961,"shasum":"335430e54a7a7dbca0d5ecb12294672391d79d37"},{"_id":"public/categories/Raspberry-Pi/index.html","modified":1515426341039,"shasum":"3a190a4cfa6bd7067389855ad6c8a05017e33d81"},{"_id":"public/categories/QT/index.html","modified":1515426341075,"shasum":"862908698760507b257081f75c15bd952724d866"},{"_id":"public/categories/pointer/index.html","modified":1515426341092,"shasum":"c6cd61a3a81c403aa645224456e438b2c98f3e7f"},{"_id":"public/categories/Network/index.html","modified":1515426341107,"shasum":"450f20bfab8e30d40e9ed96cd449aa7ad657de1b"},{"_id":"public/categories/GDB/index.html","modified":1515426341134,"shasum":"b0b2845c3aff15c8b7b4d8977b6d6e0539988003"},{"_id":"public/categories/GCC/index.html","modified":1515426341171,"shasum":"f24a8d663b87a485a82c9394b479689fe9178cef"},{"_id":"public/index.html","modified":1515426341479,"shasum":"ce244ba3d7010f6537024ba02df599bcc8d7cbec"},{"_id":"public/page/2/index.html","modified":1515426341744,"shasum":"cecd87a2400489cb08412184d4e306e5526d59d0"},{"_id":"public/page/3/index.html","modified":1515426341945,"shasum":"a6e571a46ccdd298d2c64613dd3a4b48acf07b5f"},{"_id":"public/page/4/index.html","modified":1515426341989,"shasum":"f1be4247b6bde1150ee68153995a4d61aa947603"},{"_id":"public/sitemap.xml","modified":1515426341995,"shasum":"b50fd7ca25def144ecf6403da369f0f31571fa4b"},{"_id":"public/tags/C/index.html","modified":1515426342133,"shasum":"cc820df91fda6d942afc4a01236086a2c048c561"},{"_id":"public/tags/ELF/index.html","modified":1515426342175,"shasum":"eefbc2c88c375ad3df79054ed461ded17a389f74"},{"_id":"public/tags/Attribute-Section/index.html","modified":1515426342198,"shasum":"33cdcae6502eb0a1261f61c1ac6afbfbe2acdddc"},{"_id":"public/tags/readelf/index.html","modified":1515426342240,"shasum":"fa392881bb5d9f1e1e206c0b1ba3e4a6d9188cdb"},{"_id":"public/tags/Finance/index.html","modified":1515426342258,"shasum":"61a363b350983bf56ea245de9a0a7b9e572c7ddd"},{"_id":"public/tags/Stock/index.html","modified":1515426342316,"shasum":"d30c9f025575681e11dc0ed78674a5754fe06af6"},{"_id":"public/tags/R/index.html","modified":1515426342365,"shasum":"dbec3f3772215850b2b6bfa66d4629303a601ba1"},{"_id":"public/tags/Ubuntu/index.html","modified":1515426342448,"shasum":"4fdc85ba9177467de19cc76d100ba73ec489a185"},{"_id":"public/tags/VIM/index.html","modified":1515426342455,"shasum":"228869498957fec3c6565a88450801830efa64a4"},{"_id":"public/tags/vim/index.html","modified":1515426342512,"shasum":"369a0f6c97cc86f403e88a1f166ac453d94abe29"},{"_id":"public/tags/CTag/index.html","modified":1515426342552,"shasum":"2c5592951131c8a776f8956db6329c718dd50054"},{"_id":"public/tags/Cscope/index.html","modified":1515426342629,"shasum":"9a7ffb2e44b340aa40d105d5459ce289caaaff74"},{"_id":"public/tags/stack/index.html","modified":1515426342712,"shasum":"070073c1fcdeeb25cc14603ecbb60d100c7c6a36"},{"_id":"public/tags/double-link-list/index.html","modified":1515426342834,"shasum":"e2986cc0aff260d2138fae1271bc26f9930c3814"},{"_id":"public/tags/c/index.html","modified":1515426342909,"shasum":"e25c03340bd93168350046d38c6a1edf01461fbc"},{"_id":"public/tags/data-structure/index.html","modified":1515426343037,"shasum":"0f81eb42b131e149f74fc2ff32088bafb2c646c8"},{"_id":"public/tags/Mutex/index.html","modified":1515426343116,"shasum":"2b42e77d1e3329ebf0271a70c7a91cf36eac348e"},{"_id":"public/tags/Read-Write-Lock/index.html","modified":1515426343211,"shasum":"790f490e5dd191610ce0dd9afabbf31b46397100"},{"_id":"public/tags/queue/index.html","modified":1515426343290,"shasum":"3773fdfab6ce2e5d1a4aee58e8b00f46c12311b9"},{"_id":"public/tags/nmap/index.html","modified":1515426343305,"shasum":"7accd8369fb60ba23f9781ec0859d114b050b51f"},{"_id":"public/tags/network/index.html","modified":1515426343336,"shasum":"fdd0b4f24029a06fc170549144c2439e4193e1f9"},{"_id":"public/tags/fping/index.html","modified":1515426343351,"shasum":"afce1e29f76c7d0c1e3007303751aca770835737"},{"_id":"public/tags/geek/index.html","modified":1515426343401,"shasum":"8bf0cd9eb55e804e7e2f2efec9076363aac56f92"},{"_id":"public/tags/resume/index.html","modified":1515426343415,"shasum":"ccb78f91950db0bc71a50bead2e67bb470c7c67b"},{"_id":"public/tags/class/index.html","modified":1515426343458,"shasum":"e5b0ee57e3bb0ef71b9f7a84d6f8aa2cac99fcb5"},{"_id":"public/tags/POST/index.html","modified":1515426343553,"shasum":"297e84e170e50536734e752d215abf4154de6d12"},{"_id":"public/tags/HTTP/index.html","modified":1515426343592,"shasum":"5ce5ca7ad62ec4ebf59b36c21396fb1cc7686d16"},{"_id":"public/tags/ASP/index.html","modified":1515426343630,"shasum":"b221517d905d226ecd71aff1d70f8c50129b2879"},{"_id":"public/tags/readlink/index.html","modified":1515426343664,"shasum":"2c6e37031e58a0f3442a819120c38b043912223d"},{"_id":"public/tags/ls/index.html","modified":1515426343710,"shasum":"0328aa316f3a47250c28e1ef09c81abdd7d78069"},{"_id":"public/tags/Pthread/index.html","modified":1515426343765,"shasum":"3d223cccd2e3dcd0b361f4a2fdbe47e090743daf"},{"_id":"public/tags/Interface/index.html","modified":1515426343809,"shasum":"4e57d38c942451b3d62a1dde15d9d56853265062"},{"_id":"public/tags/pthread-create/index.html","modified":1515426343855,"shasum":"cd75ffd24fe42de4dfeaeb937f632180d5f33487"},{"_id":"public/tags/pthread-join/index.html","modified":1515426343887,"shasum":"5590618a458cc7ba5be0cea06fb2b7b16d600a40"},{"_id":"public/tags/multi-thread/index.html","modified":1515426343982,"shasum":"07ab823296411130c584d89a5436d631db3ff277"},{"_id":"public/tags/Dynamic-Array/index.html","modified":1515426344033,"shasum":"fc0bf3ecc056755923412f5c7cc39abd8a99b83f"},{"_id":"public/tags/realloc/index.html","modified":1515426344141,"shasum":"da01615a9e2fd86d50b14f99fcf726d7b257a8d7"},{"_id":"public/tags/DB/index.html","modified":1515426344198,"shasum":"fabece2dfbb0d3c1a9f25021a70d7fb4d03992b1"},{"_id":"public/tags/Double-Link-List/index.html","modified":1515426344290,"shasum":"8557979dbd5ff52920973b8e9dd6aa9af56df89f"},{"_id":"public/tags/atoi/index.html","modified":1515426344347,"shasum":"c079d17340a717d8cc3562c612673c3dc083c55e"},{"_id":"public/tags/itoa/index.html","modified":1515426344380,"shasum":"421634ee8341614a0948c0eb2755937c268d7ab1"},{"_id":"public/tags/Line/index.html","modified":1515426344402,"shasum":"2c021a4f0145ab63f40eddc68cb9725bd8ed67d1"},{"_id":"public/tags/Raspberry-Pi/index.html","modified":1515426344491,"shasum":"2701ce9e684226457a4ced3db456dc0035b54ae5"},{"_id":"public/tags/Case/index.html","modified":1515426344512,"shasum":"e788d51c68284311b845dfbd3a2ad0c1557c35e1"},{"_id":"public/tags/Socket/index.html","modified":1515426344613,"shasum":"b4513548c75fcef5bbc1760f150fbe16f98a50ac"},{"_id":"public/tags/GPIO/index.html","modified":1515426344691,"shasum":"40fd4b52b55b38f0dfd3aefdbf690d2ba0d29264"},{"_id":"public/tags/root/index.html","modified":1515426344714,"shasum":"25367d554f142fce9e4b1f424033540b0f4d9b19"},{"_id":"public/tags/Cam-Module/index.html","modified":1515426344754,"shasum":"0f2e2cd935532d0f84cb55895dd9c4b2b8bb4e8a"},{"_id":"public/tags/QT/index.html","modified":1515426344803,"shasum":"ab30977b4ea30e1cb7c79b831fc0343828255525"},{"_id":"public/tags/GUI/index.html","modified":1515426344834,"shasum":"313d91d17196817def54d9d5dbe62e8e3b5aec8e"},{"_id":"public/tags/compiler/index.html","modified":1515426344884,"shasum":"e62bc5e5b7d4d33fc249fb659f74cb93fbb99d32"},{"_id":"public/tags/pointer/index.html","modified":1515426344906,"shasum":"aa55b1b4b601c062b1d1c79c65c50005db50deb6"},{"_id":"public/tags/ubuntu/index.html","modified":1515426344922,"shasum":"f222b270d99f58c7589e92e3f77e5b5fd3e32021"},{"_id":"public/tags/GDB/index.html","modified":1515426344943,"shasum":"fee5d74818622c8ae7dcdf0e2e4d7406ad3d57be"},{"_id":"public/tags/GCC/index.html","modified":1515426344969,"shasum":"995e124e6d0ee8a29fb4c78647cb16993a650cec"},{"_id":"public/tags/Virtual-Function/index.html","modified":1515426345034,"shasum":"cfe79f40176c1c5feee36f0dd134a99b4e10a4f3"},{"_id":"public/tags/Inherit/index.html","modified":1515426345097,"shasum":"9a71ee0c0b7216bfa3b540bf0c870549627aac26"},{"_id":"public/tags/Dynamical-Binding/index.html","modified":1515426345138,"shasum":"bb8ac1056a27a37cc38a343208de0c85fdd96018"},{"_id":"public/tags/Dynamic-Binding/index.html","modified":1515426345167,"shasum":"d5f5ec5ff0cc81a7336607ca9aa43bd292a2a372"}],"Category":[{"name":"ELF","_id":"cjc6dp22n000135gg3uyc1cby"},{"name":"理財","_id":"cjc6dp23s000c35ggfzjat1a5"},{"name":"R","_id":"cjc6dp240000h35ggxmog3lmi"},{"name":"VIM","_id":"cjc6dp24o000s35gg0ds9zecq"},{"name":"vim","_id":"cjc6dp24z000x35ggz6wc1a7w"},{"name":"stack","_id":"cjc6dp25e001635gg4gnv7nrz"},{"name":"Mutex","_id":"cjc6dp25v001h35ggsd6rq7p1"},{"name":"Read/Write Lock","parent":"cjc6dp25v001h35ggsd6rq7p1","_id":"cjc6dp25w001k35gg199xr777"},{"name":"queue","_id":"cjc6dp265001r35gg6zsx3hz1"},{"name":"nmap","_id":"cjc6dp26c001y35gglgt7ecaf"},{"name":"ME","_id":"cjc6dp26h002735ggrv01qiry"},{"name":"C","_id":"cjc6dp26m002e35gg1a92dva2"},{"name":"POST","_id":"cjc6dp26u002m35ggn0gzthx7"},{"name":"uinstd","parent":"cjc6dp26m002e35gg1a92dva2","_id":"cjc6dp26z002v35gg2k16c836"},{"name":"Pthread_Mutex","_id":"cjc6dp274003435gggq99nlw2"},{"name":"Multi-Thread","_id":"cjc6dp27f003d35ggc2te5yr5"},{"name":"Dynamic Array","_id":"cjc6dp27s003n35gglq5pm3f1"},{"name":"Double Link List","_id":"cjc6dp283003v35gg7gzxb4uo"},{"name":"c","_id":"cjc6dp28f004335ggehx02p6v"},{"name":"Ubuntu","_id":"cjc6dp28k004a35ggnewdiga2"},{"name":"Raspberry Pi","_id":"cjc6dp29a004g35ggkqw1ooi0"},{"name":"QT","_id":"cjc6dp2a2005a35ggllyx91de"},{"name":"pointer","_id":"cjc6dp2ab005k35ggtld6jjhl"},{"name":"Network","_id":"cjc6dp2ah005q35ggm2j6figc"},{"name":"GDB","_id":"cjc6dp2au005w35ggr2nnmsny"},{"name":"GCC","_id":"cjc6dp2b6006135ggri7lq2an"},{"name":"C++","_id":"cjc6dp2bm006635gg0g4rgdkp"}],"Data":[],"Page":[],"Post":[{"title":"[C][ELF] Attribute Section","date":"2015-03-12T16:58:10.000Z","toc":true,"_content":"\n## 目的\n這幾天看到有人的code, 在資料或是function前面多加 attribute 的關鍵字\n\n所以很好奇， 這東東是幹什麼用的. 花了一點時間讀了相關的[blog](http://enginechang.logdown.com/posts/248172-linker-loader-library), 自己消化了一下, 寫了測試的code,  來驗證一下. \n\n自定section 的目的,  應該是要提高cache 的使用效率. 這樣的話, 但是相對的\n\n你要code size會變大,  畢竟你多了section header 的資料. \n\n## Background\n在開始前可能要先明白什麼叫做section, 什麼是objuct code, 什麼ELF檔, \n\nobjuct code 就是我們.c 檔compiler 過後的檔案， 假如在透過linker 的話, \n\n就會將所有的.o檔, reloate 成elf. \n\n一個.o 檔其實就可以把他拆解成許多的section. 相同特性的資料, 就會擺成相同的secion上面. \n\n那我們是否可以自定自己的section 呢, 答案是可以的, 讃阿～～\n\n就是透過attribute 來告知compiler, 我要自定自己的section.\n\n## 快接近重點了XDD\n\n首先我寫了一個程式, 兩個file, 每個file, 任一個function.\n\n其實只是去印 global array 的值,  只是我將 int_array 放到我自定的section當中, \n\n我取名成 .sheldon.data \n\n___main.c___\n\n```\n//***********************\n// Arthur : Sheldon Peng\n// date : 2015/03/12\n//************************\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define array_size 5\n__attribute__((section(\".sheldon.data\"))) int int_array[array_size] = {0,1,2,3,4};\n\nchar test_bss[1024];\n\nvoid main(void)\n{\n  int size = array_size;\n  int_array[size-1] = 5;\n\n  memset(test_bss, 'a', sizeof(test_bss));\n\n  printf(\"Hello, this is attribute section test \\r\\n\");\n  extern void printf_array(int*,int);\n  printf_array(int_array, size);\n}\n```\n___printf_array.c___\n\n```\n#include <stdio.h>\n\nvoid printf_array(int* ptr, int size)\n{\n  printf(\"[%s] \\r\\n\", __FUNCTION__); \n  int i = 0;\n  for (i=0; i<size; i++)\n  {\n    printf(\"%d, \", ptr[i]);\n  }\n  printf(\"\\n done \\n\");\n}\n\n```\n\n\n___常用指令___\n1. readelf -s   : 讀這個elf/object 的symbol \n2. readelf -S   : 讀這個elf/object 的Section\n3. readelf -a   : 讀所有的資訊\n\n\n## 來驗證看看囉!!\n\n先將兩個 .c 檔個別的compiler\n\n```\ngcc -c print_array.c              // 產生 print_array.o (object)\ngcc -c main.c                     // 產生 main.o (object)\ngcc main.o print_array.o -o main  // 產生 main   (elf)\n\n```\n\n透過下 readelf -S 來觀察自定的section. \n\n是不是多了 .sheldon.data XDD\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/readelf_S.png %}\n\n其實還有非常多東西可以看, 像是還沒link前的symble 有什麼不一樣.\n\n某些default 的section各別代表什麼意義. 要如何找出， 你這個elf 有哪些dependency 的lib...\n\n非常非常多,  我也搞的物煞煞. 哈, 所以就走一步算一步.\n\n\n","source":"_posts/-C-ELF-Attribute-Section.md","raw":"title: \"[C][ELF] Attribute Section\"\ndate: 2015-03-13 00:58:10\ncategories: ELF \ntags:\n- C\n- ELF\n- Attribute Section\n- readelf\ntoc: true\n---\n\n## 目的\n這幾天看到有人的code, 在資料或是function前面多加 attribute 的關鍵字\n\n所以很好奇， 這東東是幹什麼用的. 花了一點時間讀了相關的[blog](http://enginechang.logdown.com/posts/248172-linker-loader-library), 自己消化了一下, 寫了測試的code,  來驗證一下. \n\n自定section 的目的,  應該是要提高cache 的使用效率. 這樣的話, 但是相對的\n\n你要code size會變大,  畢竟你多了section header 的資料. \n\n## Background\n在開始前可能要先明白什麼叫做section, 什麼是objuct code, 什麼ELF檔, \n\nobjuct code 就是我們.c 檔compiler 過後的檔案， 假如在透過linker 的話, \n\n就會將所有的.o檔, reloate 成elf. \n\n一個.o 檔其實就可以把他拆解成許多的section. 相同特性的資料, 就會擺成相同的secion上面. \n\n那我們是否可以自定自己的section 呢, 答案是可以的, 讃阿～～\n\n就是透過attribute 來告知compiler, 我要自定自己的section.\n\n## 快接近重點了XDD\n\n首先我寫了一個程式, 兩個file, 每個file, 任一個function.\n\n其實只是去印 global array 的值,  只是我將 int_array 放到我自定的section當中, \n\n我取名成 .sheldon.data \n\n___main.c___\n\n```\n//***********************\n// Arthur : Sheldon Peng\n// date : 2015/03/12\n//************************\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define array_size 5\n__attribute__((section(\".sheldon.data\"))) int int_array[array_size] = {0,1,2,3,4};\n\nchar test_bss[1024];\n\nvoid main(void)\n{\n  int size = array_size;\n  int_array[size-1] = 5;\n\n  memset(test_bss, 'a', sizeof(test_bss));\n\n  printf(\"Hello, this is attribute section test \\r\\n\");\n  extern void printf_array(int*,int);\n  printf_array(int_array, size);\n}\n```\n___printf_array.c___\n\n```\n#include <stdio.h>\n\nvoid printf_array(int* ptr, int size)\n{\n  printf(\"[%s] \\r\\n\", __FUNCTION__); \n  int i = 0;\n  for (i=0; i<size; i++)\n  {\n    printf(\"%d, \", ptr[i]);\n  }\n  printf(\"\\n done \\n\");\n}\n\n```\n\n\n___常用指令___\n1. readelf -s   : 讀這個elf/object 的symbol \n2. readelf -S   : 讀這個elf/object 的Section\n3. readelf -a   : 讀所有的資訊\n\n\n## 來驗證看看囉!!\n\n先將兩個 .c 檔個別的compiler\n\n```\ngcc -c print_array.c              // 產生 print_array.o (object)\ngcc -c main.c                     // 產生 main.o (object)\ngcc main.o print_array.o -o main  // 產生 main   (elf)\n\n```\n\n透過下 readelf -S 來觀察自定的section. \n\n是不是多了 .sheldon.data XDD\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/readelf_S.png %}\n\n其實還有非常多東西可以看, 像是還沒link前的symble 有什麼不一樣.\n\n某些default 的section各別代表什麼意義. 要如何找出， 你這個elf 有哪些dependency 的lib...\n\n非常非常多,  我也搞的物煞煞. 哈, 所以就走一步算一步.\n\n\n","slug":"-C-ELF-Attribute-Section","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp22b000035gg3t699hlf"},{"title":"理財-基本面名詞-損益表","date":"2015-01-16T00:49:39.000Z","toc":true,"_content":"#損益表\n要看一間公司賺不賺錢, 就可以從損益表, 一窺究竟. 損益表是由許多經濟名詞組合\n而成, 所以要想從損益表來得知公司情況好壞的話, \n這些名詞是必須要清楚明白的.\n\n**營業收入** = 公司從客戶上賺的錢\n\n**營業成本** = (直接成本) 生產產品所需要的原物料成本, 經營公司所用倒的人事成本, 公司所在辦公大樓的租金\n\n**營業毛利** = 營業收入-營業成本\n\n**營業費用** = （間接成本）行銷, 研發經費\n\n**營業外收入** = 與本業無關的收入\n\n**營業外支出** = 與本業無關的支出\n\n**營業外收支** = 營業外收入 - 營業外支出\n\n**稅前純益** = 營業毛利 - 營業費用 - 營業外收支\n\n**稅後純益** = 稅後純益 - 稅\n\n## EPS (Earning Per Share) , 公司最後就會用稅後純益來決定每一個股要發多少錢給各股東.\n\n\n\n","source":"_posts/理財-基本面名詞.md","raw":"title: 理財-基本面名詞-損益表\ndate: 2015-01-16 08:49:39\ncategories: 理財\ntags:\n- Finance\ntoc: true\n---\n#損益表\n要看一間公司賺不賺錢, 就可以從損益表, 一窺究竟. 損益表是由許多經濟名詞組合\n而成, 所以要想從損益表來得知公司情況好壞的話, \n這些名詞是必須要清楚明白的.\n\n**營業收入** = 公司從客戶上賺的錢\n\n**營業成本** = (直接成本) 生產產品所需要的原物料成本, 經營公司所用倒的人事成本, 公司所在辦公大樓的租金\n\n**營業毛利** = 營業收入-營業成本\n\n**營業費用** = （間接成本）行銷, 研發經費\n\n**營業外收入** = 與本業無關的收入\n\n**營業外支出** = 與本業無關的支出\n\n**營業外收支** = 營業外收入 - 營業外支出\n\n**稅前純益** = 營業毛利 - 營業費用 - 營業外收支\n\n**稅後純益** = 稅後純益 - 稅\n\n## EPS (Earning Per Share) , 公司最後就會用稅後純益來決定每一個股要發多少錢給各股東.\n\n\n\n","slug":"理財-基本面名詞","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp23p000b35ggmypydxz3"},{"title":"安裝R語言","date":"2015-06-21T10:02:40.000Z","toc":true,"_content":"\n# Purpose\n\n最近股市賠錢,覺得應該是要改變自己對投資的態度,要更積極一點\n\n而且需要明白如何透過一些分析的軟體來作投資策略分析.\n\n在網路上尋找到一個數據分析的軟體, 稱作\"R語言\"\n\n{% blockquote Wikipedia https://zh.wikipedia.org/wiki/R%E8%AF%AD%E8%A8%80 %}\nR語言，一種自由軟體程式語言與操作環境，主要用於統計分析、繪圖、資料探勘。R本來是由來自紐西蘭奧克蘭大學的Ross Ihaka和Robert Gentleman開發（也因此稱為R），現在由「R開發核心團隊」負責開發。R是基於S語言的一個GNU計劃專案，所以也可以當作S語言的一種實作，通常用S語言編寫的代碼都可以不作修改的在R環境下執行。R的語法是來自Scheme。\n{% endblockquote%}\n\n# 安裝\n\n## 添加新的套件source 到sources.list\n\n```\nsudo vim /etc/apt/sources.list\ndeb http://<my.favorite.cran.mirror>/bin/linux/ubuntu trusty/\n```\n<my.favorite.cran.mirror> 改成適當的mirror {% link 聯結 http://cran.r-project.org/mirrors.html %}\n\n假如在臺灣的話,參考底下\n\n___Taiwan___\n\nhttp://ftp.yzu.edu.tw/CRAN/ Department of Computer Science and Engineering, Yuan Ze University\nhttp://cran.csie.ntu.edu.tw/  National Taiwan University, Taipei\n\n## 更新AP\n輸入底下command\n```\nsudo apt-get update \n```\n\n假如你遇到底下問題,無法正常update的話\n```\nW: GPG 錯誤: http://cran.csie.ntu.edu.tw trusty/ Release: 由於無法取得它們的公鑰，以下簽章無法進行驗證： NO_PUBKEY 51716619E084DAB9\n```\n\n將51716619E084DAB9改成你在terminal看到的key, 並輸入底下cmd.\n```\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys FAF69C646FF368B7\nsudo apt-get update\n```\n\n## 安裝 R \n\n```\nsudo apt-get install r-base\n```\n\n","source":"_posts/安裝R語言.md","raw":"title: \"安裝R語言\"\ndate: 2015-06-21 18:02:40\ncategories:\n- R\ntags:\n- Stock\n- R\n- Ubuntu\ntoc: true\n---\n\n# Purpose\n\n最近股市賠錢,覺得應該是要改變自己對投資的態度,要更積極一點\n\n而且需要明白如何透過一些分析的軟體來作投資策略分析.\n\n在網路上尋找到一個數據分析的軟體, 稱作\"R語言\"\n\n{% blockquote Wikipedia https://zh.wikipedia.org/wiki/R%E8%AF%AD%E8%A8%80 %}\nR語言，一種自由軟體程式語言與操作環境，主要用於統計分析、繪圖、資料探勘。R本來是由來自紐西蘭奧克蘭大學的Ross Ihaka和Robert Gentleman開發（也因此稱為R），現在由「R開發核心團隊」負責開發。R是基於S語言的一個GNU計劃專案，所以也可以當作S語言的一種實作，通常用S語言編寫的代碼都可以不作修改的在R環境下執行。R的語法是來自Scheme。\n{% endblockquote%}\n\n# 安裝\n\n## 添加新的套件source 到sources.list\n\n```\nsudo vim /etc/apt/sources.list\ndeb http://<my.favorite.cran.mirror>/bin/linux/ubuntu trusty/\n```\n<my.favorite.cran.mirror> 改成適當的mirror {% link 聯結 http://cran.r-project.org/mirrors.html %}\n\n假如在臺灣的話,參考底下\n\n___Taiwan___\n\nhttp://ftp.yzu.edu.tw/CRAN/ Department of Computer Science and Engineering, Yuan Ze University\nhttp://cran.csie.ntu.edu.tw/  National Taiwan University, Taipei\n\n## 更新AP\n輸入底下command\n```\nsudo apt-get update \n```\n\n假如你遇到底下問題,無法正常update的話\n```\nW: GPG 錯誤: http://cran.csie.ntu.edu.tw trusty/ Release: 由於無法取得它們的公鑰，以下簽章無法進行驗證： NO_PUBKEY 51716619E084DAB9\n```\n\n將51716619E084DAB9改成你在terminal看到的key, 並輸入底下cmd.\n```\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys FAF69C646FF368B7\nsudo apt-get update\n```\n\n## 安裝 R \n\n```\nsudo apt-get install r-base\n```\n\n","slug":"安裝R語言","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp23z000g35gg478cthw9"},{"title":"test2","date":"2018-01-08T15:44:55.000Z","toc":true,"_content":"","source":"_posts/test2.md","raw":"title: \"test2\"\ndate: 2018-01-08 23:44:55\ncategories:\ntags:\ntoc: true\n---\n","slug":"test2","published":1,"updated":"2018-01-08T15:44:55.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp247000p35ggny2m7f7k"},{"title":"test","date":"2018-01-08T15:39:10.000Z","toc":true,"_content":"","source":"_posts/test.md","raw":"title: \"test\"\ndate: 2018-01-08 23:39:10\ncategories:\ntags:\ntoc: true\n---\n","slug":"test","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp24g000q35ggjsqdiemp"},{"title":"[VIM]How to Copy&Paste in different VIM terminal","date":"2015-06-13T08:43:22.000Z","toc":true,"_content":"\n# PURPOSE\n\nRecent I want to copy&past in different VIM terminals, so I spent a few time to figure out how to do that. w\n\n# How TO Do \n\nThere is a simple way to do.\n\n## Check your VIM information first \n\n1. open the shell terminal \n2. type the following command to check the vim information\n\n```\n   vim --version | grep xterm_clipboard\n```\n\nIf you find the below message, it tells you that the xterm_clo[board of VIM is off\n\n```\n   -xterm_clipboard\n```\n\n## Install the VIM-Plugin to enable the feature.\n\n```\n   sudo apt-get install vim-athena\n   sudo apt-get install vim-gnome\n   sudo apt-get install vim-gtk\n```\n","source":"_posts/VIM-How-to-Copy-Paste-in-different-VIM-terminal.md","raw":"title: \"[VIM]How to Copy&Paste in different VIM terminal\"\ndate: 2015-06-13 16:43:22\ncategories:\n- VIM \ntags:\n- VIM \ntoc: true\n---\n\n# PURPOSE\n\nRecent I want to copy&past in different VIM terminals, so I spent a few time to figure out how to do that. w\n\n# How TO Do \n\nThere is a simple way to do.\n\n## Check your VIM information first \n\n1. open the shell terminal \n2. type the following command to check the vim information\n\n```\n   vim --version | grep xterm_clipboard\n```\n\nIf you find the below message, it tells you that the xterm_clo[board of VIM is off\n\n```\n   -xterm_clipboard\n```\n\n## Install the VIM-Plugin to enable the feature.\n\n```\n   sudo apt-get install vim-athena\n   sudo apt-get install vim-gnome\n   sudo apt-get install vim-gtk\n```\n","slug":"VIM-How-to-Copy-Paste-in-different-VIM-terminal","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp24n000r35gggmqwtriv"},{"title":"[VIM] Backup the setting of VIM","date":"2015-05-05T00:53:27.000Z","toc":true,"_content":"# Purpose\n\n最近感覺電腦快往生了,所以現在未雨愁繆，先將\n\n自己常用的vim setting作一下備份，順便將ctag和cscope\n\n常用的script作一下記錄，假如有人有興趣也可以拿去發揚光大.\n\n## .vimrc \n\n```\n\" set up pathogen, https://github.com/tpope/vim-pathogen\nfiletype on \" without this vim emits a zero exit status, later, because of :ft off\nfiletype off\ncall pathogen#infect()\nfiletype plugin indent on\n\" don't bother with vi compatibility\nset nocompatible\n\n\" enable syntax highlighting\nsyntax enable\n\n\" auto come back the last file location\n if has(\"autocmd\")\n     autocmd BufRead *.txt set tw=78\n         autocmd BufReadPost *\n             \\ if line(\"'\\\"\") > 0 && line (\"'\\\"\") <= line(\"$\") |\n    \\   exe \"normal g'\\\"\" |\n    \\ endif\nendif\n\n\nlet g:session_autosave = 'yes'\n\nset autoindent\nset autoread                                                 \" reload files when changed on disk, i.e. via `git checkout`\nset backspace=2                                              \" Fix broken backspace in some setups\nset backupcopy=yes                                           \" see :help crontab\nset clipboard=unnamed                                        \" yank and paste with the system clipboard\nset directory-=.                                             \" don't store swapfiles in the current directory\nset encoding=utf-8\nset expandtab                                                \" expand tabs to spaces\nset ignorecase                                               \" case-insensitive search\nset incsearch                                                \" search as you type\nset laststatus=2                                             \" always show statusline\nset list                                                     \" show trailing whitespace\nset listchars=tab:▸\\ ,trail:▫\nset number                                                   \" show line numbers\nset ruler                                                    \" show where you are\nset scrolloff=3                                              \" show context above/below cursorline\nset shiftwidth=2                                             \" normal mode indentation commands use 2 spaces\nset showcmd\nset smartcase                                                \" case-sensitive search if any caps\nset softtabstop=2                                            \" insert mode tab and backspace use 2 spaces\nset tabstop=8                                                \" actual tabs occupy 8 characters\nset wildignore=log/**,node_modules/**,target/**,tmp/**,*.rbc\nset wildmenu                                                 \" show a navigable menu for tab completion\nset wildmode=longest,list,full\n\nset modifiable\nset write\nset hlsearch\nset ic\nset clipboard=unnamedplus\n\" Enable basic mouse behavior such as resizing buffers.\nset mouse=a\nif exists('$TMUX')  \" Support resizing in tmux\n  set ttymouse=xterm2\nendif\n\n\" keyboard shortcuts\nlet mapleader = ','\nmap <C-h> <C-w>h\nmap <C-j> <C-w>j\nmap <C-k> <C-w>k\nmap <C-l> <C-w>l\nmap <leader>l :Align\nnmap <leader>a :Ack \nnmap <leader>b :CtrlPBuffer<CR>\nnmap <leader>d :NERDTreeToggle<CR>\nnmap <leader>f :NERDTreeFind<CR>\nnmap <leader>t :CtrlP<CR>\nnmap <leader>s :cs find c <C-R>=expand(\"<cword>\")<CR><CR>\nnmap <leader>e :cs find t <C-R>=expand(\"<cword>\")<CR><CR>\nnmap <leader>T :CtrlPClearCache<CR>:CtrlP<CR>\nnmap <leader>] :TagbarToggle<CR>\nnmap <leader><space> :call whitespace#strip_trailing()<CR>\nnmap <leader>g :GitGutterToggle<CR>\nnmap <leader>c <Plug>Kwbd\nmap <silent> <leader>V :source ~/.vimrc<CR>:filetype detect<CR>:exe \":echo 'vimrc reloaded'\"<CR>\n\n\" NERDTree seeting\nlet NERDTreeShowHidden=1\n\n\n\"将:cs find\n\"c等Cscope查找命令映射为<C-_>c等快捷键（按法是先按Ctrl+Shift+-,然后很快再按下c）\n\"nmap <C-_>s :cs find s <C-R>=expand(\"<cword>\")<CR><CR>:copen<CR><CR>\n\"nmap <C-_>g :cs find g <C-R>=expand(\"<cword>\")<CR><CR>\n\"nmap <C-_>d :cs find d <C-R>=expand(\"<cword>\")<CR><CR>:copen<CR><CR>\n\"nmap <C-_>c :cs find c <C-R>=expand(\"<cword>\")<CR><CR>:copen<CR><CR>\n\"nmap <C-_>t :cs find t <C-R>=expand(\"<cword>\")<CR><CR>:copen<CR><CR>\n\"nmap <C-_>e :cs find e <C-R>=expand(\"<cword>\")<CR><CR>:copen<CR><CR>\n\"nmap <C-_>f :cs find f <C-R>=expand(\"<cfile>\")<CR><CR>\n\"nmap <C-_>i :cs find i <C-R>=expand(\"<cfile>\")<CR><CR>:copen<CR><CR>\n\n\n\" plugin settings\nlet g:ctrlp_match_window = 'order:ttb,max:20'\nlet g:NERDSpaceDelims=1\nlet g:gitgutter_enabled = 0\n\n\" Use The Silver Searcher https://github.com/ggreer/the_silver_searcher\nif executable('ag')\n  let g:ackprg = 'ag --nogroup --column'\n\n  \" Use Ag over Grep\n  set grepprg=ag\\ --nogroup\\ --nocolor\n\n  \" Use ag in CtrlP for listing files. Lightning fast and respects .gitignore\n  let g:ctrlp_user_command = 'ag %s -l --nocolor -g \"\"'\nendif\n\n\" fdoc is yaml\nautocmd BufRead,BufNewFile *.fdoc set filetype=yaml\n\" md is markdown\nautocmd BufRead,BufNewFile *.md set filetype=markdown\n\" extra rails.vim help\nautocmd User Rails silent! Rnavcommand decorator      app/decorators            -glob=**/* -suffix=_decorator.rb\nautocmd User Rails silent! Rnavcommand observer       app/observers             -glob=**/* -suffix=_observer.rb\nautocmd User Rails silent! Rnavcommand feature        features                  -glob=**/* -suffix=.feature\nautocmd User Rails silent! Rnavcommand job            app/jobs                  -glob=**/* -suffix=_job.rb\nautocmd User Rails silent! Rnavcommand mediator       app/mediators             -glob=**/* -suffix=_mediator.rb\nautocmd User Rails silent! Rnavcommand stepdefinition features/step_definitions -glob=**/* -suffix=_steps.rb\n\" automatically rebalance windows on vim resize\nautocmd VimResized * :wincmd =\n\n\" Fix Cursor in TMUX\nif exists('$TMUX')\n  let &t_SI = \"\\<Esc>Ptmux;\\<Esc>\\<Esc>]50;CursorShape=1\\x7\\<Esc>\\\\\"\n  let &t_EI = \"\\<Esc>Ptmux;\\<Esc>\\<Esc>]50;CursorShape=0\\x7\\<Esc>\\\\\"\nelse\n  let &t_SI = \"\\<Esc>]50;CursorShape=1\\x7\"\n  let &t_EI = \"\\<Esc>]50;CursorShape=0\\x7\"\nendif\n\n\" Go crazy!\nif filereadable(expand(\"~/.vimrc.local\"))\n  \" In your .vimrc.local, you might like:\n  \"\n  \" set autowrite\n  \" set nocursorline\n  \" set nowritebackup\n  \" set whichwrap+=<,>,h,l,[,] \" Wrap arrow keys between lines\n  \"\n  \" autocmd! bufwritepost .vimrc source ~/.vimrc\n  \" noremap! jj <ESC>\n  source ~/.vimrc.local\nendif\n```\n## .vimrc.local\n\n```\n\"set nocursorline \" don't highlight current line\nset cursorline\n\n\" keyboard shortcuts\ninoremap jj <ESC>\n\n\" gui settings\nif (&t_Co == 256 || has('gui_running'))\n  if ($TERM_PROGRAM == 'iTerm.app')\n    colorscheme solarized\n  else\n    colorscheme desert\n  endif\nendif\n\"\"\"\n\" Cscope settings\nif has(\"cscope\")\n  let i = 1\n  let path_depth = 20\n    while i < path_depth\n      if filereadable(\"cscope.out\")\n        let db = getcwd() . \"/cscope.out\"\n        echo db\n        let $CSCOPE_DB = db\n        cs add $CSCOPE_DB\n        let i = 20\n      else\n        cd ..\n      let i += 1\n      endif\n    endwhile\nendif\n```\n\n## sr\n\n```\n#!/bin/sh\nFILE_LIST=file_list\ntemp_str=NULL\n\nfor i in \"$@\"\ndo\n  if [ -n \"$i\" ]; then\n    temp_str=$i\n    if [ \"$1\" = \"$i\" ]; then\n      echo \"First Source code directory :\" \"$1\"\n      find $i -name \"*.h\" -o -name \"*.c\" -o -name \"*.cpp\" -o -name \"*.mk\" -o -name \"*config\" -o -name \"Makefile\" -o -name \"*.inl\" -o -name \"*.py\" > ./$FILE_LIST\n    else\n      echo \"the other source code directory :\" \"$i\"\n      find $i -name \"*.h\" -o -name \"*.c\" -o -name \"*.cpp\" -o -name \"*.mk\" -o -name \"*config\" -o -name \"Makefile\" -o -name \"*.inl\" -o -name \"*.py\" >> ./$FILE_LIST\n    fi\n  else\n    echo \"please keyin the project path\"\n  fi\ndone\n\nif [ \"$#\" -ne 0 ]; then\n  echo \"create the cscope tag and ctags\"\n  cscope -bkq -i ./$FILE_LIST\n  ctags -R -L ./$FILE_LIST\nfi\n```\n","source":"_posts/VIM-Backup-the-setting-of-VIM.md","raw":"title: \"[VIM] Backup the setting of VIM\"\ndate: 2015-05-05 08:53:27\ncategories:\n- vim\ntags:\n- vim\n- CTag\n- Cscope\ntoc: true\n---\n# Purpose\n\n最近感覺電腦快往生了,所以現在未雨愁繆，先將\n\n自己常用的vim setting作一下備份，順便將ctag和cscope\n\n常用的script作一下記錄，假如有人有興趣也可以拿去發揚光大.\n\n## .vimrc \n\n```\n\" set up pathogen, https://github.com/tpope/vim-pathogen\nfiletype on \" without this vim emits a zero exit status, later, because of :ft off\nfiletype off\ncall pathogen#infect()\nfiletype plugin indent on\n\" don't bother with vi compatibility\nset nocompatible\n\n\" enable syntax highlighting\nsyntax enable\n\n\" auto come back the last file location\n if has(\"autocmd\")\n     autocmd BufRead *.txt set tw=78\n         autocmd BufReadPost *\n             \\ if line(\"'\\\"\") > 0 && line (\"'\\\"\") <= line(\"$\") |\n    \\   exe \"normal g'\\\"\" |\n    \\ endif\nendif\n\n\nlet g:session_autosave = 'yes'\n\nset autoindent\nset autoread                                                 \" reload files when changed on disk, i.e. via `git checkout`\nset backspace=2                                              \" Fix broken backspace in some setups\nset backupcopy=yes                                           \" see :help crontab\nset clipboard=unnamed                                        \" yank and paste with the system clipboard\nset directory-=.                                             \" don't store swapfiles in the current directory\nset encoding=utf-8\nset expandtab                                                \" expand tabs to spaces\nset ignorecase                                               \" case-insensitive search\nset incsearch                                                \" search as you type\nset laststatus=2                                             \" always show statusline\nset list                                                     \" show trailing whitespace\nset listchars=tab:▸\\ ,trail:▫\nset number                                                   \" show line numbers\nset ruler                                                    \" show where you are\nset scrolloff=3                                              \" show context above/below cursorline\nset shiftwidth=2                                             \" normal mode indentation commands use 2 spaces\nset showcmd\nset smartcase                                                \" case-sensitive search if any caps\nset softtabstop=2                                            \" insert mode tab and backspace use 2 spaces\nset tabstop=8                                                \" actual tabs occupy 8 characters\nset wildignore=log/**,node_modules/**,target/**,tmp/**,*.rbc\nset wildmenu                                                 \" show a navigable menu for tab completion\nset wildmode=longest,list,full\n\nset modifiable\nset write\nset hlsearch\nset ic\nset clipboard=unnamedplus\n\" Enable basic mouse behavior such as resizing buffers.\nset mouse=a\nif exists('$TMUX')  \" Support resizing in tmux\n  set ttymouse=xterm2\nendif\n\n\" keyboard shortcuts\nlet mapleader = ','\nmap <C-h> <C-w>h\nmap <C-j> <C-w>j\nmap <C-k> <C-w>k\nmap <C-l> <C-w>l\nmap <leader>l :Align\nnmap <leader>a :Ack \nnmap <leader>b :CtrlPBuffer<CR>\nnmap <leader>d :NERDTreeToggle<CR>\nnmap <leader>f :NERDTreeFind<CR>\nnmap <leader>t :CtrlP<CR>\nnmap <leader>s :cs find c <C-R>=expand(\"<cword>\")<CR><CR>\nnmap <leader>e :cs find t <C-R>=expand(\"<cword>\")<CR><CR>\nnmap <leader>T :CtrlPClearCache<CR>:CtrlP<CR>\nnmap <leader>] :TagbarToggle<CR>\nnmap <leader><space> :call whitespace#strip_trailing()<CR>\nnmap <leader>g :GitGutterToggle<CR>\nnmap <leader>c <Plug>Kwbd\nmap <silent> <leader>V :source ~/.vimrc<CR>:filetype detect<CR>:exe \":echo 'vimrc reloaded'\"<CR>\n\n\" NERDTree seeting\nlet NERDTreeShowHidden=1\n\n\n\"将:cs find\n\"c等Cscope查找命令映射为<C-_>c等快捷键（按法是先按Ctrl+Shift+-,然后很快再按下c）\n\"nmap <C-_>s :cs find s <C-R>=expand(\"<cword>\")<CR><CR>:copen<CR><CR>\n\"nmap <C-_>g :cs find g <C-R>=expand(\"<cword>\")<CR><CR>\n\"nmap <C-_>d :cs find d <C-R>=expand(\"<cword>\")<CR><CR>:copen<CR><CR>\n\"nmap <C-_>c :cs find c <C-R>=expand(\"<cword>\")<CR><CR>:copen<CR><CR>\n\"nmap <C-_>t :cs find t <C-R>=expand(\"<cword>\")<CR><CR>:copen<CR><CR>\n\"nmap <C-_>e :cs find e <C-R>=expand(\"<cword>\")<CR><CR>:copen<CR><CR>\n\"nmap <C-_>f :cs find f <C-R>=expand(\"<cfile>\")<CR><CR>\n\"nmap <C-_>i :cs find i <C-R>=expand(\"<cfile>\")<CR><CR>:copen<CR><CR>\n\n\n\" plugin settings\nlet g:ctrlp_match_window = 'order:ttb,max:20'\nlet g:NERDSpaceDelims=1\nlet g:gitgutter_enabled = 0\n\n\" Use The Silver Searcher https://github.com/ggreer/the_silver_searcher\nif executable('ag')\n  let g:ackprg = 'ag --nogroup --column'\n\n  \" Use Ag over Grep\n  set grepprg=ag\\ --nogroup\\ --nocolor\n\n  \" Use ag in CtrlP for listing files. Lightning fast and respects .gitignore\n  let g:ctrlp_user_command = 'ag %s -l --nocolor -g \"\"'\nendif\n\n\" fdoc is yaml\nautocmd BufRead,BufNewFile *.fdoc set filetype=yaml\n\" md is markdown\nautocmd BufRead,BufNewFile *.md set filetype=markdown\n\" extra rails.vim help\nautocmd User Rails silent! Rnavcommand decorator      app/decorators            -glob=**/* -suffix=_decorator.rb\nautocmd User Rails silent! Rnavcommand observer       app/observers             -glob=**/* -suffix=_observer.rb\nautocmd User Rails silent! Rnavcommand feature        features                  -glob=**/* -suffix=.feature\nautocmd User Rails silent! Rnavcommand job            app/jobs                  -glob=**/* -suffix=_job.rb\nautocmd User Rails silent! Rnavcommand mediator       app/mediators             -glob=**/* -suffix=_mediator.rb\nautocmd User Rails silent! Rnavcommand stepdefinition features/step_definitions -glob=**/* -suffix=_steps.rb\n\" automatically rebalance windows on vim resize\nautocmd VimResized * :wincmd =\n\n\" Fix Cursor in TMUX\nif exists('$TMUX')\n  let &t_SI = \"\\<Esc>Ptmux;\\<Esc>\\<Esc>]50;CursorShape=1\\x7\\<Esc>\\\\\"\n  let &t_EI = \"\\<Esc>Ptmux;\\<Esc>\\<Esc>]50;CursorShape=0\\x7\\<Esc>\\\\\"\nelse\n  let &t_SI = \"\\<Esc>]50;CursorShape=1\\x7\"\n  let &t_EI = \"\\<Esc>]50;CursorShape=0\\x7\"\nendif\n\n\" Go crazy!\nif filereadable(expand(\"~/.vimrc.local\"))\n  \" In your .vimrc.local, you might like:\n  \"\n  \" set autowrite\n  \" set nocursorline\n  \" set nowritebackup\n  \" set whichwrap+=<,>,h,l,[,] \" Wrap arrow keys between lines\n  \"\n  \" autocmd! bufwritepost .vimrc source ~/.vimrc\n  \" noremap! jj <ESC>\n  source ~/.vimrc.local\nendif\n```\n## .vimrc.local\n\n```\n\"set nocursorline \" don't highlight current line\nset cursorline\n\n\" keyboard shortcuts\ninoremap jj <ESC>\n\n\" gui settings\nif (&t_Co == 256 || has('gui_running'))\n  if ($TERM_PROGRAM == 'iTerm.app')\n    colorscheme solarized\n  else\n    colorscheme desert\n  endif\nendif\n\"\"\"\n\" Cscope settings\nif has(\"cscope\")\n  let i = 1\n  let path_depth = 20\n    while i < path_depth\n      if filereadable(\"cscope.out\")\n        let db = getcwd() . \"/cscope.out\"\n        echo db\n        let $CSCOPE_DB = db\n        cs add $CSCOPE_DB\n        let i = 20\n      else\n        cd ..\n      let i += 1\n      endif\n    endwhile\nendif\n```\n\n## sr\n\n```\n#!/bin/sh\nFILE_LIST=file_list\ntemp_str=NULL\n\nfor i in \"$@\"\ndo\n  if [ -n \"$i\" ]; then\n    temp_str=$i\n    if [ \"$1\" = \"$i\" ]; then\n      echo \"First Source code directory :\" \"$1\"\n      find $i -name \"*.h\" -o -name \"*.c\" -o -name \"*.cpp\" -o -name \"*.mk\" -o -name \"*config\" -o -name \"Makefile\" -o -name \"*.inl\" -o -name \"*.py\" > ./$FILE_LIST\n    else\n      echo \"the other source code directory :\" \"$i\"\n      find $i -name \"*.h\" -o -name \"*.c\" -o -name \"*.cpp\" -o -name \"*.mk\" -o -name \"*config\" -o -name \"Makefile\" -o -name \"*.inl\" -o -name \"*.py\" >> ./$FILE_LIST\n    fi\n  else\n    echo \"please keyin the project path\"\n  fi\ndone\n\nif [ \"$#\" -ne 0 ]; then\n  echo \"create the cscope tag and ctags\"\n  cscope -bkq -i ./$FILE_LIST\n  ctags -R -L ./$FILE_LIST\nfi\n```\n","slug":"VIM-Backup-the-setting-of-VIM","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp24w000w35gg9zup0u21"},{"title":"[Stack] Create the Stack Structure by Double Link List","date":"2015-05-07T00:34:37.000Z","toc":true,"_content":"\n# Purpose\n\n繼前前篇的實作queue結構,最後再補上如何透過組合double link list的方式,\n\n實作stack strcutre的操作API. 實在是容易,其實就是雙向鏈接的特殊形式.\n\n# Concept\n\nStack 就是Fist In Last Out, 也就是我們熟知的先進後出,或稱作後進先出. \n\n把握這個概念. 所以在Stack.h 下,我開出了底下對外的API.\n\n```\n// Stack.h\n\n#include \"DList.h\"\n\ntypedef struct _Stack\n{\n  DList* HeadNode;\n}Stack;\n\nStack* Stack_Create(void);\nRet Stack_Destroy(Stack*);\nRet Stack_Print_all(Stack*, DList_Print);\nRet Stack_Push(Stack*, DList* InsertNode);\nRet Stack_Pop(Stack*);\nRet Stack_Get_Length(Stack*, int* length);\nRet Stack_Get_Node(Stack*, DList**);\n```\n\n看吧, 自定的stack structure,其實就是指向雙向鏈結頭的指標.\n\nStack_Pop就是將一個雙向鏈結的Node（index=1） 移除. (我定義的雙向鏈結,Head Node,不能當作是data node).\n\n所以總是清除掉最後進來的Node.\n\n而Stack_Push,也是一樣,插入一個Node,到index=1的地方. \n\n所以總是將Node 放到最靠近Head Node的地方. \n\n多了一個 Stack_Get_Node, 這其實是將 index=1的Node 取出來,但是我並沒有清除掉index=1的Node.\n\n所以大致就是這樣囉...\n\n# FULLL CODE \n\n___1. stack.c___\n\n```\n#include <stdlib.h>\n#include \"stack.h\"\n\nStack* Stack_Create(void)\n{\n  Stack* myStack = (Stack*)malloc(sizeof(Stack));\n  check_pointer_return_value(myStack, NULL);\n\n  myStack->HeadNode = DList_Create();\n  return myStack;\n}\n\nRet Stack_Destroy(Stack* myStack)\n{\n  check_pointer_return_value(myStack, Ret_Fail);\n  if ( Ret_Fail == DList_Destroy( myStack->HeadNode) )\n  {\n    SR_ERR(\"DList_Destroy FAILLL\\n\");\n    return Ret_Fail;\n  }\n  SR_DBG(\"Free the QUEUE\\n\");\n  free(myStack);\n  return Ret_Success;\n}\n\nRet Stack_Print_all(Stack* myStack, DList_Print Print)\n{\n  check_pointer_return_value(myStack, Ret_Fail);\n  return DList_Print_all(myStack->HeadNode, Print);\n}\n\nRet Stack_Push(Stack* myStack, DList* InsertNode)\n{\n  // I think the Head Node doesn't belong to be the Data Node.\n  check_pointer_return_value(myStack, Ret_Fail);\n  return DList_Insert_Node_ByIndex(myStack->HeadNode, InsertNode, 1);\n}\n\nRet Stack_Pop(Stack* myStack)\n{\n  check_pointer_return_value(myStack, Ret_Fail);\n  // Beacuse nature of Stack, the node need to be popped out from the Noed which nearest Head Node.\n  return (DList_Delete_Node_ByIndex(myStack->HeadNode, 1));\n\n}\n\nRet Queue_Get_Length(Stack* myStack, int* length)\n{\n  check_pointer_return_value(myStack, Ret_Fail);\n  return DList_Get_Length(myStack->HeadNode, length);\n}\n\nRet Stack_Get_Node(Stack* myStack, DList** RetNode)\n{\n  check_pointer_return_value(myStack, Ret_Fail);\n\n  // Because the Nature of Stack, we alwasy get the first Node.\n  if ( Ret_Fail == DList_Get_Node_ByIndex(myStack->HeadNode, 1, RetNode))\n  {\n    SR_ERR(\"Fail to get Node from Stack \\n\");\n    return Ret_Fail;\n  }\n\n}\n\n```\n\n___2.DList.h___\n\n```\n#include \"global_enum_macro.h\"\n\ntypedef struct _DList\n{\n  struct _DList* DList_Pre_Ptr;\n  struct _DList* DList_Next_Ptr;\n  void* data;\n  int key;\n}DList;\n\nDList* DList_Create(void);\nRet DList_Destroy(DList*);\ntypedef Ret (*DList_Print)(DList*);\nRet DList_Print_all(DList*, DList_Print);\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index);\nRet DList_Delete_Node_ByIndex(DList*, int index);\nRet DList_Get_NodeData_ByIndex(DList*, int index, void** data);\nRet DList_Get_Node_ByIndex(DList*, int index, DList**);\nRet DList_Get_Length(DList*, int* length);\n```\n\n___3.DList.c___\n\n```\n#include \"DList.h\"\n#include \"stdlib.h\"\n\n\nDList* DList_Create(void)\n{\n  // Create the Head Node for Double Link List\n  DList* HeadNode = (DList*)malloc(sizeof(DList));\n  \n  check_pointer_return_value(HeadNode,NULL);\n\n  HeadNode->DList_Pre_Ptr = NULL;\n  HeadNode->DList_Next_Ptr = NULL;\n  \n  return HeadNode;\n\n}\n\nRet DList_Destroy(DList* HeadNode)\n{\n\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  DList* Temp_Ptr = HeadNode;\n\n  while (1)\n  {\n\n      if (HeadNode == NULL)\n      {\n        printf(\"Success to Destroy the Double Link List\\n\");\n        return Ret_Success;\n      }\n\n      HeadNode = HeadNode->DList_Next_Ptr;\n      \n      free(Temp_Ptr->data);\n      free(Temp_Ptr);\n\n      Temp_Ptr = HeadNode;\n  }\n\n}\n\nRet DList_Print_all(DList* HeadNode, DList_Print Print)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(Print, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ? \n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  DList* DList_Ptr = HeadNode;\n\n  while (DList_Ptr->DList_Next_Ptr != NULL)\n  {\n    // if the node is HEAD, we skip that node\n    if (DList_Ptr->DList_Pre_Ptr != NULL)\n    {\n      Print(DList_Ptr);\n    }\n      DList_Ptr = DList_Ptr->DList_Next_Ptr;\n  }\n\n  // Print the Tail Node's data\n  Print(DList_Ptr);\n\n}\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(InsertNode, Ret_Fail);\n\n  // check the Double Link List is EMPTY ??\n  if (HeadNode->DList_Pre_Ptr == NULL && HeadNode->DList_Next_Ptr == NULL)\n  {\n    HeadNode->DList_Next_Ptr = InsertNode;\n    InsertNode->DList_Next_Ptr = NULL;\n    InsertNode->DList_Pre_Ptr = HeadNode;\n    printf(\"Because the Double Link List is EMPTY, so I force the index to be 1 \\n\");\n    return Ret_Success;\n  }\n  \n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n\n  do\n  {\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n    if (cnt == index)\n    {\n      InsertNode->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      InsertNode->DList_Pre_Ptr->DList_Next_Ptr = InsertNode;\n      Temp_Ptr->DList_Pre_Ptr = InsertNode;\n      InsertNode->DList_Next_Ptr = Temp_Ptr;\n      return Ret_Success;\n    }\n    \n  } while ( Temp_Ptr->DList_Next_Ptr != NULL);\n\n  // If the index is large than the length of Double link list, just add the NODE into the tail of Double Link List.\n\n  printf(\"Because the index is large than the length of Double Link List, just insert the NODE into the tail of Double LInke List \\n\");\n  Temp_Ptr->DList_Next_Ptr = InsertNode;\n  InsertNode->DList_Next_Ptr = NULL;\n  return Ret_Success;\n}\n\nRet DList_Delete_Node_ByIndex(DList* HeadNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n  while (Temp_Ptr->DList_Next_Ptr != NULL)\n  {\n    if (cnt == index)\n    {\n      Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = Temp_Ptr->DList_Next_Ptr;\n      Temp_Ptr->DList_Next_Ptr->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      printf(\"Free the Node of Indx[%d] \\n\", index);\n      free(Temp_Ptr->data);\n      free(Temp_Ptr);\n      return Ret_Success;\n    }\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n  }\n\n  // Because the index is large than the length of Double Link List && the Node which you want to delete is TAIL Node. \n\n  printf(\"Free the TAIL NODE \\n\");\n  Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = NULL;\n  free(Temp_Ptr->data);\n  free(Temp_Ptr);\n  return Ret_Success;\n}\n\n\nRet DList_Get_NodeData_ByIndex(DList* HeadNode, int index, void** data)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  \n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n  do \n  {\n    cnt++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr; \n    if (cnt == index || Temp_Ptr->DList_Next_Ptr == NULL)\n    {\n      if (Temp_Ptr->DList_Next_Ptr == NULL)\n      {\n        // Tail Node\n        printf(\"The index is larger than the length of Double Link List, so just get the data of Tail Node for you \\n\");\n      }\n      *data = (void*)(Temp_Ptr->data);\n      return Ret_Success;\n    }\n  } while(1);\n}\n\nRet DList_Get_Node_ByIndex(DList* HeadNode, int index, DList** RetNode)\n{\n\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  int cnt = 0;\n  for (cnt = 0; cnt<=index; cnt++)\n  {\n    if (HeadNode->DList_Next_Ptr == NULL || cnt == index)\n    {\n      SR_DBG(\"This is the TAIL NODE or find the Node, so return NODE \\n\");\n      goto RETURN_DONE;\n    }\n    HeadNode = HeadNode->DList_Next_Ptr;\n  }\n\n  goto RETURN_DONE;\n\nRETURN_DONE :\n  *RetNode = HeadNode;\n  return Ret_Success;\n}\n\nRet DList_Get_Length(DList* HeadNode, int* length)\n{\n\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  \n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    *length = 0;\n    check_pointer_return_value(NULL, Ret_Success);\n  }\n\n  *length=0;\n  DList* Temp_Ptr = HeadNode;\n  do \n  {\n    (*length)++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr; \n    if (Temp_Ptr->DList_Next_Ptr == NULL)\n    {\n      return Ret_Success;\n    }\n  } while(1);\n\n\n}\n\n```\n\n___4.global_enum_macro.h___\n\n```\n#include <stdio.h>\n\n// Define GLobal Enum\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None,\n}Ret;\n\n// Define Global Macro\n#define SR_DBG(fmt,args ...) printf(\"[Sheldon debug][%s][%d] \"fmt,__FUNCTION__,__LINE__,##args)\n#define SR_ERR(fmt,args ...) printf(\"ERROR !!! [%s][%d ] \"fmt, __FUNCTION__,__LINE__,##args)\n#define check_pointer_return_value(ptr,value) if(ptr==NULL) \\\n                                                  { printf(\"[%s][%d] ERROR!!! Pointer is NULL \\r\\n\",__FUNCTION__,__LINE__); \\\n                                                  return value;} \\\n\n\n\n\n```\n\n___5.main.c___\n\n```\n#include <stdlib.h>\n#include \"stack.h\"\n\nRet MyPrint(DList* MyDList)\n{\n  check_pointer_return_value(MyDList, Ret_Fail);\n  // This place tell how to print the DLinkList's data type\n  printf(\"MyDList->key=%d, *(int*)(MyDList->data)=%d \\r\\n\", MyDList->key, *(int*)(MyDList->data));\n}\n\nDList* Create_Node(int data)\n{\n  DList* myNode = (DList*)malloc(sizeof(DList));\n  myNode->data = (int*)malloc(sizeof(int));\n  *(int*)(myNode->data) = data; \n  return myNode;\n}\n\nvoid main(void)\n{\n  Stack* myStack = Stack_Create() ; \n\n  // Push the Node to Queue\n  Stack_Push(myStack, Create_Node(10));\n  Stack_Push(myStack, Create_Node(20));\n  Stack_Push(myStack, Create_Node(30));\n  Stack_Push(myStack, Create_Node(40));\n  Stack_Push(myStack, Create_Node(50));\n  \n  // Print all the Nodes of Queue\n  Stack_Print_all(myStack, MyPrint);\n\n  // Pop out  the Node from Queue\n  // Test  Stack_Get_Node \n  SR_DBG(\"=================\\r\\n\");\n  DList* D_Ptr = NULL;\n  Stack_Get_Node(myStack, &D_Ptr);\n  SR_DBG(\"data is %d \\r\\n\",*(int*)(D_Ptr->data));\n  SR_DBG(\" Pop out Node\\r\\n\");\n  Stack_Pop(myStack);\n  Stack_Get_Node(myStack, &D_Ptr);\n  SR_DBG(\"data is %d \\r\\n\",*(int*)(D_Ptr->data));\n  SR_DBG(\" Pop out Node\\r\\n\");\n  Stack_Pop(myStack);\n  Stack_Get_Node(myStack, &D_Ptr);\n  SR_DBG(\"data is %d \\r\\n\",*(int*)(D_Ptr->data));\n\n  // Print all the Nodes of Queue\n  Stack_Print_all(myStack, MyPrint);\n\n  // Destroy the Queue\n  if (Ret_Success == Stack_Destroy(myStack))\n  {\n    SR_DBG(\"Destroy Stack -- Success !!!\\n\");\n    myStack = NULL;\n  }\n\n  Stack_Print_all(myStack, MyPrint);\n\n}\n```\n\n","source":"_posts/Stack-Create-the-Stack-Structure-by-Double-Link-List.md","raw":"title: \"[Stack] Create the Stack Structure by Double Link List\"\ndate: 2015-05-07 08:34:37\ncategories:\n- stack\ntags:\n- stack\n- double link list\n- c\n- data structure\ntoc: true\n---\n\n# Purpose\n\n繼前前篇的實作queue結構,最後再補上如何透過組合double link list的方式,\n\n實作stack strcutre的操作API. 實在是容易,其實就是雙向鏈接的特殊形式.\n\n# Concept\n\nStack 就是Fist In Last Out, 也就是我們熟知的先進後出,或稱作後進先出. \n\n把握這個概念. 所以在Stack.h 下,我開出了底下對外的API.\n\n```\n// Stack.h\n\n#include \"DList.h\"\n\ntypedef struct _Stack\n{\n  DList* HeadNode;\n}Stack;\n\nStack* Stack_Create(void);\nRet Stack_Destroy(Stack*);\nRet Stack_Print_all(Stack*, DList_Print);\nRet Stack_Push(Stack*, DList* InsertNode);\nRet Stack_Pop(Stack*);\nRet Stack_Get_Length(Stack*, int* length);\nRet Stack_Get_Node(Stack*, DList**);\n```\n\n看吧, 自定的stack structure,其實就是指向雙向鏈結頭的指標.\n\nStack_Pop就是將一個雙向鏈結的Node（index=1） 移除. (我定義的雙向鏈結,Head Node,不能當作是data node).\n\n所以總是清除掉最後進來的Node.\n\n而Stack_Push,也是一樣,插入一個Node,到index=1的地方. \n\n所以總是將Node 放到最靠近Head Node的地方. \n\n多了一個 Stack_Get_Node, 這其實是將 index=1的Node 取出來,但是我並沒有清除掉index=1的Node.\n\n所以大致就是這樣囉...\n\n# FULLL CODE \n\n___1. stack.c___\n\n```\n#include <stdlib.h>\n#include \"stack.h\"\n\nStack* Stack_Create(void)\n{\n  Stack* myStack = (Stack*)malloc(sizeof(Stack));\n  check_pointer_return_value(myStack, NULL);\n\n  myStack->HeadNode = DList_Create();\n  return myStack;\n}\n\nRet Stack_Destroy(Stack* myStack)\n{\n  check_pointer_return_value(myStack, Ret_Fail);\n  if ( Ret_Fail == DList_Destroy( myStack->HeadNode) )\n  {\n    SR_ERR(\"DList_Destroy FAILLL\\n\");\n    return Ret_Fail;\n  }\n  SR_DBG(\"Free the QUEUE\\n\");\n  free(myStack);\n  return Ret_Success;\n}\n\nRet Stack_Print_all(Stack* myStack, DList_Print Print)\n{\n  check_pointer_return_value(myStack, Ret_Fail);\n  return DList_Print_all(myStack->HeadNode, Print);\n}\n\nRet Stack_Push(Stack* myStack, DList* InsertNode)\n{\n  // I think the Head Node doesn't belong to be the Data Node.\n  check_pointer_return_value(myStack, Ret_Fail);\n  return DList_Insert_Node_ByIndex(myStack->HeadNode, InsertNode, 1);\n}\n\nRet Stack_Pop(Stack* myStack)\n{\n  check_pointer_return_value(myStack, Ret_Fail);\n  // Beacuse nature of Stack, the node need to be popped out from the Noed which nearest Head Node.\n  return (DList_Delete_Node_ByIndex(myStack->HeadNode, 1));\n\n}\n\nRet Queue_Get_Length(Stack* myStack, int* length)\n{\n  check_pointer_return_value(myStack, Ret_Fail);\n  return DList_Get_Length(myStack->HeadNode, length);\n}\n\nRet Stack_Get_Node(Stack* myStack, DList** RetNode)\n{\n  check_pointer_return_value(myStack, Ret_Fail);\n\n  // Because the Nature of Stack, we alwasy get the first Node.\n  if ( Ret_Fail == DList_Get_Node_ByIndex(myStack->HeadNode, 1, RetNode))\n  {\n    SR_ERR(\"Fail to get Node from Stack \\n\");\n    return Ret_Fail;\n  }\n\n}\n\n```\n\n___2.DList.h___\n\n```\n#include \"global_enum_macro.h\"\n\ntypedef struct _DList\n{\n  struct _DList* DList_Pre_Ptr;\n  struct _DList* DList_Next_Ptr;\n  void* data;\n  int key;\n}DList;\n\nDList* DList_Create(void);\nRet DList_Destroy(DList*);\ntypedef Ret (*DList_Print)(DList*);\nRet DList_Print_all(DList*, DList_Print);\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index);\nRet DList_Delete_Node_ByIndex(DList*, int index);\nRet DList_Get_NodeData_ByIndex(DList*, int index, void** data);\nRet DList_Get_Node_ByIndex(DList*, int index, DList**);\nRet DList_Get_Length(DList*, int* length);\n```\n\n___3.DList.c___\n\n```\n#include \"DList.h\"\n#include \"stdlib.h\"\n\n\nDList* DList_Create(void)\n{\n  // Create the Head Node for Double Link List\n  DList* HeadNode = (DList*)malloc(sizeof(DList));\n  \n  check_pointer_return_value(HeadNode,NULL);\n\n  HeadNode->DList_Pre_Ptr = NULL;\n  HeadNode->DList_Next_Ptr = NULL;\n  \n  return HeadNode;\n\n}\n\nRet DList_Destroy(DList* HeadNode)\n{\n\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  DList* Temp_Ptr = HeadNode;\n\n  while (1)\n  {\n\n      if (HeadNode == NULL)\n      {\n        printf(\"Success to Destroy the Double Link List\\n\");\n        return Ret_Success;\n      }\n\n      HeadNode = HeadNode->DList_Next_Ptr;\n      \n      free(Temp_Ptr->data);\n      free(Temp_Ptr);\n\n      Temp_Ptr = HeadNode;\n  }\n\n}\n\nRet DList_Print_all(DList* HeadNode, DList_Print Print)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(Print, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ? \n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  DList* DList_Ptr = HeadNode;\n\n  while (DList_Ptr->DList_Next_Ptr != NULL)\n  {\n    // if the node is HEAD, we skip that node\n    if (DList_Ptr->DList_Pre_Ptr != NULL)\n    {\n      Print(DList_Ptr);\n    }\n      DList_Ptr = DList_Ptr->DList_Next_Ptr;\n  }\n\n  // Print the Tail Node's data\n  Print(DList_Ptr);\n\n}\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(InsertNode, Ret_Fail);\n\n  // check the Double Link List is EMPTY ??\n  if (HeadNode->DList_Pre_Ptr == NULL && HeadNode->DList_Next_Ptr == NULL)\n  {\n    HeadNode->DList_Next_Ptr = InsertNode;\n    InsertNode->DList_Next_Ptr = NULL;\n    InsertNode->DList_Pre_Ptr = HeadNode;\n    printf(\"Because the Double Link List is EMPTY, so I force the index to be 1 \\n\");\n    return Ret_Success;\n  }\n  \n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n\n  do\n  {\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n    if (cnt == index)\n    {\n      InsertNode->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      InsertNode->DList_Pre_Ptr->DList_Next_Ptr = InsertNode;\n      Temp_Ptr->DList_Pre_Ptr = InsertNode;\n      InsertNode->DList_Next_Ptr = Temp_Ptr;\n      return Ret_Success;\n    }\n    \n  } while ( Temp_Ptr->DList_Next_Ptr != NULL);\n\n  // If the index is large than the length of Double link list, just add the NODE into the tail of Double Link List.\n\n  printf(\"Because the index is large than the length of Double Link List, just insert the NODE into the tail of Double LInke List \\n\");\n  Temp_Ptr->DList_Next_Ptr = InsertNode;\n  InsertNode->DList_Next_Ptr = NULL;\n  return Ret_Success;\n}\n\nRet DList_Delete_Node_ByIndex(DList* HeadNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n  while (Temp_Ptr->DList_Next_Ptr != NULL)\n  {\n    if (cnt == index)\n    {\n      Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = Temp_Ptr->DList_Next_Ptr;\n      Temp_Ptr->DList_Next_Ptr->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      printf(\"Free the Node of Indx[%d] \\n\", index);\n      free(Temp_Ptr->data);\n      free(Temp_Ptr);\n      return Ret_Success;\n    }\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n  }\n\n  // Because the index is large than the length of Double Link List && the Node which you want to delete is TAIL Node. \n\n  printf(\"Free the TAIL NODE \\n\");\n  Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = NULL;\n  free(Temp_Ptr->data);\n  free(Temp_Ptr);\n  return Ret_Success;\n}\n\n\nRet DList_Get_NodeData_ByIndex(DList* HeadNode, int index, void** data)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  \n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n  do \n  {\n    cnt++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr; \n    if (cnt == index || Temp_Ptr->DList_Next_Ptr == NULL)\n    {\n      if (Temp_Ptr->DList_Next_Ptr == NULL)\n      {\n        // Tail Node\n        printf(\"The index is larger than the length of Double Link List, so just get the data of Tail Node for you \\n\");\n      }\n      *data = (void*)(Temp_Ptr->data);\n      return Ret_Success;\n    }\n  } while(1);\n}\n\nRet DList_Get_Node_ByIndex(DList* HeadNode, int index, DList** RetNode)\n{\n\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  int cnt = 0;\n  for (cnt = 0; cnt<=index; cnt++)\n  {\n    if (HeadNode->DList_Next_Ptr == NULL || cnt == index)\n    {\n      SR_DBG(\"This is the TAIL NODE or find the Node, so return NODE \\n\");\n      goto RETURN_DONE;\n    }\n    HeadNode = HeadNode->DList_Next_Ptr;\n  }\n\n  goto RETURN_DONE;\n\nRETURN_DONE :\n  *RetNode = HeadNode;\n  return Ret_Success;\n}\n\nRet DList_Get_Length(DList* HeadNode, int* length)\n{\n\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  \n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    *length = 0;\n    check_pointer_return_value(NULL, Ret_Success);\n  }\n\n  *length=0;\n  DList* Temp_Ptr = HeadNode;\n  do \n  {\n    (*length)++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr; \n    if (Temp_Ptr->DList_Next_Ptr == NULL)\n    {\n      return Ret_Success;\n    }\n  } while(1);\n\n\n}\n\n```\n\n___4.global_enum_macro.h___\n\n```\n#include <stdio.h>\n\n// Define GLobal Enum\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None,\n}Ret;\n\n// Define Global Macro\n#define SR_DBG(fmt,args ...) printf(\"[Sheldon debug][%s][%d] \"fmt,__FUNCTION__,__LINE__,##args)\n#define SR_ERR(fmt,args ...) printf(\"ERROR !!! [%s][%d ] \"fmt, __FUNCTION__,__LINE__,##args)\n#define check_pointer_return_value(ptr,value) if(ptr==NULL) \\\n                                                  { printf(\"[%s][%d] ERROR!!! Pointer is NULL \\r\\n\",__FUNCTION__,__LINE__); \\\n                                                  return value;} \\\n\n\n\n\n```\n\n___5.main.c___\n\n```\n#include <stdlib.h>\n#include \"stack.h\"\n\nRet MyPrint(DList* MyDList)\n{\n  check_pointer_return_value(MyDList, Ret_Fail);\n  // This place tell how to print the DLinkList's data type\n  printf(\"MyDList->key=%d, *(int*)(MyDList->data)=%d \\r\\n\", MyDList->key, *(int*)(MyDList->data));\n}\n\nDList* Create_Node(int data)\n{\n  DList* myNode = (DList*)malloc(sizeof(DList));\n  myNode->data = (int*)malloc(sizeof(int));\n  *(int*)(myNode->data) = data; \n  return myNode;\n}\n\nvoid main(void)\n{\n  Stack* myStack = Stack_Create() ; \n\n  // Push the Node to Queue\n  Stack_Push(myStack, Create_Node(10));\n  Stack_Push(myStack, Create_Node(20));\n  Stack_Push(myStack, Create_Node(30));\n  Stack_Push(myStack, Create_Node(40));\n  Stack_Push(myStack, Create_Node(50));\n  \n  // Print all the Nodes of Queue\n  Stack_Print_all(myStack, MyPrint);\n\n  // Pop out  the Node from Queue\n  // Test  Stack_Get_Node \n  SR_DBG(\"=================\\r\\n\");\n  DList* D_Ptr = NULL;\n  Stack_Get_Node(myStack, &D_Ptr);\n  SR_DBG(\"data is %d \\r\\n\",*(int*)(D_Ptr->data));\n  SR_DBG(\" Pop out Node\\r\\n\");\n  Stack_Pop(myStack);\n  Stack_Get_Node(myStack, &D_Ptr);\n  SR_DBG(\"data is %d \\r\\n\",*(int*)(D_Ptr->data));\n  SR_DBG(\" Pop out Node\\r\\n\");\n  Stack_Pop(myStack);\n  Stack_Get_Node(myStack, &D_Ptr);\n  SR_DBG(\"data is %d \\r\\n\",*(int*)(D_Ptr->data));\n\n  // Print all the Nodes of Queue\n  Stack_Print_all(myStack, MyPrint);\n\n  // Destroy the Queue\n  if (Ret_Success == Stack_Destroy(myStack))\n  {\n    SR_DBG(\"Destroy Stack -- Success !!!\\n\");\n    myStack = NULL;\n  }\n\n  Stack_Print_all(myStack, MyPrint);\n\n}\n```\n\n","slug":"Stack-Create-the-Stack-Structure-by-Double-Link-List","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp25b001535gg17gdmbzo"},{"title":"[Read/Write Lock][Mutex] exercise to implement the read/write lock in the mutex","date":"2015-04-12T17:11:59.000Z","toc":true,"_content":"\n# 目的\n\n最近遇到一個問題，假如你現在程式裏面有許多thread,每個thread會存取相同的資料, \n\n一般來說,我們都會用mutex來做保護，避免讀資料的thread,再讀的時候,寫資料的thread就把資料改過了\n\n以致於讀資料的thread,拿到錯誤的資訊.\n\n但是假如程式裏面,大部分的thread都是讀資料,寫資料的thread其實不是很多,這樣的話,我們都用同一個mutex的話,\n\n效率其實會下降,所以就有人提出了read/write lock,兩個鎖的方式,讀資料的thread們,除了第一個讀的thread要等以外\n\n其他的都不用.利害吧XDD.\n\n# Sample Code. \n\n這份sample code, \n\n1. 我將最原本的mutex_lock實作擺在\n   basic_mutex_class.c, \n   而lock_interface.c 裡面有抽象的描述.\n\n2. 有關 Read/Write Lock 的實作擺在 main.c. \n   其實也只是多生出兩個mutex, 稱作讀鎖以及寫鎖.\n   在實作出讀寫鎖的使用方式.\n\n___a. main,c___\n\n```\n#include <stdlib.h>\n#include \"lock_interface.h\"\n#include \"basic_mutex_class.h\"\n\n\nRet read_RW_lock_ipl(read_write_lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n \n  // 再來Read Lock 來保護read_count\n  if (api_my_lock(my_lock->RLock) == Ret_Success)\n  {\n    // 有thread 要讀的時候,read_count++, 記錄有幾個thread 還在用.\n    my_lock->read_count++;\n\n    // 嘗試獲得Write Lock, 禁止有人寫\n    if (api_my_lock(my_lock->WLock) == Ret_Success)\n    {\n      // 記錄現在lock mode 爲read.\n      my_lock->lock_mode = Read_Lock_Mode; \n    }\n    // UnLock 掉read lock, 由於只有讀的時候,不需要lock read thread.\n    if (api_my_unlock(my_lock->RLock) == Ret_Fail)\n    {\n      SR_ERR(\"\\n\");\n      return Ret_Fail;\n    }\n  }\n}\n\nRet write_RW_lock_ipl(read_write_lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n\n  // 嘗試獲得Write Lock, 禁止有人寫\n  if (api_my_lock(my_lock->WLock) == Ret_Success)\n  {\n      // 記錄現在lock mode 爲write.\n      my_lock->lock_mode = Write_Lock_Mode;\n      return Ret_Success;\n  }\n  return Ret_Fail;\n}\n\nRet un_RW_lock_ipl(read_write_lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n\n  if (my_lock->lock_mode == Read_Lock_Mode)\n  {\n    // 現在是讀的情況,需要要解鎖\n    // 用read lock 來保護read_count\n    if (api_my_lock(my_lock->RLock) == Ret_Success)\n    {\n      //檢查 read_count 是否爲0\n      my_lock->read_count--;\n      if (my_lock->read_count == 0)\n      {\n        // 由於現在已經沒有讀資料的thread了, 所以就是釋放Write Lock\n        if (api_my_unlock(my_lock->WLock)==Ret_Fail)\n        {\n          SR_ERR(\"\\n\");\n          return Ret_Fail;\n        }\n      }\n      if (api_my_unlock(my_lock->RLock) == Ret_Fail)\n      {\n        SR_ERR(\"\\n\");\n        return Ret_Fail;\n      }\n\n      SR_DBG(\"Success to unlock \\n\");\n      return Ret_Success;\n    }\n  }\n  else if (my_lock->lock_mode == Write_Lock_Mode)\n  {\n    // 寫的thread, 結束以後，解鎖\n    if (api_my_unlock(my_lock->WLock)==Ret_Fail)\n    {\n      SR_ERR(\"\\n\");\n      return Ret_Fail;\n    }\n    return Ret_Success;\n  }\n  else\n  {\n    SR_ERR(\"Lock Mode is Non, there is something wrong.... \");\n  }\n}\n\nRet destroy_RW_lock_ipl(read_write_lock* my_lock)\n{\n\n  check_pointer_return_value(my_lock, Ret_Fail);\n  free(my_lock->RLock);\n  free(my_lock->WLock);\n  free(my_lock);\n  SR_DBG(\"Success to destory read/write lock \\n\");\n}\n\nread_write_lock* create_read_write_lock(void)\n{\n  read_write_lock* my_read_write_lock = malloc(sizeof(read_write_lock));\n\n  check_pointer_return_value(my_read_write_lock, NULL);\n\n  my_read_write_lock->read_count = 0;\n  my_read_write_lock->RLock = (My_Lock*)Init_Mutex_Pthread();\n  my_read_write_lock->WLock = (My_Lock*)Init_Mutex_Pthread();\n  my_read_write_lock->lock_mode = None_Lock_Mode; \n  my_read_write_lock->read_lock_Fun = read_RW_lock_ipl; \n  my_read_write_lock->write_lock_Fun = write_RW_lock_ipl;\n  my_read_write_lock->un_read_write_lock = un_RW_lock_ipl;\n  my_read_write_lock->destroy_read_write_lock = destroy_RW_lock_ipl;\n\n  return my_read_write_lock;\n}\n\nvoid main(void)\n{\n\n  read_write_lock* my_RW_lock = create_read_write_lock();\n  // Test for Read lock\n  my_RW_lock->read_lock_Fun(my_RW_lock);\n  my_RW_lock->un_read_write_lock(my_RW_lock);\n\n  // Test for write lock\n  my_RW_lock->write_lock_Fun(my_RW_lock);\n  my_RW_lock->un_read_write_lock(my_RW_lock);\n\n  my_RW_lock->destroy_read_write_lock(my_RW_lock);\n\n}\n\n```\n\n___b.basic_mutex_class.h___\n\n```\n#include <pthread.h>\n\nMy_Lock* Init_Mutex_Pthread(void);\nRet Mutex_Pthread_lock(My_Lock* );\nRet Mutex_Pthread_unlock(My_Lock* );\nRet Mutex_Pthread_destory(My_Lock* );\n\ntypedef struct _mutex_info\n{\n  pthread_mutex_t mutex;\n}mutex_info;\n\n\n```\n\n___c.basic_mutex_class.c___\n\n```\n#include <stdlib.h>\n#include \"lock_interface.h\"\n#include \"basic_mutex_class.h\"\n\nRet Mutex_Pthread_lock(My_Lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n  \n  mutex_info* my_mutex = (mutex_info*)my_lock->lock_info;\n\n  if (pthread_mutex_lock(&my_mutex->mutex) == 0)\n  {\n    return Ret_Success;\n  }\n  else\n  {\n    SR_ERR(\"\\n\");\n  }\n}\n\nRet Mutex_Pthread_unlock(My_Lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n  \n  mutex_info* my_mutex = (mutex_info*)my_lock->lock_info;\n\n  if (pthread_mutex_unlock(&my_mutex->mutex) == 0)\n  {\n    return Ret_Success;\n  }\n  else\n  {\n    SR_ERR(\"\\n\");\n  }\n}\n\nRet Mutex_Pthread_destory(My_Lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n  \n  mutex_info* my_mutex = (mutex_info*)my_lock->lock_info;\n\n  if (pthread_mutex_destroy(&my_mutex->mutex) == 0)\n  {\n    free(my_lock);\n    return Ret_Success;\n  }\n  else\n  {\n    SR_ERR(\"\\n\");\n  }\n}\n\nMy_Lock* Init_Mutex_Pthread(void)\n{\n  My_Lock* my_lock = malloc(sizeof(My_Lock)+sizeof(mutex_info));\n  check_pointer_return_value(my_lock, NULL);\n\n  mutex_info* my_mutex;\n  my_mutex = (mutex_info*)my_lock->lock_info;\n  pthread_mutex_init(&(my_mutex->mutex),NULL);\n\n  my_lock->DoLock = Mutex_Pthread_lock;\n  my_lock->DoUnlock = Mutex_Pthread_unlock;\n  my_lock->DoDestory = Mutex_Pthread_destory; \n  \n  return my_lock;\n\n}\n\n```\n\n___d.global_enum_macro.h___\n\n```\n#include <stdio.h>\n\n// Define GLobal Enum\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None,\n}Ret;\n\n// Define Global Macro\n#define SR_DBG(fmt,args ...) printf(\"[Sheldon debug][%s][%d] \"fmt,__FUNCTION__,__LINE__,##args)\n#define SR_ERR(fmt,args ...) printf(\"ERROR !!! [%s][%d ] \"fmt, __FUNCTION__,__LINE__,##args)\n#define check_pointer_return_value(ptr,value) if(ptr==NULL) \\\n                                                  { printf(\"ERROR!!! #ptr is NULL, return #value \\r\\n\"); \\\n                                                  return value;} \\\n\n\n\n\n```\n\n___e.lock_inter_face.h___\n\n```\n#include \"global_enum_macro.h\"\n\n// For basic lock\nstruct _my_lock;\ntypedef struct _my_lock My_lock;\n\ntypedef Ret (*LockFun)(My_lock*);\ntypedef Ret (*UnLockFun)(My_lock*);\ntypedef Ret (*DestoryLockFun)(My_lock*);\n\ntypedef struct _my_lock\n{\n  LockFun DoLock;\n  UnLockFun DoUnlock;\n  DestoryLockFun DoDestory;\n  char lock_info[0];\n}My_Lock;\n\n\n// For read/write lock\nstruct _read_write_lock;\ntypedef struct _read_write_lock read_write_lock;\ntypedef Ret (*ReadLockFun)(read_write_lock*);\ntypedef Ret (*WriteLockFun)(read_write_lock*);\ntypedef Ret (*UnReadWriteLockFun)(read_write_lock*);\ntypedef Ret (*DestroyReadWriteLockFun)(read_write_lock*);\n\ntypedef enum _ReadWriteLockMode\n{\n  Read_Lock_Mode,\n  Write_Lock_Mode,\n  None_Lock_Mode,\n}ReadWriteLockMode;\n\n\ntypedef struct _read_write_lock\n{\n  int read_count;\n  My_Lock* RLock;\n  My_Lock* WLock;\n\n  ReadWriteLockMode lock_mode;\n  ReadLockFun read_lock_Fun;\n  WriteLockFun write_lock_Fun;\n  UnReadWriteLockFun un_read_write_lock;\n  DestroyReadWriteLockFun destroy_read_write_lock;\n}read_write_lock;\n\nRet api_my_lock(My_Lock* my_lock);\nRet api_my_unlock(My_Lock* my_lock);\nRet api_my_destory(My_Lock* my_lock);\n\n```\n\n___f.lock_interface.c___\n\n```\n#include \"lock_interface.h\"\n\n\nRet api_my_lock(My_Lock* my_lock)\n{\n check_pointer_return_value(my_lock, Ret_Fail);\n if (my_lock->DoLock(my_lock) == Ret_Fail) \n {\n    SR_ERR(\"\\n\");\n }\n return Ret_Success;\n}\n\nRet api_my_unlock(My_Lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail); \n  if (my_lock->DoUnlock(my_lock) == Ret_Fail)\n  {\n    SR_ERR(\"\\n\");\n  }\n  return Ret_Success;\n}\n\nRet api_my_destory(My_Lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n  \n  if (my_lock->DoDestory(my_lock) == Ret_Fail)\n  {\n    SR_ERR(\"\\n\");\n  }\n  return Ret_Success;\n}\n\n```\n\n","source":"_posts/Read-Write-Lock-Mutex-exercise-to-implement-the-read-write-lock-in-the-mutex.md","raw":"title: \"[Read/Write Lock][Mutex] exercise to implement the read/write lock in the mutex\"\ndate: 2015-04-13 01:11:59\ncategories:\n- Mutex\n- Read/Write Lock\ntags:\n- C\n- Mutex\n- Read/Write Lock\ntoc: true\n---\n\n# 目的\n\n最近遇到一個問題，假如你現在程式裏面有許多thread,每個thread會存取相同的資料, \n\n一般來說,我們都會用mutex來做保護，避免讀資料的thread,再讀的時候,寫資料的thread就把資料改過了\n\n以致於讀資料的thread,拿到錯誤的資訊.\n\n但是假如程式裏面,大部分的thread都是讀資料,寫資料的thread其實不是很多,這樣的話,我們都用同一個mutex的話,\n\n效率其實會下降,所以就有人提出了read/write lock,兩個鎖的方式,讀資料的thread們,除了第一個讀的thread要等以外\n\n其他的都不用.利害吧XDD.\n\n# Sample Code. \n\n這份sample code, \n\n1. 我將最原本的mutex_lock實作擺在\n   basic_mutex_class.c, \n   而lock_interface.c 裡面有抽象的描述.\n\n2. 有關 Read/Write Lock 的實作擺在 main.c. \n   其實也只是多生出兩個mutex, 稱作讀鎖以及寫鎖.\n   在實作出讀寫鎖的使用方式.\n\n___a. main,c___\n\n```\n#include <stdlib.h>\n#include \"lock_interface.h\"\n#include \"basic_mutex_class.h\"\n\n\nRet read_RW_lock_ipl(read_write_lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n \n  // 再來Read Lock 來保護read_count\n  if (api_my_lock(my_lock->RLock) == Ret_Success)\n  {\n    // 有thread 要讀的時候,read_count++, 記錄有幾個thread 還在用.\n    my_lock->read_count++;\n\n    // 嘗試獲得Write Lock, 禁止有人寫\n    if (api_my_lock(my_lock->WLock) == Ret_Success)\n    {\n      // 記錄現在lock mode 爲read.\n      my_lock->lock_mode = Read_Lock_Mode; \n    }\n    // UnLock 掉read lock, 由於只有讀的時候,不需要lock read thread.\n    if (api_my_unlock(my_lock->RLock) == Ret_Fail)\n    {\n      SR_ERR(\"\\n\");\n      return Ret_Fail;\n    }\n  }\n}\n\nRet write_RW_lock_ipl(read_write_lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n\n  // 嘗試獲得Write Lock, 禁止有人寫\n  if (api_my_lock(my_lock->WLock) == Ret_Success)\n  {\n      // 記錄現在lock mode 爲write.\n      my_lock->lock_mode = Write_Lock_Mode;\n      return Ret_Success;\n  }\n  return Ret_Fail;\n}\n\nRet un_RW_lock_ipl(read_write_lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n\n  if (my_lock->lock_mode == Read_Lock_Mode)\n  {\n    // 現在是讀的情況,需要要解鎖\n    // 用read lock 來保護read_count\n    if (api_my_lock(my_lock->RLock) == Ret_Success)\n    {\n      //檢查 read_count 是否爲0\n      my_lock->read_count--;\n      if (my_lock->read_count == 0)\n      {\n        // 由於現在已經沒有讀資料的thread了, 所以就是釋放Write Lock\n        if (api_my_unlock(my_lock->WLock)==Ret_Fail)\n        {\n          SR_ERR(\"\\n\");\n          return Ret_Fail;\n        }\n      }\n      if (api_my_unlock(my_lock->RLock) == Ret_Fail)\n      {\n        SR_ERR(\"\\n\");\n        return Ret_Fail;\n      }\n\n      SR_DBG(\"Success to unlock \\n\");\n      return Ret_Success;\n    }\n  }\n  else if (my_lock->lock_mode == Write_Lock_Mode)\n  {\n    // 寫的thread, 結束以後，解鎖\n    if (api_my_unlock(my_lock->WLock)==Ret_Fail)\n    {\n      SR_ERR(\"\\n\");\n      return Ret_Fail;\n    }\n    return Ret_Success;\n  }\n  else\n  {\n    SR_ERR(\"Lock Mode is Non, there is something wrong.... \");\n  }\n}\n\nRet destroy_RW_lock_ipl(read_write_lock* my_lock)\n{\n\n  check_pointer_return_value(my_lock, Ret_Fail);\n  free(my_lock->RLock);\n  free(my_lock->WLock);\n  free(my_lock);\n  SR_DBG(\"Success to destory read/write lock \\n\");\n}\n\nread_write_lock* create_read_write_lock(void)\n{\n  read_write_lock* my_read_write_lock = malloc(sizeof(read_write_lock));\n\n  check_pointer_return_value(my_read_write_lock, NULL);\n\n  my_read_write_lock->read_count = 0;\n  my_read_write_lock->RLock = (My_Lock*)Init_Mutex_Pthread();\n  my_read_write_lock->WLock = (My_Lock*)Init_Mutex_Pthread();\n  my_read_write_lock->lock_mode = None_Lock_Mode; \n  my_read_write_lock->read_lock_Fun = read_RW_lock_ipl; \n  my_read_write_lock->write_lock_Fun = write_RW_lock_ipl;\n  my_read_write_lock->un_read_write_lock = un_RW_lock_ipl;\n  my_read_write_lock->destroy_read_write_lock = destroy_RW_lock_ipl;\n\n  return my_read_write_lock;\n}\n\nvoid main(void)\n{\n\n  read_write_lock* my_RW_lock = create_read_write_lock();\n  // Test for Read lock\n  my_RW_lock->read_lock_Fun(my_RW_lock);\n  my_RW_lock->un_read_write_lock(my_RW_lock);\n\n  // Test for write lock\n  my_RW_lock->write_lock_Fun(my_RW_lock);\n  my_RW_lock->un_read_write_lock(my_RW_lock);\n\n  my_RW_lock->destroy_read_write_lock(my_RW_lock);\n\n}\n\n```\n\n___b.basic_mutex_class.h___\n\n```\n#include <pthread.h>\n\nMy_Lock* Init_Mutex_Pthread(void);\nRet Mutex_Pthread_lock(My_Lock* );\nRet Mutex_Pthread_unlock(My_Lock* );\nRet Mutex_Pthread_destory(My_Lock* );\n\ntypedef struct _mutex_info\n{\n  pthread_mutex_t mutex;\n}mutex_info;\n\n\n```\n\n___c.basic_mutex_class.c___\n\n```\n#include <stdlib.h>\n#include \"lock_interface.h\"\n#include \"basic_mutex_class.h\"\n\nRet Mutex_Pthread_lock(My_Lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n  \n  mutex_info* my_mutex = (mutex_info*)my_lock->lock_info;\n\n  if (pthread_mutex_lock(&my_mutex->mutex) == 0)\n  {\n    return Ret_Success;\n  }\n  else\n  {\n    SR_ERR(\"\\n\");\n  }\n}\n\nRet Mutex_Pthread_unlock(My_Lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n  \n  mutex_info* my_mutex = (mutex_info*)my_lock->lock_info;\n\n  if (pthread_mutex_unlock(&my_mutex->mutex) == 0)\n  {\n    return Ret_Success;\n  }\n  else\n  {\n    SR_ERR(\"\\n\");\n  }\n}\n\nRet Mutex_Pthread_destory(My_Lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n  \n  mutex_info* my_mutex = (mutex_info*)my_lock->lock_info;\n\n  if (pthread_mutex_destroy(&my_mutex->mutex) == 0)\n  {\n    free(my_lock);\n    return Ret_Success;\n  }\n  else\n  {\n    SR_ERR(\"\\n\");\n  }\n}\n\nMy_Lock* Init_Mutex_Pthread(void)\n{\n  My_Lock* my_lock = malloc(sizeof(My_Lock)+sizeof(mutex_info));\n  check_pointer_return_value(my_lock, NULL);\n\n  mutex_info* my_mutex;\n  my_mutex = (mutex_info*)my_lock->lock_info;\n  pthread_mutex_init(&(my_mutex->mutex),NULL);\n\n  my_lock->DoLock = Mutex_Pthread_lock;\n  my_lock->DoUnlock = Mutex_Pthread_unlock;\n  my_lock->DoDestory = Mutex_Pthread_destory; \n  \n  return my_lock;\n\n}\n\n```\n\n___d.global_enum_macro.h___\n\n```\n#include <stdio.h>\n\n// Define GLobal Enum\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None,\n}Ret;\n\n// Define Global Macro\n#define SR_DBG(fmt,args ...) printf(\"[Sheldon debug][%s][%d] \"fmt,__FUNCTION__,__LINE__,##args)\n#define SR_ERR(fmt,args ...) printf(\"ERROR !!! [%s][%d ] \"fmt, __FUNCTION__,__LINE__,##args)\n#define check_pointer_return_value(ptr,value) if(ptr==NULL) \\\n                                                  { printf(\"ERROR!!! #ptr is NULL, return #value \\r\\n\"); \\\n                                                  return value;} \\\n\n\n\n\n```\n\n___e.lock_inter_face.h___\n\n```\n#include \"global_enum_macro.h\"\n\n// For basic lock\nstruct _my_lock;\ntypedef struct _my_lock My_lock;\n\ntypedef Ret (*LockFun)(My_lock*);\ntypedef Ret (*UnLockFun)(My_lock*);\ntypedef Ret (*DestoryLockFun)(My_lock*);\n\ntypedef struct _my_lock\n{\n  LockFun DoLock;\n  UnLockFun DoUnlock;\n  DestoryLockFun DoDestory;\n  char lock_info[0];\n}My_Lock;\n\n\n// For read/write lock\nstruct _read_write_lock;\ntypedef struct _read_write_lock read_write_lock;\ntypedef Ret (*ReadLockFun)(read_write_lock*);\ntypedef Ret (*WriteLockFun)(read_write_lock*);\ntypedef Ret (*UnReadWriteLockFun)(read_write_lock*);\ntypedef Ret (*DestroyReadWriteLockFun)(read_write_lock*);\n\ntypedef enum _ReadWriteLockMode\n{\n  Read_Lock_Mode,\n  Write_Lock_Mode,\n  None_Lock_Mode,\n}ReadWriteLockMode;\n\n\ntypedef struct _read_write_lock\n{\n  int read_count;\n  My_Lock* RLock;\n  My_Lock* WLock;\n\n  ReadWriteLockMode lock_mode;\n  ReadLockFun read_lock_Fun;\n  WriteLockFun write_lock_Fun;\n  UnReadWriteLockFun un_read_write_lock;\n  DestroyReadWriteLockFun destroy_read_write_lock;\n}read_write_lock;\n\nRet api_my_lock(My_Lock* my_lock);\nRet api_my_unlock(My_Lock* my_lock);\nRet api_my_destory(My_Lock* my_lock);\n\n```\n\n___f.lock_interface.c___\n\n```\n#include \"lock_interface.h\"\n\n\nRet api_my_lock(My_Lock* my_lock)\n{\n check_pointer_return_value(my_lock, Ret_Fail);\n if (my_lock->DoLock(my_lock) == Ret_Fail) \n {\n    SR_ERR(\"\\n\");\n }\n return Ret_Success;\n}\n\nRet api_my_unlock(My_Lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail); \n  if (my_lock->DoUnlock(my_lock) == Ret_Fail)\n  {\n    SR_ERR(\"\\n\");\n  }\n  return Ret_Success;\n}\n\nRet api_my_destory(My_Lock* my_lock)\n{\n  check_pointer_return_value(my_lock, Ret_Fail);\n  \n  if (my_lock->DoDestory(my_lock) == Ret_Fail)\n  {\n    SR_ERR(\"\\n\");\n  }\n  return Ret_Success;\n}\n\n```\n\n","slug":"Read-Write-Lock-Mutex-exercise-to-implement-the-read-write-lock-in-the-mutex","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp25p001g35gg3zed1xhy"},{"title":"[Queue] Create the Queue structure by the Double Link List","date":"2015-05-05T00:21:52.000Z","toc":true,"_content":"\n# Purpose\n\n爲了鍛鍊自己的能力，所以就是想寫點東西，看到別人用雙向鏈接兜出了\n\n一個queue 的結構,自己也想無中生有的產生一個出來.前一篇已經有完成了\n\n雙向鏈結，這篇就有點想是表現組合的威力.基本上無論是queue或是stack\n\n都是雙向鏈結的特例,所以真是基礎打的好，什麼都能迎刃而解.\n\n# Explain the conecpt of the Queue Structure. \n\nQueue 其實就是先進先出.我們只有多包一層API,強迫caller使用API的時候,\n\nPush都是將雙向鏈結的Node,推在前端,讓後將原本在queue 裏面的往後移.\n\nPop的話，就單純將queue裏面最後一個雙向鏈結的Node移除. \n\n槪念相當單純,由於我在雙向鏈結的實作,將Node所存的type,交給caller來決定,\n\n所以在Queue 的 Demo code裏面,也是沿用這樣的概念. \n\n根據如何操作Queue,所以我開了底下這些API, \n\n實際如何包就請參考擺在最後面的code.\n\n```\nQueue* Queue_Create(void);\nRet Queue_Destroy(Queue*);\nRet Queue_Print_all(Queue*, DList_Print);\nRet Queue_Push(Queue*, DList* InsertNode);\nRet Queue_Pop(Queue*);\nRet Queue_Get_Length(Queue*, int* length);\n```\n\n由於Queue其實就是雙向鏈接的特例，所以結構上就是跟雙向鏈結一樣\n\n只是會限制他的操作，所以Queue的結構就定義成底下\n\n```\ntypedef struct _Queue\n{\n  DList* HeadNode;\n}Queue;\n\n```\n\n# FULL CODE \n\n___1. queue.h___\n\n```\n#include \"DList.h\"\n\ntypedef struct _Queue\n{\n  DList* HeadNode;\n}Queue;\n\nQueue* Queue_Create(void);\nRet Queue_Destroy(Queue*);\nRet Queue_Print_all(Queue*, DList_Print);\nRet Queue_Push(Queue*, DList* InsertNode);\nRet Queue_Pop(Queue*);\nRet Queue_Get_Length(Queue*, int* length);\n```\n\n___2.queue.c___\n\n```\n#include <stdlib.h>\n#include \"queue.h\"\n\nQueue* Queue_Create(void)\n{\n  Queue* myQueue = (Queue*)malloc(sizeof(Queue));\n  check_pointer_return_value(myQueue, NULL);\n\n  myQueue->HeadNode = DList_Create();\n  return myQueue;\n}\n\nRet Queue_Destroy(Queue* myQueue)\n{\n  check_pointer_return_value(myQueue, Ret_Fail);\n  if ( Ret_Fail == DList_Destroy( myQueue->HeadNode) )\n  {\n    SR_ERR(\"DList_Destroy FAILLL\\n\");\n    return Ret_Fail;\n  }\n  SR_DBG(\"Free the QUEUE\\n\");\n  free(myQueue);\n  return Ret_Success;\n}\n\nRet Queue_Print_all(Queue* myQueue, DList_Print Print)\n{\n  check_pointer_return_value(myQueue, Ret_Fail);\n  return DList_Print_all(myQueue->HeadNode, Print);\n}\n\nRet Queue_Push(Queue* myQueue, DList* InsertNode)\n{\n  // I think the Head Node doesn't belong to be the Data Node.\n  check_pointer_return_value(myQueue, Ret_Fail);\n  return DList_Insert_Node_ByIndex(myQueue->HeadNode, InsertNode, 1);\n}\n\nRet Queue_Pop(Queue* myQueue)\n{\n  check_pointer_return_value(myQueue, Ret_Fail);\n  int length =0;\n  if (Ret_Fail == DList_Get_Length(myQueue->HeadNode, &length))\n  {\n    SR_ERR(\"Get the Length of DList \\n\");\n    return Ret_Fail;\n  }\n\n  return (DList_Delete_Node_ByIndex(myQueue->HeadNode, length));\n\n}\n\nRet Queue_Get_Length(Queue* myQueue, int* length)\n{\n  check_pointer_return_value(myQueue, Ret_Fail);\n  return DList_Get_Length(myQueue->HeadNode, length);\n}\n\n```\n\n___3.DList.h___\n\n```\n#include \"global_enum_macro.h\"\n\ntypedef struct _DList\n{\n  struct _DList* DList_Pre_Ptr;\n  struct _DList* DList_Next_Ptr;\n  void* data;\n  int key;\n}DList;\n\nDList* DList_Create(void);\nRet DList_Destroy(DList*);\ntypedef Ret (*DList_Print)(DList*);\nRet DList_Print_all(DList*, DList_Print);\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index);\nRet DList_Delete_Node_ByIndex(DList*, int index);\nRet DList_Get_NodeData_ByIndex(DList*, int index, void** data);\nRet DList_Get_Length(DList*, int* length);\n```\n\n___4.DList.c___\n\n```\n#include \"DList.h\"\n#include \"stdlib.h\"\n\n\nDList* DList_Create(void)\n{\n  // Create the Head Node for Double Link List\n  DList* HeadNode = (DList*)malloc(sizeof(DList));\n  \n  check_pointer_return_value(HeadNode,NULL);\n\n  HeadNode->DList_Pre_Ptr = NULL;\n  HeadNode->DList_Next_Ptr = NULL;\n  \n  return HeadNode;\n\n}\n\nRet DList_Destroy(DList* HeadNode)\n{\n\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  DList* Temp_Ptr = HeadNode;\n\n  while (1)\n  {\n      if (HeadNode == NULL)\n      {\n        printf(\"Success to Destroy the Double Link List\\n\");\n        return Ret_Success;\n      }\n\n      HeadNode = HeadNode->DList_Next_Ptr;\n      \n      free(Temp_Ptr->data);\n      free(Temp_Ptr);\n\n      Temp_Ptr = HeadNode;\n  }\n\n}\n\nRet DList_Print_all(DList* HeadNode, DList_Print Print)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(Print, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ? \n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  DList* DList_Ptr = HeadNode;\n\n  while (DList_Ptr->DList_Next_Ptr != NULL)\n  {\n    // if the node is HEAD, we skip that node\n    if (DList_Ptr->DList_Pre_Ptr != NULL)\n    {\n      Print(DList_Ptr);\n    }\n      DList_Ptr = DList_Ptr->DList_Next_Ptr;\n  }\n\n  // Print the Tail Node's data\n  Print(DList_Ptr);\n\n}\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(InsertNode, Ret_Fail);\n\n  // check the Double Link List is EMPTY ??\n  if (HeadNode->DList_Pre_Ptr == NULL && HeadNode->DList_Next_Ptr == NULL)\n  {\n    HeadNode->DList_Next_Ptr = InsertNode;\n    InsertNode->DList_Next_Ptr = NULL;\n    InsertNode->DList_Pre_Ptr = HeadNode;\n    printf(\"Because the Double Link List is EMPTY, so I force the index to be 1 \\n\");\n    return Ret_Success;\n  }\n  \n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n\n  do\n  {\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n    if (cnt == index)\n    {\n      InsertNode->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      InsertNode->DList_Pre_Ptr->DList_Next_Ptr = InsertNode;\n      Temp_Ptr->DList_Pre_Ptr = InsertNode;\n      InsertNode->DList_Next_Ptr = Temp_Ptr;\n      return Ret_Success;\n    }\n    \n  } while ( Temp_Ptr->DList_Next_Ptr != NULL);\n\n  // If the index is large than the length of Double link list, just add the NODE into the tail of Double Link List.\n\n  printf(\"Because the index is large than the length of Double Link List, just insert the NODE into the tail of Double LInke List \\n\");\n  Temp_Ptr->DList_Next_Ptr = InsertNode;\n  InsertNode->DList_Next_Ptr = NULL;\n  return Ret_Success;\n}\n\nRet DList_Delete_Node_ByIndex(DList* HeadNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n  while (Temp_Ptr->DList_Next_Ptr != NULL)\n  {\n    if (cnt == index)\n    {\n      Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = Temp_Ptr->DList_Next_Ptr;\n      Temp_Ptr->DList_Next_Ptr->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      printf(\"Free the Node of Indx[%d] \\n\", index);\n      free(Temp_Ptr->data);\n      free(Temp_Ptr);\n      return Ret_Success;\n    }\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n  }\n\n  // Because the index is large than the length of Double Link List && the Node which you want to delete is TAIL Node. \n\n  printf(\"Free the TAIL NODE \\n\");\n  Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = NULL;\n  free(Temp_Ptr->data);\n  free(Temp_Ptr);\n  return Ret_Success;\n}\n\n\nRet DList_Get_NodeData_ByIndex(DList* HeadNode, int index, void** data)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  \n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n  do \n  {\n    cnt++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr; \n    if (cnt == index || Temp_Ptr->DList_Next_Ptr == NULL)\n    {\n      if (Temp_Ptr->DList_Next_Ptr == NULL)\n      {\n        // Tail Node\n        printf(\"The index is larger than the length of Double Link List, so just get the data of Tail Node for you \\n\");\n      }\n      *data = (void*)(Temp_Ptr->data);\n      return Ret_Success;\n    }\n  } while(1);\n}\n\nRet DList_Get_Length(DList* HeadNode, int* length)\n{\n\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  \n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    *length = 0;\n    check_pointer_return_value(NULL, Ret_Success);\n  }\n\n  *length=0;\n  DList* Temp_Ptr = HeadNode;\n  do \n  {\n    (*length)++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr; \n    if (Temp_Ptr->DList_Next_Ptr == NULL)\n    {\n      return Ret_Success;\n    }\n  } while(1);\n\n\n}\n\n```\n\n___5.global_enum_macro.h___\n\n```\n#include <stdio.h>\n\n// Define GLobal Enum\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None,\n}Ret;\n\n// Define Global Macro\n#define SR_DBG(fmt,args ...) printf(\"[Sheldon debug][%s][%d] \"fmt,__FUNCTION__,__LINE__,##args)\n#define SR_ERR(fmt,args ...) printf(\"ERROR !!! [%s][%d ] \"fmt, __FUNCTION__,__LINE__,##args)\n#define check_pointer_return_value(ptr,value) if(ptr==NULL) \\\n                                                  { printf(\"[%s][%d] ERROR!!! #ptr# is NULL, return #value# \\r\\n\",__FUNCTION__,__LINE__); \\\n                                                  return value;} \\\n\n```\n\n___6.main.c___\n\n```\n#include <stdlib.h>\n#include \"queue.h\"\n\nRet MyPrint(DList* MyDList)\n{\n  check_pointer_return_value(MyDList, Ret_Fail);\n  // This place tell how to print the DLinkList's data type\n  printf(\"MyDList->key=%d, *(int*)(MyDList->data)=%d \\r\\n\", MyDList->key, *(int*)(MyDList->data));\n}\n\nDList* Create_Node(int data)\n{\n  DList* myNode = (DList*)malloc(sizeof(DList));\n  myNode->data = (int*)malloc(sizeof(int));\n  *(int*)(myNode->data) = data; \n  return myNode;\n}\n\nvoid main(void)\n{\n  Queue* myQueue = Queue_Create() ; \n\n  // Push the Node to Queue\n  Queue_Push(myQueue, Create_Node(10));\n  Queue_Push(myQueue, Create_Node(20));\n  Queue_Push(myQueue, Create_Node(30));\n  Queue_Push(myQueue, Create_Node(40));\n  Queue_Push(myQueue, Create_Node(50));\n  \n  // Print all the Nodes of Queue\n  Queue_Print_all(myQueue, MyPrint);\n\n  // Pop out  the Node from Queue\n  Queue_Pop(myQueue);\n  Queue_Pop(myQueue);\n\n  // Print all the Nodes of Queue\n  Queue_Print_all(myQueue, MyPrint);\n\n  // Destroy the Queue\n  if (Ret_Success == Queue_Destroy(myQueue))\n  {\n    SR_DBG(\"Destroy Queue -- Success !!!\\n\");\n    myQueue = NULL;\n  }\n\n  Queue_Print_all(myQueue, MyPrint);\n\n}\n```\n","source":"_posts/Queue-Create-the-Queue-structure-by-the-Double-Link-List.md","raw":"title: \"[Queue] Create the Queue structure by the Double Link List\"\ndate: 2015-05-05 08:21:52\ncategories:\n- queue\ntags:\n- data structure\n- queue \n- double link list\ntoc: true\n---\n\n# Purpose\n\n爲了鍛鍊自己的能力，所以就是想寫點東西，看到別人用雙向鏈接兜出了\n\n一個queue 的結構,自己也想無中生有的產生一個出來.前一篇已經有完成了\n\n雙向鏈結，這篇就有點想是表現組合的威力.基本上無論是queue或是stack\n\n都是雙向鏈結的特例,所以真是基礎打的好，什麼都能迎刃而解.\n\n# Explain the conecpt of the Queue Structure. \n\nQueue 其實就是先進先出.我們只有多包一層API,強迫caller使用API的時候,\n\nPush都是將雙向鏈結的Node,推在前端,讓後將原本在queue 裏面的往後移.\n\nPop的話，就單純將queue裏面最後一個雙向鏈結的Node移除. \n\n槪念相當單純,由於我在雙向鏈結的實作,將Node所存的type,交給caller來決定,\n\n所以在Queue 的 Demo code裏面,也是沿用這樣的概念. \n\n根據如何操作Queue,所以我開了底下這些API, \n\n實際如何包就請參考擺在最後面的code.\n\n```\nQueue* Queue_Create(void);\nRet Queue_Destroy(Queue*);\nRet Queue_Print_all(Queue*, DList_Print);\nRet Queue_Push(Queue*, DList* InsertNode);\nRet Queue_Pop(Queue*);\nRet Queue_Get_Length(Queue*, int* length);\n```\n\n由於Queue其實就是雙向鏈接的特例，所以結構上就是跟雙向鏈結一樣\n\n只是會限制他的操作，所以Queue的結構就定義成底下\n\n```\ntypedef struct _Queue\n{\n  DList* HeadNode;\n}Queue;\n\n```\n\n# FULL CODE \n\n___1. queue.h___\n\n```\n#include \"DList.h\"\n\ntypedef struct _Queue\n{\n  DList* HeadNode;\n}Queue;\n\nQueue* Queue_Create(void);\nRet Queue_Destroy(Queue*);\nRet Queue_Print_all(Queue*, DList_Print);\nRet Queue_Push(Queue*, DList* InsertNode);\nRet Queue_Pop(Queue*);\nRet Queue_Get_Length(Queue*, int* length);\n```\n\n___2.queue.c___\n\n```\n#include <stdlib.h>\n#include \"queue.h\"\n\nQueue* Queue_Create(void)\n{\n  Queue* myQueue = (Queue*)malloc(sizeof(Queue));\n  check_pointer_return_value(myQueue, NULL);\n\n  myQueue->HeadNode = DList_Create();\n  return myQueue;\n}\n\nRet Queue_Destroy(Queue* myQueue)\n{\n  check_pointer_return_value(myQueue, Ret_Fail);\n  if ( Ret_Fail == DList_Destroy( myQueue->HeadNode) )\n  {\n    SR_ERR(\"DList_Destroy FAILLL\\n\");\n    return Ret_Fail;\n  }\n  SR_DBG(\"Free the QUEUE\\n\");\n  free(myQueue);\n  return Ret_Success;\n}\n\nRet Queue_Print_all(Queue* myQueue, DList_Print Print)\n{\n  check_pointer_return_value(myQueue, Ret_Fail);\n  return DList_Print_all(myQueue->HeadNode, Print);\n}\n\nRet Queue_Push(Queue* myQueue, DList* InsertNode)\n{\n  // I think the Head Node doesn't belong to be the Data Node.\n  check_pointer_return_value(myQueue, Ret_Fail);\n  return DList_Insert_Node_ByIndex(myQueue->HeadNode, InsertNode, 1);\n}\n\nRet Queue_Pop(Queue* myQueue)\n{\n  check_pointer_return_value(myQueue, Ret_Fail);\n  int length =0;\n  if (Ret_Fail == DList_Get_Length(myQueue->HeadNode, &length))\n  {\n    SR_ERR(\"Get the Length of DList \\n\");\n    return Ret_Fail;\n  }\n\n  return (DList_Delete_Node_ByIndex(myQueue->HeadNode, length));\n\n}\n\nRet Queue_Get_Length(Queue* myQueue, int* length)\n{\n  check_pointer_return_value(myQueue, Ret_Fail);\n  return DList_Get_Length(myQueue->HeadNode, length);\n}\n\n```\n\n___3.DList.h___\n\n```\n#include \"global_enum_macro.h\"\n\ntypedef struct _DList\n{\n  struct _DList* DList_Pre_Ptr;\n  struct _DList* DList_Next_Ptr;\n  void* data;\n  int key;\n}DList;\n\nDList* DList_Create(void);\nRet DList_Destroy(DList*);\ntypedef Ret (*DList_Print)(DList*);\nRet DList_Print_all(DList*, DList_Print);\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index);\nRet DList_Delete_Node_ByIndex(DList*, int index);\nRet DList_Get_NodeData_ByIndex(DList*, int index, void** data);\nRet DList_Get_Length(DList*, int* length);\n```\n\n___4.DList.c___\n\n```\n#include \"DList.h\"\n#include \"stdlib.h\"\n\n\nDList* DList_Create(void)\n{\n  // Create the Head Node for Double Link List\n  DList* HeadNode = (DList*)malloc(sizeof(DList));\n  \n  check_pointer_return_value(HeadNode,NULL);\n\n  HeadNode->DList_Pre_Ptr = NULL;\n  HeadNode->DList_Next_Ptr = NULL;\n  \n  return HeadNode;\n\n}\n\nRet DList_Destroy(DList* HeadNode)\n{\n\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  DList* Temp_Ptr = HeadNode;\n\n  while (1)\n  {\n      if (HeadNode == NULL)\n      {\n        printf(\"Success to Destroy the Double Link List\\n\");\n        return Ret_Success;\n      }\n\n      HeadNode = HeadNode->DList_Next_Ptr;\n      \n      free(Temp_Ptr->data);\n      free(Temp_Ptr);\n\n      Temp_Ptr = HeadNode;\n  }\n\n}\n\nRet DList_Print_all(DList* HeadNode, DList_Print Print)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(Print, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ? \n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  DList* DList_Ptr = HeadNode;\n\n  while (DList_Ptr->DList_Next_Ptr != NULL)\n  {\n    // if the node is HEAD, we skip that node\n    if (DList_Ptr->DList_Pre_Ptr != NULL)\n    {\n      Print(DList_Ptr);\n    }\n      DList_Ptr = DList_Ptr->DList_Next_Ptr;\n  }\n\n  // Print the Tail Node's data\n  Print(DList_Ptr);\n\n}\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(InsertNode, Ret_Fail);\n\n  // check the Double Link List is EMPTY ??\n  if (HeadNode->DList_Pre_Ptr == NULL && HeadNode->DList_Next_Ptr == NULL)\n  {\n    HeadNode->DList_Next_Ptr = InsertNode;\n    InsertNode->DList_Next_Ptr = NULL;\n    InsertNode->DList_Pre_Ptr = HeadNode;\n    printf(\"Because the Double Link List is EMPTY, so I force the index to be 1 \\n\");\n    return Ret_Success;\n  }\n  \n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n\n  do\n  {\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n    if (cnt == index)\n    {\n      InsertNode->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      InsertNode->DList_Pre_Ptr->DList_Next_Ptr = InsertNode;\n      Temp_Ptr->DList_Pre_Ptr = InsertNode;\n      InsertNode->DList_Next_Ptr = Temp_Ptr;\n      return Ret_Success;\n    }\n    \n  } while ( Temp_Ptr->DList_Next_Ptr != NULL);\n\n  // If the index is large than the length of Double link list, just add the NODE into the tail of Double Link List.\n\n  printf(\"Because the index is large than the length of Double Link List, just insert the NODE into the tail of Double LInke List \\n\");\n  Temp_Ptr->DList_Next_Ptr = InsertNode;\n  InsertNode->DList_Next_Ptr = NULL;\n  return Ret_Success;\n}\n\nRet DList_Delete_Node_ByIndex(DList* HeadNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n  while (Temp_Ptr->DList_Next_Ptr != NULL)\n  {\n    if (cnt == index)\n    {\n      Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = Temp_Ptr->DList_Next_Ptr;\n      Temp_Ptr->DList_Next_Ptr->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      printf(\"Free the Node of Indx[%d] \\n\", index);\n      free(Temp_Ptr->data);\n      free(Temp_Ptr);\n      return Ret_Success;\n    }\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n  }\n\n  // Because the index is large than the length of Double Link List && the Node which you want to delete is TAIL Node. \n\n  printf(\"Free the TAIL NODE \\n\");\n  Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = NULL;\n  free(Temp_Ptr->data);\n  free(Temp_Ptr);\n  return Ret_Success;\n}\n\n\nRet DList_Get_NodeData_ByIndex(DList* HeadNode, int index, void** data)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  \n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n  do \n  {\n    cnt++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr; \n    if (cnt == index || Temp_Ptr->DList_Next_Ptr == NULL)\n    {\n      if (Temp_Ptr->DList_Next_Ptr == NULL)\n      {\n        // Tail Node\n        printf(\"The index is larger than the length of Double Link List, so just get the data of Tail Node for you \\n\");\n      }\n      *data = (void*)(Temp_Ptr->data);\n      return Ret_Success;\n    }\n  } while(1);\n}\n\nRet DList_Get_Length(DList* HeadNode, int* length)\n{\n\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  \n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    *length = 0;\n    check_pointer_return_value(NULL, Ret_Success);\n  }\n\n  *length=0;\n  DList* Temp_Ptr = HeadNode;\n  do \n  {\n    (*length)++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr; \n    if (Temp_Ptr->DList_Next_Ptr == NULL)\n    {\n      return Ret_Success;\n    }\n  } while(1);\n\n\n}\n\n```\n\n___5.global_enum_macro.h___\n\n```\n#include <stdio.h>\n\n// Define GLobal Enum\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None,\n}Ret;\n\n// Define Global Macro\n#define SR_DBG(fmt,args ...) printf(\"[Sheldon debug][%s][%d] \"fmt,__FUNCTION__,__LINE__,##args)\n#define SR_ERR(fmt,args ...) printf(\"ERROR !!! [%s][%d ] \"fmt, __FUNCTION__,__LINE__,##args)\n#define check_pointer_return_value(ptr,value) if(ptr==NULL) \\\n                                                  { printf(\"[%s][%d] ERROR!!! #ptr# is NULL, return #value# \\r\\n\",__FUNCTION__,__LINE__); \\\n                                                  return value;} \\\n\n```\n\n___6.main.c___\n\n```\n#include <stdlib.h>\n#include \"queue.h\"\n\nRet MyPrint(DList* MyDList)\n{\n  check_pointer_return_value(MyDList, Ret_Fail);\n  // This place tell how to print the DLinkList's data type\n  printf(\"MyDList->key=%d, *(int*)(MyDList->data)=%d \\r\\n\", MyDList->key, *(int*)(MyDList->data));\n}\n\nDList* Create_Node(int data)\n{\n  DList* myNode = (DList*)malloc(sizeof(DList));\n  myNode->data = (int*)malloc(sizeof(int));\n  *(int*)(myNode->data) = data; \n  return myNode;\n}\n\nvoid main(void)\n{\n  Queue* myQueue = Queue_Create() ; \n\n  // Push the Node to Queue\n  Queue_Push(myQueue, Create_Node(10));\n  Queue_Push(myQueue, Create_Node(20));\n  Queue_Push(myQueue, Create_Node(30));\n  Queue_Push(myQueue, Create_Node(40));\n  Queue_Push(myQueue, Create_Node(50));\n  \n  // Print all the Nodes of Queue\n  Queue_Print_all(myQueue, MyPrint);\n\n  // Pop out  the Node from Queue\n  Queue_Pop(myQueue);\n  Queue_Pop(myQueue);\n\n  // Print all the Nodes of Queue\n  Queue_Print_all(myQueue, MyPrint);\n\n  // Destroy the Queue\n  if (Ret_Success == Queue_Destroy(myQueue))\n  {\n    SR_DBG(\"Destroy Queue -- Success !!!\\n\");\n    myQueue = NULL;\n  }\n\n  Queue_Print_all(myQueue, MyPrint);\n\n}\n```\n","slug":"Queue-Create-the-Queue-structure-by-the-Double-Link-List","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp262001q35ggkwnh5ysn"},{"title":"[Netwoek][Scan IP] nmap","date":"2015-03-24T15:58:26.000Z","toc":true,"_content":"\n之前發現了 fping 可以掃描網域IP, 今天又發現了一個更強大的工具 nmap ...\n\nXDD, 還不是很會用, 先記錄一下, 之後再找時間來介紹. \n\n假如你想要掃整個子網域, 可以用底下的指令\n\n```\nnmap 192.168.0.*\n```\n[參考](http://www.gtwang.org/2014/10/nmap-command-examples-tutorials.html)\n","source":"_posts/Netwoek-Scan-IP-nmap.md","raw":"title: \"[Netwoek][Scan IP] nmap\"\ndate: 2015-03-24 23:58:26\ncategories:\n- nmap\ntags:\n- nmap\n- network\n- fping\ntoc: true\n---\n\n之前發現了 fping 可以掃描網域IP, 今天又發現了一個更強大的工具 nmap ...\n\nXDD, 還不是很會用, 先記錄一下, 之後再找時間來介紹. \n\n假如你想要掃整個子網域, 可以用底下的指令\n\n```\nnmap 192.168.0.*\n```\n[參考](http://www.gtwang.org/2014/10/nmap-command-examples-tutorials.html)\n","slug":"Netwoek-Scan-IP-nmap","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp269001x35ggyc67iikp"},{"title":"My First Post","date":"2015-01-13T16:06:08.000Z","toc":true,"_content":"\n# Why Do I Create This Blog ? \nThis blog tell what I learn in my life. I waste a lot of time in nothing thing. \nSo right now, it is the time to tell more about the signitifant thing, such as \ntechnical skill, knowledgement, programming, life news, funny things, how to\nmanage your finance and how to be a wonderful man. \n\n# Who Am I ? \nI was a physics students in the university. Then I got the master degree of EE.\nBut I was interested in computer science for a long time, so I took an effert to learn the knowledge by myself. \nFinally, I am a software engineer. Hope that I can be an entrepreneur in the software field. \n\n## Technical Skill\n1. Programming : C/Matlab/Python/Shell Scripts\n2. OS : Linux/Ecos\n3. Embedded Chip : Raspberry Pi/ MSTAR's Chip\n4. Distributed revision control system : GIT\n5. Android RIL\n6. Video Decoder knowldege.\n7. TV knowledge (T-CON/Over-Driver/Decompression/Local Dimming)\n8. Closed Caption knowledge\n\n## Working Experience\n\n### MSTAR (2014/2~now)\n\n### HTC (2011/11~2014/1)\n\n### CHEMI (2008/11~2011/11)\n\n## Academic\n### Master Degree \n\n### Bachelor\n\n\n# How to contact me ? \n*PM me to following email*\n>**rushpeng@gmail.com**\n\n*LinkedIn* \n>**[My_LinkedIN](https://www.linkedin.com/profile/public-profile-settings?trk=prof-edit-edit-public_profile)**\n\n_Phone_\n>**(+886)918721062**\n\n\n\n","source":"_posts/My-First-Post.md","raw":"title: My First Post\ndate: 2015-01-14 00:06:08\ncategories: ME\ntags:\n- geek \n- resume\ntoc: true\n---\n\n# Why Do I Create This Blog ? \nThis blog tell what I learn in my life. I waste a lot of time in nothing thing. \nSo right now, it is the time to tell more about the signitifant thing, such as \ntechnical skill, knowledgement, programming, life news, funny things, how to\nmanage your finance and how to be a wonderful man. \n\n# Who Am I ? \nI was a physics students in the university. Then I got the master degree of EE.\nBut I was interested in computer science for a long time, so I took an effert to learn the knowledge by myself. \nFinally, I am a software engineer. Hope that I can be an entrepreneur in the software field. \n\n## Technical Skill\n1. Programming : C/Matlab/Python/Shell Scripts\n2. OS : Linux/Ecos\n3. Embedded Chip : Raspberry Pi/ MSTAR's Chip\n4. Distributed revision control system : GIT\n5. Android RIL\n6. Video Decoder knowldege.\n7. TV knowledge (T-CON/Over-Driver/Decompression/Local Dimming)\n8. Closed Caption knowledge\n\n## Working Experience\n\n### MSTAR (2014/2~now)\n\n### HTC (2011/11~2014/1)\n\n### CHEMI (2008/11~2011/11)\n\n## Academic\n### Master Degree \n\n### Bachelor\n\n\n# How to contact me ? \n*PM me to following email*\n>**rushpeng@gmail.com**\n\n*LinkedIn* \n>**[My_LinkedIN](https://www.linkedin.com/profile/public-profile-settings?trk=prof-edit-edit-public_profile)**\n\n_Phone_\n>**(+886)918721062**\n\n\n\n","slug":"My-First-Post","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp26g002635ggxqahh0ei"},{"title":"How to call C++ class member function from C","date":"2015-06-26T22:18:41.000Z","toc":true,"_content":"\n#Purpose\n\n整個晚上都睡不着,大概是因爲今天被一個無心的朋友傷到自信心\n\n難道物理系不能寫出好的code嗎,雖然真的也是有一段時間沒有磨練自己了.\n\n爲了捍衛自己的尊嚴,還是必須要嚴守每天寫點程式的習慣.\n\n今天想到一件事情,要如何從C語言去呼叫C++的class member function.\n\n這件事情,感覺挺有趣的,所以花了點時間看看要如何實作.\n\n#HOW TO DO \n\n概念是這樣滴, C的code是無法直接呼叫C++ class的member,\n\n必須要透過一層wrapper 層的來變相取得class的member, 要注意的是, 這個wrapper 層也必須是C++,\n\n你會發現, 其實這個wrapper 只是利用物件的poiner 去操作, class member.\n\n底下的例子，我會定一個class, 然後再把這個class 包成一個static lib.\n\n接着就會用C code去呼叫他.\n\n## core.cpp\n\n如上面所說,我定義一個class並且放在core.cpp 裏面,裏面只有一個member function,\n\n唯一的功用就是將兩個數字相加後.印出來.\n\n```\n#include <iostream>\n\nusing namespace std;\n\nclass MyCPP {\n  public : \n    void PrintNumber(int num1, int num2); \n};\n\nvoid MyCPP :: PrintNumber(int num1, int num2)\n{\n  cout << (num1+num2) <<endl;\n\n}\n```\n\n## wrapper.h\n\n再來就是實作wrapper層的api,這層非常的有意思,先來講一下這個header file,\n\n由於c++的compiler對於symbol有Name Mangling的行爲(也就是會改變數函式名稱)\n\n所以假如我們wrapper這層的api,要同時被C以及C++使用的話,我們必須讓g++ compiler symbol不去做name mangling.\n\n要怎麼做呢？就是透過 extern \"C\" 這個關鍵字.\n\n爲了避免gcc compiler 在include wrapper.h 出現compiler error, 我們再用cplusplus去隔開.\n;\n還有一件事情要注意壓,由於是要給C code 使用,但是C一定沒有class 這種結構,所以就會將class的poiner\n\n先暫時指向void\n\n```\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    void* api_create_class(void);\n    void api_destory_class(void*);\n    void api_print_sum(void*, int, int);\n#ifdef __cplusplus\n}\n#endif\n```\n\n## wrapper.cpp\n\n這三個wrapper api 的實作,非常容易.比較要注意的是,C++ 的形態轉換,是用 static_cast<CLASS>\n\n```\n#include \"core.cpp\"\n#include \"wrapper.h\"\n\nvoid* api_create_class(void)\n{\n  return new MyCPP();\n}\n\nvoid api_destory_class(void* thiz) \n{\n  delete static_cast<MyCPP*>(thiz);\n}\n\nvoid api_print_sum(void* thiz, int num1, int num2)\n{\n  static_cast<MyCPP*>(thiz)->PrintNumber(num1,num2);\n}\n\n```\n\n## main.c \n\n再來就是要進入測試成果的部分囉, \n\n先include wrapper.h, 然後在使用他囉!!!!\n\n```\n#include <stdio.h> \n#include \"wrapper.h\"\n\nint main(int argc, char** argv)\n{\n  printf(\"Hello, This sample code teach us how to call CPP class function from C \\r\\n\");\n  \n  printf(\" New a Class \\r\\n\");\n  void* MyClass = api_create_class();\n\n  printf(\" Print the Sum of Numbers \\r\\n\");\n  api_print_sum(MyClass, 10, 20);\n\n  printf(\" Delete the Class \\r\\n\");\n  api_destory_class(MyClass);\n\n  return 0;\n}\n```\n\n\n# How To Compiler \n\n挖勒,剛講這麼多,到底要怎麼編code呀???\n\n接下來就是要介紹如何 compiler. \n\n假如你都有照着作下來的話,你應該會有底下這些檔案. \n\n```\ncore.cpp  main.c  wrapper.cpp  wrapper.h\n```\n\n## 製作C++靜態lib \n\n```\ng++ wrapper.cpp core.cpp -c    // 你換發現多了兩個 .o 檔\nar rvs libMyCPP.a wrapper.o core.o\n```\n\n## 製作C (main) 的object code\n\n```\ngcc main.c -c      // 你會發現多了一個main.o\n```\n\n## 利用g++ 去做LINK \n\n```\ng++ main.o libMyCPP.a -o test\n```\n\n## 驗證成果 !!!\n\n```\n./test\n```\n\n```\nHello, This sample code teach us how to call the static of CPP from C \nNew a Class \nPrint the Sum of Numbers \n30\nDelete the Class\n```\n\n\n\n\n","source":"_posts/How-to-call-C-calss-member-function-from-C.md","raw":"title: \"How to call C++ class member function from C\"\ndate: 2015-06-27 06:18:41\ncategories:\n- C\ntags:\n- C\n- C++\n- class\ntoc: true\n---\n\n#Purpose\n\n整個晚上都睡不着,大概是因爲今天被一個無心的朋友傷到自信心\n\n難道物理系不能寫出好的code嗎,雖然真的也是有一段時間沒有磨練自己了.\n\n爲了捍衛自己的尊嚴,還是必須要嚴守每天寫點程式的習慣.\n\n今天想到一件事情,要如何從C語言去呼叫C++的class member function.\n\n這件事情,感覺挺有趣的,所以花了點時間看看要如何實作.\n\n#HOW TO DO \n\n概念是這樣滴, C的code是無法直接呼叫C++ class的member,\n\n必須要透過一層wrapper 層的來變相取得class的member, 要注意的是, 這個wrapper 層也必須是C++,\n\n你會發現, 其實這個wrapper 只是利用物件的poiner 去操作, class member.\n\n底下的例子，我會定一個class, 然後再把這個class 包成一個static lib.\n\n接着就會用C code去呼叫他.\n\n## core.cpp\n\n如上面所說,我定義一個class並且放在core.cpp 裏面,裏面只有一個member function,\n\n唯一的功用就是將兩個數字相加後.印出來.\n\n```\n#include <iostream>\n\nusing namespace std;\n\nclass MyCPP {\n  public : \n    void PrintNumber(int num1, int num2); \n};\n\nvoid MyCPP :: PrintNumber(int num1, int num2)\n{\n  cout << (num1+num2) <<endl;\n\n}\n```\n\n## wrapper.h\n\n再來就是實作wrapper層的api,這層非常的有意思,先來講一下這個header file,\n\n由於c++的compiler對於symbol有Name Mangling的行爲(也就是會改變數函式名稱)\n\n所以假如我們wrapper這層的api,要同時被C以及C++使用的話,我們必須讓g++ compiler symbol不去做name mangling.\n\n要怎麼做呢？就是透過 extern \"C\" 這個關鍵字.\n\n爲了避免gcc compiler 在include wrapper.h 出現compiler error, 我們再用cplusplus去隔開.\n;\n還有一件事情要注意壓,由於是要給C code 使用,但是C一定沒有class 這種結構,所以就會將class的poiner\n\n先暫時指向void\n\n```\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    void* api_create_class(void);\n    void api_destory_class(void*);\n    void api_print_sum(void*, int, int);\n#ifdef __cplusplus\n}\n#endif\n```\n\n## wrapper.cpp\n\n這三個wrapper api 的實作,非常容易.比較要注意的是,C++ 的形態轉換,是用 static_cast<CLASS>\n\n```\n#include \"core.cpp\"\n#include \"wrapper.h\"\n\nvoid* api_create_class(void)\n{\n  return new MyCPP();\n}\n\nvoid api_destory_class(void* thiz) \n{\n  delete static_cast<MyCPP*>(thiz);\n}\n\nvoid api_print_sum(void* thiz, int num1, int num2)\n{\n  static_cast<MyCPP*>(thiz)->PrintNumber(num1,num2);\n}\n\n```\n\n## main.c \n\n再來就是要進入測試成果的部分囉, \n\n先include wrapper.h, 然後在使用他囉!!!!\n\n```\n#include <stdio.h> \n#include \"wrapper.h\"\n\nint main(int argc, char** argv)\n{\n  printf(\"Hello, This sample code teach us how to call CPP class function from C \\r\\n\");\n  \n  printf(\" New a Class \\r\\n\");\n  void* MyClass = api_create_class();\n\n  printf(\" Print the Sum of Numbers \\r\\n\");\n  api_print_sum(MyClass, 10, 20);\n\n  printf(\" Delete the Class \\r\\n\");\n  api_destory_class(MyClass);\n\n  return 0;\n}\n```\n\n\n# How To Compiler \n\n挖勒,剛講這麼多,到底要怎麼編code呀???\n\n接下來就是要介紹如何 compiler. \n\n假如你都有照着作下來的話,你應該會有底下這些檔案. \n\n```\ncore.cpp  main.c  wrapper.cpp  wrapper.h\n```\n\n## 製作C++靜態lib \n\n```\ng++ wrapper.cpp core.cpp -c    // 你換發現多了兩個 .o 檔\nar rvs libMyCPP.a wrapper.o core.o\n```\n\n## 製作C (main) 的object code\n\n```\ngcc main.c -c      // 你會發現多了一個main.o\n```\n\n## 利用g++ 去做LINK \n\n```\ng++ main.o libMyCPP.a -o test\n```\n\n## 驗證成果 !!!\n\n```\n./test\n```\n\n```\nHello, This sample code teach us how to call the static of CPP from C \nNew a Class \nPrint the Sum of Numbers \n30\nDelete the Class\n```\n\n\n\n\n","slug":"How-to-call-C-calss-member-function-from-C","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp26k002d35ggqh0rlh2s"},{"title":"[HTTP][ASP][POST][表單] 分析網頁原始碼","date":"2015-03-28T14:56:02.000Z","toc":true,"_content":"\n# Purpose\n\n有一個好朋友，最近在研究如何自動的把股市資料抓下來, 以利後續的分析處理\n\n他問了我一個問題， 要怎麼了解底下文章, 爲什麼這樣的URL就可以抓取想要個資料\n\n[抓取鉅亨網個股歷史行情](http://ric1565.blogspot.tw/2013/12/web.html)\n\n老實說，我不是做web應用的，XDDD,當下的反應是 \"瓦阿哉\". 所以爲了要保存一些顏面.\n\n花了時間看了一下. 怎麼分析html....\n\n# Introudction\n\n他的目的是要抓取網頁中表單的資料, \n\n所以必須要知道HTTP如何處理表單的. \n\n在開始之前, 你必須要知道如何檢視html的原始碼,\n\n這部份，最容易了.\n\n先來安裝個chrome. 然後找一個有[表單的網頁](http://www.cnyes.com/twstock/ps_historyprice/1101.htm)\n\n(按右鍵) -> (檢視網頁原始碼)\n\n大功告成, Aha....\n\n# 表單\n\nhtml的標籤有許多種, 這裡的[聯結](http://w3school.com.cn/tags/tag_script.asp)作者很用心誒. \n\n但是現在我們其實只是要focus 在表單上.\n\n表單標籤的keyword 其實就是 ___form___, 所以你只需要在原始碼中查詢___form___的關鍵字， 你就會發現表單的位置.\n\n例如底下,\n\n```\n<form name=\"aspnetForm\" method=\"post\" action=\"/twstock/ps_historyprice/1101.htm\" id=\"aspnetForm\">\n<div>\n...\n<input type=\"hidden\" name=\"__VIEWSTATE\" id=\"__VIEWSTATE\"\n...\n</form>  \n```\n\n標籤大多都是成對的出現,所以你發現了___form___的開頭,就可以看到一個___/form___的結尾\n\n從上面的資訊可以看出一些東西, 組成這個表單標籤的元素, 其實有許多種, \n\n底下只是一個例子,\n\n___1. name=\"aspnetForm\"___\n\n這個就是這個表單的名字\n\n___2. method=\"post\"___\n\n當你按完___查詢___按鍵之後, 會利用post的方式將表單以及一些user自定的參數,帶給___action這個程式___, \n一般講到post的時後,都會提到get這個方法, 我大概只有一個概念, 似乎post會比get還要安全,XDD 這種粗淺的認知.\n有興趣的可以看一下,底下的差異介紹.\n\n[GET VS POST Method](http://blog.toright.com/posts/1203/%E6%B7%BA%E8%AB%87-http-method%EF%BC%9A%E8%A1%A8%E5%96%AE%E4%B8%AD%E7%9A%84-get-%E8%88%87-post-%E6%9C%89%E4%BB%80%E9%BA%BC%E5%B7%AE%E5%88%A5%EF%BC%9F.html)\n\n___3. action=\"/twstock/ps_historyprice/1101.htm\"___\n\n如同上面所說,其實1101.htm應該就是web server上某一個程式, 當我們按完___查詢___以後, 會將一些資料（例如, 開始日期與結束日期)\n送到___action___這裏. 去做相對應的處理. [例子](http://ric1565.blogspot.tw/2013/12/web.html), 其實就是將這其間內的資料從data base裏面撈出來\n在顯示給user看.\n\n# 如何用改變URL的方式, 來獲取各個表單的資訊.\n\n在開始之前,應該有人,會有一些疑問,爲什麼網址不變,但是卻可以撈到不同的股市資料, 其實就是剛剛那個post的方式, 做到的. \n\n有人會問，要怎麼知道,新的表單需要在URL上多加什麼爾外的資訊. 才能獲得呢.\n\n其實很直觀,你觀察一下網頁上的表單,會需要什麼資訊，這個例子是用, (開始日期與結束日期),你就直接在原始碼中找尋(開始日期與結束日期)\n\n多們直觀對吧 kerker\n\n```\n<form name=\"aspnetForm\" method=\"post\" action=\"/twstock/ps_historyprice/1101.htm\" id=\"aspnetForm\">\n...\n<span class=\"srchyear2\" >\n開始日期<input name=\"ctl00$ContentPlaceHolder1$startText\" type=\"text\" value=\"2015/02/28\" maxlength=\"10\" id=\"ctl00_ContentPlaceHolder1_startText\" style=\"width:72px;\" />\n結束日期<input name=\"ctl00$ContentPlaceHolder1$endText\" type=\"text\" value=\"2015/03/28\" maxlength=\"10\" id=\"ctl00_ContentPlaceHolder1_endText\" style=\"width:72px;\" />\n<input type=\"submit\" name=\"ctl00$ContentPlaceHolder1$submitBut\" value=\"查詢\" id=\"ctl00_ContentPlaceHolder1_submitBut\" class=\"butn btnga\" />\n<span style=\"float:right\">\n</span>\n</span>\n...\n</form>  \n\n```\n\n這樣就可以發現,在表單裏面，其實有一段標籤是描述（開始日期與結束日期),\n\n跟剛剛一樣，假如要知道input這個標籤屬性在幹嗎，查閱一下 [HELP-HTML-標籤](http://w3school.com.cn/tags/tag_script.asp)\n\n這邊稍爲帶一下，\n\n1. name : 代表input 的名字\n2. type : input 的屬性，text很明顯就是只文字.\n3. value : 這個input 是什麼值. 看起來就像是日期.\n\n有了以上的簡單的認知,我們就可以透過key URL 的方式，來改變我們要搜尋的股市歷史資料\n\n首先， 由於我們這個是要股市歷史資料,你觀察一下,他的歷史資料的首頁,\n\n```\nhttp://www.cnyes.com/twstock/ps_historyprice.aspx\n```\n\n聯結進去預設的各股，是臺G電2330, 假如是要查聯發科2454的話.\n\n你只要將code=2454 帶入URL中即可.像是底下.\n\n要注意一個地方，假如我需要帶參數在URL中時，你就必須多加一個\"？\"在網址的最後面. 然後緊接着參數code\n\n```\nhttp://www.cnyes.com/twstock/ps_historyprice.aspx?code=2454\n```\n\n看起來真的很容易對吧...\n\n再來就是，假如我需要知道某個區間內的歷史資料要怎麼做呢.\n\n其實很間單,就是在多加時間的參數下去,對吧. 時間參數所要用的name 其實就是網頁原始碼中的name(可以參考上一段所說)\n\n1. Name of 開始時間 : ctl00$ContentPlaceHolder1$startText\n2. Name of 結束時間 : ctl00$ContentPlaceHolder1$endText\n\n要注意兩個地方\n\n1. 等於（=）後面,就是塞值進去，這個例子就是時間.\n2. 帶入的每個參數之間都要有\"&\"將每個參數做區隔. 底下例子其實，就是三個參數.\n\n```\nhttp://www.cnyes.com/twstock/ps_historyprice.aspx?code=2454&ctl00$ContentPlaceHolder1$startText=2014/01/01&ctl00$ContentPlaceHolder1$endText=2014/01/28\n```\n\n","source":"_posts/HTTP-ASP-POST-分析網頁原始碼.md","raw":"title: \"[HTTP][ASP][POST][表單] 分析網頁原始碼\"\ndate: 2015-03-28 22:56:02\ncategories:\n- POST\ntags:\n- POST\n- HTTP\n- ASP\ntoc: true\n---\n\n# Purpose\n\n有一個好朋友，最近在研究如何自動的把股市資料抓下來, 以利後續的分析處理\n\n他問了我一個問題， 要怎麼了解底下文章, 爲什麼這樣的URL就可以抓取想要個資料\n\n[抓取鉅亨網個股歷史行情](http://ric1565.blogspot.tw/2013/12/web.html)\n\n老實說，我不是做web應用的，XDDD,當下的反應是 \"瓦阿哉\". 所以爲了要保存一些顏面.\n\n花了時間看了一下. 怎麼分析html....\n\n# Introudction\n\n他的目的是要抓取網頁中表單的資料, \n\n所以必須要知道HTTP如何處理表單的. \n\n在開始之前, 你必須要知道如何檢視html的原始碼,\n\n這部份，最容易了.\n\n先來安裝個chrome. 然後找一個有[表單的網頁](http://www.cnyes.com/twstock/ps_historyprice/1101.htm)\n\n(按右鍵) -> (檢視網頁原始碼)\n\n大功告成, Aha....\n\n# 表單\n\nhtml的標籤有許多種, 這裡的[聯結](http://w3school.com.cn/tags/tag_script.asp)作者很用心誒. \n\n但是現在我們其實只是要focus 在表單上.\n\n表單標籤的keyword 其實就是 ___form___, 所以你只需要在原始碼中查詢___form___的關鍵字， 你就會發現表單的位置.\n\n例如底下,\n\n```\n<form name=\"aspnetForm\" method=\"post\" action=\"/twstock/ps_historyprice/1101.htm\" id=\"aspnetForm\">\n<div>\n...\n<input type=\"hidden\" name=\"__VIEWSTATE\" id=\"__VIEWSTATE\"\n...\n</form>  \n```\n\n標籤大多都是成對的出現,所以你發現了___form___的開頭,就可以看到一個___/form___的結尾\n\n從上面的資訊可以看出一些東西, 組成這個表單標籤的元素, 其實有許多種, \n\n底下只是一個例子,\n\n___1. name=\"aspnetForm\"___\n\n這個就是這個表單的名字\n\n___2. method=\"post\"___\n\n當你按完___查詢___按鍵之後, 會利用post的方式將表單以及一些user自定的參數,帶給___action這個程式___, \n一般講到post的時後,都會提到get這個方法, 我大概只有一個概念, 似乎post會比get還要安全,XDD 這種粗淺的認知.\n有興趣的可以看一下,底下的差異介紹.\n\n[GET VS POST Method](http://blog.toright.com/posts/1203/%E6%B7%BA%E8%AB%87-http-method%EF%BC%9A%E8%A1%A8%E5%96%AE%E4%B8%AD%E7%9A%84-get-%E8%88%87-post-%E6%9C%89%E4%BB%80%E9%BA%BC%E5%B7%AE%E5%88%A5%EF%BC%9F.html)\n\n___3. action=\"/twstock/ps_historyprice/1101.htm\"___\n\n如同上面所說,其實1101.htm應該就是web server上某一個程式, 當我們按完___查詢___以後, 會將一些資料（例如, 開始日期與結束日期)\n送到___action___這裏. 去做相對應的處理. [例子](http://ric1565.blogspot.tw/2013/12/web.html), 其實就是將這其間內的資料從data base裏面撈出來\n在顯示給user看.\n\n# 如何用改變URL的方式, 來獲取各個表單的資訊.\n\n在開始之前,應該有人,會有一些疑問,爲什麼網址不變,但是卻可以撈到不同的股市資料, 其實就是剛剛那個post的方式, 做到的. \n\n有人會問，要怎麼知道,新的表單需要在URL上多加什麼爾外的資訊. 才能獲得呢.\n\n其實很直觀,你觀察一下網頁上的表單,會需要什麼資訊，這個例子是用, (開始日期與結束日期),你就直接在原始碼中找尋(開始日期與結束日期)\n\n多們直觀對吧 kerker\n\n```\n<form name=\"aspnetForm\" method=\"post\" action=\"/twstock/ps_historyprice/1101.htm\" id=\"aspnetForm\">\n...\n<span class=\"srchyear2\" >\n開始日期<input name=\"ctl00$ContentPlaceHolder1$startText\" type=\"text\" value=\"2015/02/28\" maxlength=\"10\" id=\"ctl00_ContentPlaceHolder1_startText\" style=\"width:72px;\" />\n結束日期<input name=\"ctl00$ContentPlaceHolder1$endText\" type=\"text\" value=\"2015/03/28\" maxlength=\"10\" id=\"ctl00_ContentPlaceHolder1_endText\" style=\"width:72px;\" />\n<input type=\"submit\" name=\"ctl00$ContentPlaceHolder1$submitBut\" value=\"查詢\" id=\"ctl00_ContentPlaceHolder1_submitBut\" class=\"butn btnga\" />\n<span style=\"float:right\">\n</span>\n</span>\n...\n</form>  \n\n```\n\n這樣就可以發現,在表單裏面，其實有一段標籤是描述（開始日期與結束日期),\n\n跟剛剛一樣，假如要知道input這個標籤屬性在幹嗎，查閱一下 [HELP-HTML-標籤](http://w3school.com.cn/tags/tag_script.asp)\n\n這邊稍爲帶一下，\n\n1. name : 代表input 的名字\n2. type : input 的屬性，text很明顯就是只文字.\n3. value : 這個input 是什麼值. 看起來就像是日期.\n\n有了以上的簡單的認知,我們就可以透過key URL 的方式，來改變我們要搜尋的股市歷史資料\n\n首先， 由於我們這個是要股市歷史資料,你觀察一下,他的歷史資料的首頁,\n\n```\nhttp://www.cnyes.com/twstock/ps_historyprice.aspx\n```\n\n聯結進去預設的各股，是臺G電2330, 假如是要查聯發科2454的話.\n\n你只要將code=2454 帶入URL中即可.像是底下.\n\n要注意一個地方，假如我需要帶參數在URL中時，你就必須多加一個\"？\"在網址的最後面. 然後緊接着參數code\n\n```\nhttp://www.cnyes.com/twstock/ps_historyprice.aspx?code=2454\n```\n\n看起來真的很容易對吧...\n\n再來就是，假如我需要知道某個區間內的歷史資料要怎麼做呢.\n\n其實很間單,就是在多加時間的參數下去,對吧. 時間參數所要用的name 其實就是網頁原始碼中的name(可以參考上一段所說)\n\n1. Name of 開始時間 : ctl00$ContentPlaceHolder1$startText\n2. Name of 結束時間 : ctl00$ContentPlaceHolder1$endText\n\n要注意兩個地方\n\n1. 等於（=）後面,就是塞值進去，這個例子就是時間.\n2. 帶入的每個參數之間都要有\"&\"將每個參數做區隔. 底下例子其實，就是三個參數.\n\n```\nhttp://www.cnyes.com/twstock/ps_historyprice.aspx?code=2454&ctl00$ContentPlaceHolder1$startText=2014/01/01&ctl00$ContentPlaceHolder1$endText=2014/01/28\n```\n\n","slug":"HTTP-ASP-POST-分析網頁原始碼","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp26s002l35gg99etej9b"},{"title":"[C][uinstd] 簡易使用 readlink ","date":"2015-03-17T16:56:50.000Z","toc":true,"_content":"\n## 目的\n\n最近遇到一個問題, 假如我希望我的程式能夠知道某個symbolic link 的指向. \n\n但是我又不希望用 fork+exec or system 的方式, 去產生另一個process 來執行\"ls -l\"\n\n直接單純的使用 ___uinstd.h___ 裏面的readlink來得到link的指向.\n\n看起來fork+exec 的比較有趣困難 XDD, 過幾天再寫一下心得...哈\n\n## Sample Code\n\n___1. 產生一個symbolic link___\n\n什麼是symbolic link呢？熟稱soft link, 有點像windows 底下的聯結, google一下巴...\n\n```\nsheldon$ ln -s ~/python link_test\n```\n\n我產生了一個link 稱作link_test, 這個link指向 ~/python\n\n___2. example code___\n\n___main.c___\n\n```\n//*****************************\n// Purpose : this is an sample code to use the api of readlink\n// Arthur : Sheldon Peng\n// Date : 2015/3/18\n//***************************\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\nvoid main(void)\n{\n  char link_path[] = \"/home/sheldon/programming/c_language/readlink/link_test\";\n  char target_path[256];\n  memset(target_path, 0, sizeof(target_path));\n\n  if ( -1 == readlink(link_path, target_path, sizeof(target_path)))\n  {\n    printf(\"Fail to read link path !!\\r\\n\");\n  }▫\n  else\n  {\n    printf(\"link path is %s \\r\\n\", target_path);\n  }\n\n}\n\n```\n","source":"_posts/C-readlink.md","raw":"title: \"[C][uinstd] 簡易使用 readlink \"\ndate: 2015-03-18 00:56:50\ncategories:\n- C\n- uinstd\ntags:\n- C\n- readlink\n- ls\ntoc: true\n---\n\n## 目的\n\n最近遇到一個問題, 假如我希望我的程式能夠知道某個symbolic link 的指向. \n\n但是我又不希望用 fork+exec or system 的方式, 去產生另一個process 來執行\"ls -l\"\n\n直接單純的使用 ___uinstd.h___ 裏面的readlink來得到link的指向.\n\n看起來fork+exec 的比較有趣困難 XDD, 過幾天再寫一下心得...哈\n\n## Sample Code\n\n___1. 產生一個symbolic link___\n\n什麼是symbolic link呢？熟稱soft link, 有點像windows 底下的聯結, google一下巴...\n\n```\nsheldon$ ln -s ~/python link_test\n```\n\n我產生了一個link 稱作link_test, 這個link指向 ~/python\n\n___2. example code___\n\n___main.c___\n\n```\n//*****************************\n// Purpose : this is an sample code to use the api of readlink\n// Arthur : Sheldon Peng\n// Date : 2015/3/18\n//***************************\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\nvoid main(void)\n{\n  char link_path[] = \"/home/sheldon/programming/c_language/readlink/link_test\";\n  char target_path[256];\n  memset(target_path, 0, sizeof(target_path));\n\n  if ( -1 == readlink(link_path, target_path, sizeof(target_path)))\n  {\n    printf(\"Fail to read link path !!\\r\\n\");\n  }▫\n  else\n  {\n    printf(\"link path is %s \\r\\n\", target_path);\n  }\n\n}\n\n```\n","slug":"C-readlink","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp26y002u35gg7cd8tfth"},{"title":"[C][Mutex][Pthread][Interface] A sample code for pthread_mutex interface","date":"2015-04-03T16:04:26.000Z","toc":true,"_content":"\n# Purpose\n\n今天閱讀到一個章節，是在說明同步的，thread之間的同步一般都會提到mutex,\n\n讓不同thread之間能夠共用share資源,但是又不會干擾對方的state, 就非常重要了. \n\n其中有個地方提到了，interface 的概念, 假如我的code是想要跑在各種平臺上面的話，我就應該將程式架構分成AP層, interface 層（API）, \n\ndriver 層(偏硬體控制HW, 我們這邊就暫時不考慮它，embedded system 就很重要了) .\n\n這邊的API層，提到了用大量的callback function,來達到跨平臺的需求,交由上層AP來決定,要運行在什麼平臺上.\n\n底下的sample code, 是用pthread_mutex 來說明這個概念.\n\n# The Concept of Sample Code\n\n假如我們需要把mutex 這種東西實作成一個interface,要如何去做,又能滿足各種平臺.\n\n___1. 抽象話___\n\n   第一個要做的是讓mutex 變得抽象話, 實作的部分，都透過用calback的方式讓AP層來實作.\n   這樣聽起來有點像是在C用struct 取代C++的class XDD... \n   可參考 mutex_interface.h \n```\nstruct _Locker \n{\n  LockerLockFunc lock;\n  LockerUnLockFunc unlock;\n  LockerDestoryLockFunc destory;\n  char lock_info[0];\n};\n```\n   這邊定了三個function pointer, 還有一個lock_info 來定義我們這個lock的特性.\n   char lock_info[0], 這個宣告其實是一個技巧, char lock_info[0]其實並沒有佔任何空間,\n   假如你的私有資料長度是可變的,你就可以這樣宣告.\n   \n   後面在create lock 的時候,會有提到如何做這件事情,\n\n___2. Create_Lock___\n\n   爲什麼interface 沒有開出Create_Lock 的API給別任用呢, 書中提到, 這是因爲當你再做抽象話的描述時，你無法用\n   抽象畫來產生一個真實的實體出來，這句話我到現在還沒體會XDD.\n\n___3. Callback fucntion的引數都含有struct Locker___\n\n   這個就是抽象話的好處,交由上層來決定我的實作方式，假如你是要用linux 的pthread_mutex 來實作的話. \n   請把這個東西的function pointer交給interface. \n   你看看mutex_interface.c 這個檔案,看官,是不是，多麼的清楚間單.\n\n# Sample Code\n\n___1.main.c___\n\n```\n#include <pthread.h>\n#include \"mutex_interface.h\"\n\nRet PthreadLock(Locker* thiz);\nRet PthreadUnLock(Locker* thiz);\nRet PthreadDestory(Locker* thiz);\n\n\ntypedef struct _pthread_info\n{\n  pthread_mutex_t mutex_id;\n} pthread_info;\n\nRet PthreadLock(Locker* thiz)\n{\n  check_ptr(thiz, Ret_Fail);\n\n  pthread_info* pp_info = (pthread_info*)thiz->lock_info;\n  if ( 0 == pthread_mutex_lock(&pp_info->mutex_id))\n  {\n    return Ret_Success;\n  }\n  else\n  {\n    SR_DBG(\"WTF!!!  ERROR !!!\\r\\n\");\n    return Ret_Fail;\n  }\n\n}\n\nRet PthreadUnLock(Locker* thiz)\n{\n  check_ptr(thiz, Ret_Fail);\n  \n  pthread_info* pp_info = (pthread_info*)thiz->lock_info;\n  if ( 0 == pthread_mutex_unlock(&pp_info->mutex_id))\n  {\n    return Ret_Success;\n  }\n  else\n  {\n    SR_DBG(\"WTF!!! ERROR !!!\\r\\n\");\n    return Ret_Fail;\n  }\n}\n\nRet PthreadDestory(Locker* thiz)\n{\n  check_ptr(thiz, Ret_Fail);\n\n  pthread_info* pp_info = (pthread_info*)thiz->lock_info;\n  \n  if ( 0 != pthread_mutex_destroy(&pp_info->mutex_id))\n  {\n    return Ret_Fail;\n  }\n  SR_DBG(\"FREE the mutex \\n\");\n  free(thiz);\n  return Ret_Success;\n}\n\nLocker* create_locker(void)\n{\n  SR_DBG(\"Start \\n\\r\");\n  // Allocate the memory for locker\n  Locker* locker_thiz = malloc(sizeof(Locker) + sizeof(pthread_info));\n  pthread_info* pp_info = (pthread_info*)locker_thiz->lock_info;\n\n  if (NULL != locker_thiz)\n  {\n    // Init the callback function in class.\n    locker_thiz->lock = PthreadLock;\n    locker_thiz->unlock = PthreadUnLock;\n    locker_thiz->destory = PthreadDestory;\n    pthread_mutex_init(&(pp_info->mutex_id),NULL);\n    return locker_thiz;\n  }\n  return NULL;\n}\n\n\nvoid main(void)\n{\n  Locker* myLocker ; \n  myLocker = create_locker();\n  \n  myLocker->destory(myLocker);\n}\n\n\n```\n   \n___2.mutex_interface.c___\n\n```\n#include \"mutex_interface.h\"\n\nRet locker_lock(Locker* thiz)\n{\n  check_ptr(thiz,Ret_Fail);\n\n  return thiz->lock(thiz);\n}\n\nRet locker_unlock(Locker* thiz)\n{\n  check_ptr(thiz,Ret_Fail);\n\n  return thiz->unlock(thiz);\n}\n\nRet locker_destory(Locker* thiz)\n{\n  check_ptr(thiz,Ret_Fail);\n\n  return thiz->destory(thiz); \n}\n\n```\n\n___3.mutex_interface.h___\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct _Locker;\ntypedef struct _Locker Locker;\n\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None\n}Ret;\n\ntypedef Ret (*LockerLockFunc)(Locker* thiz);\ntypedef Ret (*LockerUnLockFunc)(Locker* thiz);\ntypedef Ret (*LockerDestoryLockFunc)(Locker* thiz);\n\nstruct _Locker \n{\n  LockerLockFunc lock;\n  LockerUnLockFunc unlock;\n  LockerDestoryLockFunc destory;\n  char lock_info[0];\n};\n\n\nRet locker_lock(Locker* thiz);\nRet locker_unlock(Locker* thiz);\nRet locker_destory(Locker* thiz);\n\n\n#define check_ptr(ptr, var)  if(ptr==NULL)    \\\n                              { printf(\" [\"#ptr\"] pointer is NULL\\r\\n\");  \\\n                               return var; }  \\\n\n#define SR_DBG(fmt, arg...) printf(\"Sheldon Debug:[%s][%d]\"fmt, __FUNCTION__, __LINE__, ##arg)\n\n```\n\n# How to compiler \n\n```\ngcc -g main.c mutex_interface.c -lpthread -o main\n```\n\n# [GDB練習] 覺得有趣的事情,\n\n不知道各位有沒有注意到底下這兩行程式.\n\n```\n  // Allocate the memory for locker\n  Locker* locker_thiz = malloc(sizeof(Locker) + sizeof(pthread_info));\n  pthread_info* pp_info = (pthread_info*)locker_thiz->lock_info;\n```\n這個地方就是剛剛提到的,若是一個可變的資料的話，要怎麼做呢.\n分配locker_thiz指向的實體記憶體的時候，要多分配一塊 sizeof(pthread_info)，這個就是user自定的. \n看起來是不是很方便呢.XDDD\n\n不知道大家有沒有宜個疑問，爲什麼locker_thiz->lock_info，是代表pp_info指向的位置呢.\n\n底下是用gdb 觀察的一個結果. \n\n___1. 啓動GDB___\n\ngdb main\n\n___2. break 在 76行___\n\n(gdb) b 76\n\n___3. 執行程式___\n\n(gdb) r\n\n___4. 觀察變數的值___\n\n```\n(gdb) r\nStarting program: /home/sheldon/programming/c_language/mutex_interface/main \n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\nSheldon Debug:[create_locker][64]Start \n\nBreakpoint 1, create_locker () at main.c:76\n76      return locker_thiz;\n(gdb) p locker_thiz->lock_info\n$1 = 0x603028 \"\"\n(gdb) p &locker_thiz->lock_info\n$2 = (char (*)[]) 0x603028\n(gdb) p *(locker_thiz->lock_info)\n$3 = 0 '\\000'\n(gdb) p pp_info->mutex_id \n$4 = {__data = {__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 0, __spins = 0, __elision = 0, __list = {__prev = 0x0, __next = 0x0}}, \n  __size = '\\000' <repeats 39 times>, __align = 0}\n(gdb) p &pp_info->mutex_id \n$5 = (pthread_mutex_t *) 0x603028\n```\n\nlocker_thiz->lock_info 其實就是會等於 locker_thiz+sizeof(Locker)\n\n","source":"_posts/C-Mutex-Pthread-Interface-A-sample-code-for-pthread-mutex-interface.md","raw":"title: \"[C][Mutex][Pthread][Interface] A sample code for pthread_mutex interface\"\ndate: 2015-04-04 00:04:26\ncategories:\n- Pthread_Mutex\ntags:\n- C\n- Pthread\n- Mutex\n- Interface\ntoc: true\n---\n\n# Purpose\n\n今天閱讀到一個章節，是在說明同步的，thread之間的同步一般都會提到mutex,\n\n讓不同thread之間能夠共用share資源,但是又不會干擾對方的state, 就非常重要了. \n\n其中有個地方提到了，interface 的概念, 假如我的code是想要跑在各種平臺上面的話，我就應該將程式架構分成AP層, interface 層（API）, \n\ndriver 層(偏硬體控制HW, 我們這邊就暫時不考慮它，embedded system 就很重要了) .\n\n這邊的API層，提到了用大量的callback function,來達到跨平臺的需求,交由上層AP來決定,要運行在什麼平臺上.\n\n底下的sample code, 是用pthread_mutex 來說明這個概念.\n\n# The Concept of Sample Code\n\n假如我們需要把mutex 這種東西實作成一個interface,要如何去做,又能滿足各種平臺.\n\n___1. 抽象話___\n\n   第一個要做的是讓mutex 變得抽象話, 實作的部分，都透過用calback的方式讓AP層來實作.\n   這樣聽起來有點像是在C用struct 取代C++的class XDD... \n   可參考 mutex_interface.h \n```\nstruct _Locker \n{\n  LockerLockFunc lock;\n  LockerUnLockFunc unlock;\n  LockerDestoryLockFunc destory;\n  char lock_info[0];\n};\n```\n   這邊定了三個function pointer, 還有一個lock_info 來定義我們這個lock的特性.\n   char lock_info[0], 這個宣告其實是一個技巧, char lock_info[0]其實並沒有佔任何空間,\n   假如你的私有資料長度是可變的,你就可以這樣宣告.\n   \n   後面在create lock 的時候,會有提到如何做這件事情,\n\n___2. Create_Lock___\n\n   爲什麼interface 沒有開出Create_Lock 的API給別任用呢, 書中提到, 這是因爲當你再做抽象話的描述時，你無法用\n   抽象畫來產生一個真實的實體出來，這句話我到現在還沒體會XDD.\n\n___3. Callback fucntion的引數都含有struct Locker___\n\n   這個就是抽象話的好處,交由上層來決定我的實作方式，假如你是要用linux 的pthread_mutex 來實作的話. \n   請把這個東西的function pointer交給interface. \n   你看看mutex_interface.c 這個檔案,看官,是不是，多麼的清楚間單.\n\n# Sample Code\n\n___1.main.c___\n\n```\n#include <pthread.h>\n#include \"mutex_interface.h\"\n\nRet PthreadLock(Locker* thiz);\nRet PthreadUnLock(Locker* thiz);\nRet PthreadDestory(Locker* thiz);\n\n\ntypedef struct _pthread_info\n{\n  pthread_mutex_t mutex_id;\n} pthread_info;\n\nRet PthreadLock(Locker* thiz)\n{\n  check_ptr(thiz, Ret_Fail);\n\n  pthread_info* pp_info = (pthread_info*)thiz->lock_info;\n  if ( 0 == pthread_mutex_lock(&pp_info->mutex_id))\n  {\n    return Ret_Success;\n  }\n  else\n  {\n    SR_DBG(\"WTF!!!  ERROR !!!\\r\\n\");\n    return Ret_Fail;\n  }\n\n}\n\nRet PthreadUnLock(Locker* thiz)\n{\n  check_ptr(thiz, Ret_Fail);\n  \n  pthread_info* pp_info = (pthread_info*)thiz->lock_info;\n  if ( 0 == pthread_mutex_unlock(&pp_info->mutex_id))\n  {\n    return Ret_Success;\n  }\n  else\n  {\n    SR_DBG(\"WTF!!! ERROR !!!\\r\\n\");\n    return Ret_Fail;\n  }\n}\n\nRet PthreadDestory(Locker* thiz)\n{\n  check_ptr(thiz, Ret_Fail);\n\n  pthread_info* pp_info = (pthread_info*)thiz->lock_info;\n  \n  if ( 0 != pthread_mutex_destroy(&pp_info->mutex_id))\n  {\n    return Ret_Fail;\n  }\n  SR_DBG(\"FREE the mutex \\n\");\n  free(thiz);\n  return Ret_Success;\n}\n\nLocker* create_locker(void)\n{\n  SR_DBG(\"Start \\n\\r\");\n  // Allocate the memory for locker\n  Locker* locker_thiz = malloc(sizeof(Locker) + sizeof(pthread_info));\n  pthread_info* pp_info = (pthread_info*)locker_thiz->lock_info;\n\n  if (NULL != locker_thiz)\n  {\n    // Init the callback function in class.\n    locker_thiz->lock = PthreadLock;\n    locker_thiz->unlock = PthreadUnLock;\n    locker_thiz->destory = PthreadDestory;\n    pthread_mutex_init(&(pp_info->mutex_id),NULL);\n    return locker_thiz;\n  }\n  return NULL;\n}\n\n\nvoid main(void)\n{\n  Locker* myLocker ; \n  myLocker = create_locker();\n  \n  myLocker->destory(myLocker);\n}\n\n\n```\n   \n___2.mutex_interface.c___\n\n```\n#include \"mutex_interface.h\"\n\nRet locker_lock(Locker* thiz)\n{\n  check_ptr(thiz,Ret_Fail);\n\n  return thiz->lock(thiz);\n}\n\nRet locker_unlock(Locker* thiz)\n{\n  check_ptr(thiz,Ret_Fail);\n\n  return thiz->unlock(thiz);\n}\n\nRet locker_destory(Locker* thiz)\n{\n  check_ptr(thiz,Ret_Fail);\n\n  return thiz->destory(thiz); \n}\n\n```\n\n___3.mutex_interface.h___\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct _Locker;\ntypedef struct _Locker Locker;\n\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None\n}Ret;\n\ntypedef Ret (*LockerLockFunc)(Locker* thiz);\ntypedef Ret (*LockerUnLockFunc)(Locker* thiz);\ntypedef Ret (*LockerDestoryLockFunc)(Locker* thiz);\n\nstruct _Locker \n{\n  LockerLockFunc lock;\n  LockerUnLockFunc unlock;\n  LockerDestoryLockFunc destory;\n  char lock_info[0];\n};\n\n\nRet locker_lock(Locker* thiz);\nRet locker_unlock(Locker* thiz);\nRet locker_destory(Locker* thiz);\n\n\n#define check_ptr(ptr, var)  if(ptr==NULL)    \\\n                              { printf(\" [\"#ptr\"] pointer is NULL\\r\\n\");  \\\n                               return var; }  \\\n\n#define SR_DBG(fmt, arg...) printf(\"Sheldon Debug:[%s][%d]\"fmt, __FUNCTION__, __LINE__, ##arg)\n\n```\n\n# How to compiler \n\n```\ngcc -g main.c mutex_interface.c -lpthread -o main\n```\n\n# [GDB練習] 覺得有趣的事情,\n\n不知道各位有沒有注意到底下這兩行程式.\n\n```\n  // Allocate the memory for locker\n  Locker* locker_thiz = malloc(sizeof(Locker) + sizeof(pthread_info));\n  pthread_info* pp_info = (pthread_info*)locker_thiz->lock_info;\n```\n這個地方就是剛剛提到的,若是一個可變的資料的話，要怎麼做呢.\n分配locker_thiz指向的實體記憶體的時候，要多分配一塊 sizeof(pthread_info)，這個就是user自定的. \n看起來是不是很方便呢.XDDD\n\n不知道大家有沒有宜個疑問，爲什麼locker_thiz->lock_info，是代表pp_info指向的位置呢.\n\n底下是用gdb 觀察的一個結果. \n\n___1. 啓動GDB___\n\ngdb main\n\n___2. break 在 76行___\n\n(gdb) b 76\n\n___3. 執行程式___\n\n(gdb) r\n\n___4. 觀察變數的值___\n\n```\n(gdb) r\nStarting program: /home/sheldon/programming/c_language/mutex_interface/main \n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\nSheldon Debug:[create_locker][64]Start \n\nBreakpoint 1, create_locker () at main.c:76\n76      return locker_thiz;\n(gdb) p locker_thiz->lock_info\n$1 = 0x603028 \"\"\n(gdb) p &locker_thiz->lock_info\n$2 = (char (*)[]) 0x603028\n(gdb) p *(locker_thiz->lock_info)\n$3 = 0 '\\000'\n(gdb) p pp_info->mutex_id \n$4 = {__data = {__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 0, __spins = 0, __elision = 0, __list = {__prev = 0x0, __next = 0x0}}, \n  __size = '\\000' <repeats 39 times>, __align = 0}\n(gdb) p &pp_info->mutex_id \n$5 = (pthread_mutex_t *) 0x603028\n```\n\nlocker_thiz->lock_info 其實就是會等於 locker_thiz+sizeof(Locker)\n\n","slug":"C-Mutex-Pthread-Interface-A-sample-code-for-pthread-mutex-interface","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp272003335ggfaxzzvcv"},{"title":"[C][Multi-Thread] How to use pthread_create and pthread_join to operate multi-thread","date":"2015-03-23T13:22:47.000Z","toc":true,"_content":"\n# Purpose\n\n今天在練習如何使用pthread_create和pthread_join來練習multi-thread的操作.\n\nmulti-thread 的code的好處, 在於你假如用multi-process 的話, CPU會在去多做context-switch,\n\n整體的效能下降. 但是由於每個thread都共用相同的memory 大小區塊, 所以有可能造成\n\n每個thread access 到其他人thread要用的資料, 底下有兩個sample code, 第一個sample code,\n\n就出現這樣的錯誤.\n\n# Compiler\n\n```\ngcc main.c -lpthread -o main\n```\n\n由於pthread是在libpthread.so的lib裏面, 所以我們在compiler 的時候, 必須將pthread lib include 進去. \n\n.c 檔裏面, 也記得要include pthread.h.\n\n# Sample Code 1 \n\n你可以從底下的結果看出一個奇特的現象,\n\n我產生了10個thread, 但是印出thread id 的時候， thread id =5, 卻印了4次. \n\n這代表, 我create thread 的時侯, 帶下去的thread id (i), 被其他thread access到了. 造成了這個問題, \n\n修這個bug的最簡單方法, 可以參考Sample Code 2.\n\n關於 pthread_join 的使用, 也很單純. \n\n他就wait 那裡,等待他要wait 的pthread id 被終止, 假如沒有終止的話, 那就GG了, 系統就會hang在那裏. \n\n\n___main.c___\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#define THREAD_NUM 10\n#define SR_DBG(fmt,arg...) printf(\"[%s][%d] \"fmt, __FUNCTION__,__LINE__, ##arg)\n\nvoid* thread_routine(void* argv)\n{\n  int my_id = *((int*)argv);\n  SR_DBG(\"hello, i'm new thread, my name is id[%d] \\r\\n\",my_id);\n  return;\n}\n\nint create_multi_thread_test(void)\n{\n  int i;\n\n  pthread_t thread_id_array[THREAD_NUM];\n \n  for (i=0; i<THREAD_NUM; i++)\n  {\n    if (0 != pthread_create(&thread_id_array[i], NULL, thread_routine, &i))\n    {\n      SR_DBG(\"OMG, create thread FAILLL!!! \\r\\n\");\n    }\n  }\n\n  for (i=0; i<THREAD_NUM; i++)\n  {\n    SR_DBG(\"Wait for termination of thread id [%d] \\r\\n\", i);\n    if (0 != pthread_join(thread_id_array[i], NULL))\n    {\n      SR_DBG(\"OMG, Mother thread cannot wait for thread id [%d]\\r\\n\", i);\n    }\n  }\n  \n\n  return 0;\n}\n\nvoid main(void)\n{\n  SR_DBG(\"This is multi-thread test code \\r\\n\");\n  \n  if (-1 == create_multi_thread_test())\n  {\n    SR_DBG(\"the multi thread test is FAILLLLL!!! \\r\\n\");\n  }\n\n}\n\n```\n\n___Result1___\n\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/pthread_v1.png %}\n\n# Sample Code 2 #\n\n這個smaple code, 就是針對上面去做一些改良, 多用一個 array 來存要帶進去thread_routine 裏面的引數\n\n避免被其他thread access 倒.但是這一定不是最佳的方法... \n\n___main_v2.c___\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#define THREAD_NUM 10\n#define SR_DBG(fmt,arg...) printf(\"[%s][%d] \"fmt, __FUNCTION__,__LINE__, ##arg)\n\nvoid* thread_routine(void* argv)\n{\n  int my_id = *((int*)argv);\n  SR_DBG(\"hello, i'm new thread, my name is id[%d] \\r\\n\",my_id);\n  return;\n}\n\nint create_multi_thread_test(void)\n{\n  int i;\n\n  pthread_t thread_id_array[THREAD_NUM];\n  int thread_i[THREAD_NUM];\n \n  for (i=0; i<THREAD_NUM; i++)\n  {\n    thread_i[i] = i;\n    if (0 != pthread_create(&thread_id_array[i], NULL, thread_routine, &thread_i[i]))\n    {\n      SR_DBG(\"OMG, create thread FAILLL!!! \\r\\n\");\n    }\n  }\n\n  for (i=0; i<THREAD_NUM; i++)\n  {\n    SR_DBG(\"Wait for termination of thread id [%d] \\r\\n\", i);\n    if (0 != pthread_join(thread_id_array[i], NULL))\n    {\n      SR_DBG(\"OMG, Mother thread cannot wait for thread id [%d]\\r\\n\", i);\n    }\n  }\n  \n\n  return 0;\n}\n\nvoid main(void)\n{\n  SR_DBG(\"This is multi-thread test code \\r\\n\");\n  \n  if (-1 == create_multi_thread_test())\n  {\n    SR_DBG(\"the multi thread test is FAILLLLL!!! \\r\\n\");\n  }\n\n}\n```\n\n___Result2___\n\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/pthread_v2.png %}\n","source":"_posts/C-Multi-Thread-How-to-use-pthread-create-and-pthread-join-to-operate-multi-thread.md","raw":"title: \"[C][Multi-Thread] How to use pthread_create and pthread_join to operate multi-thread\"\ndate: 2015-03-23 21:22:47\ncategories:\n- Multi-Thread\ntags:\n- C\n- pthread_create\n- pthread_join\n- multi-thread\ntoc: true\n---\n\n# Purpose\n\n今天在練習如何使用pthread_create和pthread_join來練習multi-thread的操作.\n\nmulti-thread 的code的好處, 在於你假如用multi-process 的話, CPU會在去多做context-switch,\n\n整體的效能下降. 但是由於每個thread都共用相同的memory 大小區塊, 所以有可能造成\n\n每個thread access 到其他人thread要用的資料, 底下有兩個sample code, 第一個sample code,\n\n就出現這樣的錯誤.\n\n# Compiler\n\n```\ngcc main.c -lpthread -o main\n```\n\n由於pthread是在libpthread.so的lib裏面, 所以我們在compiler 的時候, 必須將pthread lib include 進去. \n\n.c 檔裏面, 也記得要include pthread.h.\n\n# Sample Code 1 \n\n你可以從底下的結果看出一個奇特的現象,\n\n我產生了10個thread, 但是印出thread id 的時候， thread id =5, 卻印了4次. \n\n這代表, 我create thread 的時侯, 帶下去的thread id (i), 被其他thread access到了. 造成了這個問題, \n\n修這個bug的最簡單方法, 可以參考Sample Code 2.\n\n關於 pthread_join 的使用, 也很單純. \n\n他就wait 那裡,等待他要wait 的pthread id 被終止, 假如沒有終止的話, 那就GG了, 系統就會hang在那裏. \n\n\n___main.c___\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#define THREAD_NUM 10\n#define SR_DBG(fmt,arg...) printf(\"[%s][%d] \"fmt, __FUNCTION__,__LINE__, ##arg)\n\nvoid* thread_routine(void* argv)\n{\n  int my_id = *((int*)argv);\n  SR_DBG(\"hello, i'm new thread, my name is id[%d] \\r\\n\",my_id);\n  return;\n}\n\nint create_multi_thread_test(void)\n{\n  int i;\n\n  pthread_t thread_id_array[THREAD_NUM];\n \n  for (i=0; i<THREAD_NUM; i++)\n  {\n    if (0 != pthread_create(&thread_id_array[i], NULL, thread_routine, &i))\n    {\n      SR_DBG(\"OMG, create thread FAILLL!!! \\r\\n\");\n    }\n  }\n\n  for (i=0; i<THREAD_NUM; i++)\n  {\n    SR_DBG(\"Wait for termination of thread id [%d] \\r\\n\", i);\n    if (0 != pthread_join(thread_id_array[i], NULL))\n    {\n      SR_DBG(\"OMG, Mother thread cannot wait for thread id [%d]\\r\\n\", i);\n    }\n  }\n  \n\n  return 0;\n}\n\nvoid main(void)\n{\n  SR_DBG(\"This is multi-thread test code \\r\\n\");\n  \n  if (-1 == create_multi_thread_test())\n  {\n    SR_DBG(\"the multi thread test is FAILLLLL!!! \\r\\n\");\n  }\n\n}\n\n```\n\n___Result1___\n\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/pthread_v1.png %}\n\n# Sample Code 2 #\n\n這個smaple code, 就是針對上面去做一些改良, 多用一個 array 來存要帶進去thread_routine 裏面的引數\n\n避免被其他thread access 倒.但是這一定不是最佳的方法... \n\n___main_v2.c___\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#define THREAD_NUM 10\n#define SR_DBG(fmt,arg...) printf(\"[%s][%d] \"fmt, __FUNCTION__,__LINE__, ##arg)\n\nvoid* thread_routine(void* argv)\n{\n  int my_id = *((int*)argv);\n  SR_DBG(\"hello, i'm new thread, my name is id[%d] \\r\\n\",my_id);\n  return;\n}\n\nint create_multi_thread_test(void)\n{\n  int i;\n\n  pthread_t thread_id_array[THREAD_NUM];\n  int thread_i[THREAD_NUM];\n \n  for (i=0; i<THREAD_NUM; i++)\n  {\n    thread_i[i] = i;\n    if (0 != pthread_create(&thread_id_array[i], NULL, thread_routine, &thread_i[i]))\n    {\n      SR_DBG(\"OMG, create thread FAILLL!!! \\r\\n\");\n    }\n  }\n\n  for (i=0; i<THREAD_NUM; i++)\n  {\n    SR_DBG(\"Wait for termination of thread id [%d] \\r\\n\", i);\n    if (0 != pthread_join(thread_id_array[i], NULL))\n    {\n      SR_DBG(\"OMG, Mother thread cannot wait for thread id [%d]\\r\\n\", i);\n    }\n  }\n  \n\n  return 0;\n}\n\nvoid main(void)\n{\n  SR_DBG(\"This is multi-thread test code \\r\\n\");\n  \n  if (-1 == create_multi_thread_test())\n  {\n    SR_DBG(\"the multi thread test is FAILLLLL!!! \\r\\n\");\n  }\n\n}\n```\n\n___Result2___\n\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/pthread_v2.png %}\n","slug":"C-Multi-Thread-How-to-use-pthread-create-and-pthread-join-to-operate-multi-thread","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp27c003c35gguvotozg2"},{"title":"[C][Dynamic Array] Exercise to operate the dyanmic array ","date":"2015-03-21T07:28:52.000Z","toc":true,"_content":"\n\n## 目的\n\n很久之前買了一本書, 有關於系統程式師的養成計劃, 但是一直沒有很他認真的實行...\n\n哈, 最近又開始了新生活運動, 打算每個禮拜花一點時間upgrade一下技能, 已經打算\n\n靠着寫程式過我下半生了, HA....今天看到了一個有趣的議題, 資料結構裏面有 雙向鏈結以及dynamic array 這種東西, \n\n我沒學過自料結構,但是雙向鏈結在interview的時候, 常會被問, 但是 dynamic array 這個我還是第一次各聽到\n\n（是不是很虛， 沒辦法, 小弟不是資工的...走一步算一步吧!!） \n\n今天就花了時間, 學習了一下要如何操作 dynamic array... \n\n## 結論\n\n先來下個結論, 一開始我以爲dynamic array 是指array 可以動態的改變, 將底下的array, 大小改變...\n\n```\nint static_array[10];\n```\n\n但是我做了實驗, 發現是不行的(有錯的話, 請糾正我吧！！) \n\n基本上就是透過 malloc 要一塊heap 的記憶體,然後再用 realloc 的方式, 去放大縮小你的heap空間.\n\n底下的sample 主要做了底下這些事情. 一行一行做註解， 會殺了我...所以我列出concept, 讓入門人有個概念\n\n\n1. 我用一個structure -->  DArray, 來當作動態的array. 主要就是操作裏面的data\n2. 這個sample code有讓array長大的api, 以及讓array所小的api, 可以參考.h 檔去追\n3. DArray 裏面有兩個siz,\n      int array_size;           --> data array 的大小\n      int allocated_array_size; --> 我們用 malloc 實際跟系統要的memory size\n4. 爲什麼要分兩個size呢, 原因是因爲跟記憶體有關, 你應該不會希望, 當我們要新增刪除一個member 就要\n   call一次 realloc 吧...這樣會造成你的memory不連續. 就失去了dynamic array 的好處之一...\n\n## Sample Code\n\n___main.c___\n\n```\n/*******************************\n *  Purpose : Exercise to operate the dynamic array\n *  Arthur  : Sheldon Peng\n *  Date    : 2015/3/21 \n * */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"main.h\"\n\n#define SR_DBG(fmt, vargs...) printf(\"[%s][%d]\" fmt, __FUNCTION__, __LINE__, ##vargs)\n\n#define CHECK_NULL(PTR)  if(!PTR)    \\\n                          {printf(\"ERROR!! the pointer is NULL \\r\\n\");} \n\n\nstatic RET DArray_shrink(DArray* thiz, int shrink_size)\n{\n  CHECK_NULL(thiz);\n  void* shrink_data = realloc((void*)thiz->data, shrink_size*sizeof(char));\n  \n  if ( NULL!=shrink_data)\n  {\n    thiz->data = (char*)shrink_data; \n    thiz->allocated_array_size = shrink_size; \n    SR_DBG(\" SHRINK size to %d \\r\\n\", shrink_size);\n  }\n  else\n  {\n    SR_DBG(\"FAIL to realloc array \\r\\n\");\n    return RET_FAIL; \n  }\n\n  return RET_SUCCESS;\n\n}\n\nRET DArray_delete(DArray* thiz, int index)\n{\n  CHECK_NULL(thiz);\n  \n  if (index > thiz->array_size)\n  {\n    SR_DBG(\" ERROR to delete the dynamic array member beacuse the index is not belong into dynamic array \\r\\n\");\n    return RET_FAIL;\n  }\n\n  // remove the member from the dynamic array\n  int i;\n  for (i=index;i<(thiz->array_size-1);i++)\n  {\n    thiz->data[i] = thiz->data[i+1];\n  }\n  thiz->array_size = thiz->array_size-1;\n  \n  // Shrink the dynamic array if the pool size is enough to use .\n  int shrink_size = thiz->array_size + (thiz->array_size>>1);\n\n  if (shrink_size < thiz->allocated_array_size)\n  {\n     if ( RET_FAIL == DArray_shrink(thiz, shrink_size) )\n     {\n       SR_DBG(\"FAILLL to shrink the dynamic array \\r\\n\");\n     }\n  }\n}\n\nstatic RET DArray_enlarge(DArray* thiz, int enlarge_size)\n{\n  CHECK_NULL(thiz);\n  void* enlarge_data = realloc((void*)thiz->data, enlarge_size*sizeof(char));\n\n  if ( NULL!=enlarge_data )\n  {\n    thiz->data = (char*)enlarge_data;\n    thiz->allocated_array_size = enlarge_size;\n    SR_DBG(\" ENLARGE size to %d \\r\\n\", enlarge_size);\n  }\n  else\n  {\n    SR_DBG(\"FAIL to realloc array \\r\\n\");\n    return RET_FAIL; \n  }\n\n  return RET_SUCCESS;\n}\n\nRET DArray_insert(DArray* thiz, int index, char insert_data)\n{\n  CHECK_NULL(thiz);\n\n  if (index > thiz->array_size)\n  {\n    SR_DBG(\"Your index is wrong, because the index is not wihin the array \\r\\n\");\n    return RET_FAIL;\n  }\n\n  if (thiz->allocated_array_size < thiz->array_size+1)\n  {\n    SR_DBG(\"Because the space is not enough, so we need to enlarge the space for dynamic array \\r\\n\");\n    int enlarge_size = (thiz->array_size>>1) + thiz->array_size;\n    if (RET_FAIL == DArray_enlarge(thiz, enlarge_size ))\n    {\n      SR_DBG(\"FAILLL to enlarge the space of dynamic array \\r\\n\");\n      return RET_FAIL;\n    }\n  }\n  \n  int i;\n  for ( i=thiz->array_size; i>index; i--)\n  {\n    thiz->data[i] = thiz->data[i-1];\n  }\n  \n  thiz->data[index] = insert_data;\n  thiz->array_size = thiz->array_size+1;\n}\n\nvoid Display_DArray(DArray* DArray_ptr)\n{\n  int i;\n  int size = DArray_ptr->array_size;\n\n  SR_DBG(\"My Dynamic Array is : \\r\\n\");\n  SR_DBG(\"size is %d \\r\\n\", size);\n  SR_DBG(\"allocated size is %d \\r\\n\", DArray_ptr->allocated_array_size);\n\n  for ( i=0; i<size; i++)\n  {\n      printf(\"%d, \", DArray_ptr->data[i]);\n  }\n  printf(\"\\r\\n\");\n}\n\nvoid main(void)\n{\n  // Init my dynamic array\n  DArray myDArray;\n  myDArray.array_size = MINIMUN_ARRAY_SIZE;\n  myDArray.allocated_array_size = MINIMUN_ARRAY_SIZE+ (MINIMUN_ARRAY_SIZE>>1); \n  \n  //char InitArray[myDArray.array_size];\n  myDArray.data = (char*)malloc(sizeof(char)*myDArray.array_size);\n  memset((void*)myDArray.data, 0x0, (myDArray.array_size)*sizeof(char));\n\n  // Display all dynamic array members. \n  Display_DArray(&myDArray);\n\n  // test\n  SR_DBG(\"======== TEST for ENLARGing D_ARRAY \\r\\n\");\n  int i;\n  for (i=0;i<10;i++)\n  {\n    DArray_insert(&myDArray, 0, i);\n  }\n\n  for (i=0;i<10;i++)\n  {\n    DArray_insert(&myDArray, 5, i);\n  }\n  Display_DArray(&myDArray);\n  SR_DBG(\"======== TEST for SHRINking D_ARRAY \\r\\n\");\n  DArray_delete(&myDArray, 1);\n  DArray_delete(&myDArray, 1);\n  DArray_delete(&myDArray, 1);\n  DArray_delete(&myDArray, 1);\n  DArray_delete(&myDArray, 5);\n  DArray_delete(&myDArray, 6);\n  Display_DArray(&myDArray);\n}\n```\n\n___main.h___\n\n```\n#define MINIMUN_ARRAY_SIZE 1\n\ntypedef enum\n{\n  RET_SUCCESS,\n  RET_FAIL,\n}RET;\n\ntypedef struct _DArray\n{\n  int array_size;\n  int allocated_array_size;\n  char* data;\n}DArray;\n\nRET DArray_insert(DArray* thiz, int index, char insert_data);\nRET DArray_delete(DArray* thiz, int index);\n\n```\n\n","source":"_posts/C-Dynamic-Array-Exercise-to-operate-the-dyanmic-array.md","raw":"title: \"[C][Dynamic Array] Exercise to operate the dyanmic array \"\ndate: 2015-03-21 15:28:52\ncategories:\n- Dynamic Array\ntags:\n- C\n- Dynamic Array\n- realloc\ntoc: true\n---\n\n\n## 目的\n\n很久之前買了一本書, 有關於系統程式師的養成計劃, 但是一直沒有很他認真的實行...\n\n哈, 最近又開始了新生活運動, 打算每個禮拜花一點時間upgrade一下技能, 已經打算\n\n靠着寫程式過我下半生了, HA....今天看到了一個有趣的議題, 資料結構裏面有 雙向鏈結以及dynamic array 這種東西, \n\n我沒學過自料結構,但是雙向鏈結在interview的時候, 常會被問, 但是 dynamic array 這個我還是第一次各聽到\n\n（是不是很虛， 沒辦法, 小弟不是資工的...走一步算一步吧!!） \n\n今天就花了時間, 學習了一下要如何操作 dynamic array... \n\n## 結論\n\n先來下個結論, 一開始我以爲dynamic array 是指array 可以動態的改變, 將底下的array, 大小改變...\n\n```\nint static_array[10];\n```\n\n但是我做了實驗, 發現是不行的(有錯的話, 請糾正我吧！！) \n\n基本上就是透過 malloc 要一塊heap 的記憶體,然後再用 realloc 的方式, 去放大縮小你的heap空間.\n\n底下的sample 主要做了底下這些事情. 一行一行做註解， 會殺了我...所以我列出concept, 讓入門人有個概念\n\n\n1. 我用一個structure -->  DArray, 來當作動態的array. 主要就是操作裏面的data\n2. 這個sample code有讓array長大的api, 以及讓array所小的api, 可以參考.h 檔去追\n3. DArray 裏面有兩個siz,\n      int array_size;           --> data array 的大小\n      int allocated_array_size; --> 我們用 malloc 實際跟系統要的memory size\n4. 爲什麼要分兩個size呢, 原因是因爲跟記憶體有關, 你應該不會希望, 當我們要新增刪除一個member 就要\n   call一次 realloc 吧...這樣會造成你的memory不連續. 就失去了dynamic array 的好處之一...\n\n## Sample Code\n\n___main.c___\n\n```\n/*******************************\n *  Purpose : Exercise to operate the dynamic array\n *  Arthur  : Sheldon Peng\n *  Date    : 2015/3/21 \n * */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"main.h\"\n\n#define SR_DBG(fmt, vargs...) printf(\"[%s][%d]\" fmt, __FUNCTION__, __LINE__, ##vargs)\n\n#define CHECK_NULL(PTR)  if(!PTR)    \\\n                          {printf(\"ERROR!! the pointer is NULL \\r\\n\");} \n\n\nstatic RET DArray_shrink(DArray* thiz, int shrink_size)\n{\n  CHECK_NULL(thiz);\n  void* shrink_data = realloc((void*)thiz->data, shrink_size*sizeof(char));\n  \n  if ( NULL!=shrink_data)\n  {\n    thiz->data = (char*)shrink_data; \n    thiz->allocated_array_size = shrink_size; \n    SR_DBG(\" SHRINK size to %d \\r\\n\", shrink_size);\n  }\n  else\n  {\n    SR_DBG(\"FAIL to realloc array \\r\\n\");\n    return RET_FAIL; \n  }\n\n  return RET_SUCCESS;\n\n}\n\nRET DArray_delete(DArray* thiz, int index)\n{\n  CHECK_NULL(thiz);\n  \n  if (index > thiz->array_size)\n  {\n    SR_DBG(\" ERROR to delete the dynamic array member beacuse the index is not belong into dynamic array \\r\\n\");\n    return RET_FAIL;\n  }\n\n  // remove the member from the dynamic array\n  int i;\n  for (i=index;i<(thiz->array_size-1);i++)\n  {\n    thiz->data[i] = thiz->data[i+1];\n  }\n  thiz->array_size = thiz->array_size-1;\n  \n  // Shrink the dynamic array if the pool size is enough to use .\n  int shrink_size = thiz->array_size + (thiz->array_size>>1);\n\n  if (shrink_size < thiz->allocated_array_size)\n  {\n     if ( RET_FAIL == DArray_shrink(thiz, shrink_size) )\n     {\n       SR_DBG(\"FAILLL to shrink the dynamic array \\r\\n\");\n     }\n  }\n}\n\nstatic RET DArray_enlarge(DArray* thiz, int enlarge_size)\n{\n  CHECK_NULL(thiz);\n  void* enlarge_data = realloc((void*)thiz->data, enlarge_size*sizeof(char));\n\n  if ( NULL!=enlarge_data )\n  {\n    thiz->data = (char*)enlarge_data;\n    thiz->allocated_array_size = enlarge_size;\n    SR_DBG(\" ENLARGE size to %d \\r\\n\", enlarge_size);\n  }\n  else\n  {\n    SR_DBG(\"FAIL to realloc array \\r\\n\");\n    return RET_FAIL; \n  }\n\n  return RET_SUCCESS;\n}\n\nRET DArray_insert(DArray* thiz, int index, char insert_data)\n{\n  CHECK_NULL(thiz);\n\n  if (index > thiz->array_size)\n  {\n    SR_DBG(\"Your index is wrong, because the index is not wihin the array \\r\\n\");\n    return RET_FAIL;\n  }\n\n  if (thiz->allocated_array_size < thiz->array_size+1)\n  {\n    SR_DBG(\"Because the space is not enough, so we need to enlarge the space for dynamic array \\r\\n\");\n    int enlarge_size = (thiz->array_size>>1) + thiz->array_size;\n    if (RET_FAIL == DArray_enlarge(thiz, enlarge_size ))\n    {\n      SR_DBG(\"FAILLL to enlarge the space of dynamic array \\r\\n\");\n      return RET_FAIL;\n    }\n  }\n  \n  int i;\n  for ( i=thiz->array_size; i>index; i--)\n  {\n    thiz->data[i] = thiz->data[i-1];\n  }\n  \n  thiz->data[index] = insert_data;\n  thiz->array_size = thiz->array_size+1;\n}\n\nvoid Display_DArray(DArray* DArray_ptr)\n{\n  int i;\n  int size = DArray_ptr->array_size;\n\n  SR_DBG(\"My Dynamic Array is : \\r\\n\");\n  SR_DBG(\"size is %d \\r\\n\", size);\n  SR_DBG(\"allocated size is %d \\r\\n\", DArray_ptr->allocated_array_size);\n\n  for ( i=0; i<size; i++)\n  {\n      printf(\"%d, \", DArray_ptr->data[i]);\n  }\n  printf(\"\\r\\n\");\n}\n\nvoid main(void)\n{\n  // Init my dynamic array\n  DArray myDArray;\n  myDArray.array_size = MINIMUN_ARRAY_SIZE;\n  myDArray.allocated_array_size = MINIMUN_ARRAY_SIZE+ (MINIMUN_ARRAY_SIZE>>1); \n  \n  //char InitArray[myDArray.array_size];\n  myDArray.data = (char*)malloc(sizeof(char)*myDArray.array_size);\n  memset((void*)myDArray.data, 0x0, (myDArray.array_size)*sizeof(char));\n\n  // Display all dynamic array members. \n  Display_DArray(&myDArray);\n\n  // test\n  SR_DBG(\"======== TEST for ENLARGing D_ARRAY \\r\\n\");\n  int i;\n  for (i=0;i<10;i++)\n  {\n    DArray_insert(&myDArray, 0, i);\n  }\n\n  for (i=0;i<10;i++)\n  {\n    DArray_insert(&myDArray, 5, i);\n  }\n  Display_DArray(&myDArray);\n  SR_DBG(\"======== TEST for SHRINking D_ARRAY \\r\\n\");\n  DArray_delete(&myDArray, 1);\n  DArray_delete(&myDArray, 1);\n  DArray_delete(&myDArray, 1);\n  DArray_delete(&myDArray, 1);\n  DArray_delete(&myDArray, 5);\n  DArray_delete(&myDArray, 6);\n  Display_DArray(&myDArray);\n}\n```\n\n___main.h___\n\n```\n#define MINIMUN_ARRAY_SIZE 1\n\ntypedef enum\n{\n  RET_SUCCESS,\n  RET_FAIL,\n}RET;\n\ntypedef struct _DArray\n{\n  int array_size;\n  int allocated_array_size;\n  char* data;\n}DArray;\n\nRET DArray_insert(DArray* thiz, int index, char insert_data);\nRET DArray_delete(DArray* thiz, int index);\n\n```\n\n","slug":"C-Dynamic-Array-Exercise-to-operate-the-dyanmic-array","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp27n003m35gg7g5xtphf"},{"title":"[C][DB][Double Link List] Exercise the Double Link List","date":"2015-05-02T13:20:04.000Z","toc":true,"_content":"\n# Purpose \n\n最近好奇要怎麼實作Stack 和 queue,看了一本書，他是用double link list來實作, \n\n爲了要自我鍛鍊一下,所以自己寫了一個double link list的實作.\n\n之後，會再補上stack/heap的組合變化. \n\n# Explain what I DO\n\n## Concept  \n\n___1. DList.h___\n\n我將API 對外的function都放在這裏.\n\n基本上就是產生一個D_Link_List,和Print D_Link_List, 新增刪除Node.\n\n新增和刪除node的方式,就是參考index. index 你可以把當作D_Link_List的Node個數\n\n我現在實作的D_Link_List 最少有一個Head Node, index可以把他當作是0.\n\n```\nDList* DList_Create(void);\ntypedef Ret (*DList_Print)(DList*);\nRet DList_Print_all(DList*, DList_Print);\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index);\nRet DList_Delete_Node_ByIndex(DList*, int index);\n```\n\n在DList 的struct裏面, 我特意將data 存成 pointer to void.\n目的其實,就是由上層來決定Double Link List裏面的Node,資料是存什麼.\n\n```\ntypedef struct _DList\n{\n  struct _DList* DList_Pre_Ptr;\n  struct _DList* DList_Next_Ptr;\n  void* data;\n  int key;\n}DList;\n```\n\n___2.DList.c___\n\n大部分實作放在這裏.\n\n___3. main.c___\n\n由於我把data要存什麼type,交給上層來決定,\n所以必須要實作存data和display data的function.\n可以參考底下這兩個function,所以我要換Node 的data type也會非常方便.\n```\nRet MyPrint(DList* MyDList);\nDList* Create_Node(int data);\n```\n我在DList struct 裏面多存了一個key的東西,爲了日後方便,可以search關鍵字.\n就可以找到你要的node,但是API還沒寫好.現在只支援Index的方式.XD\n\n在main的後面,有多補一些測試的部分.\n\n\n## FULL CODE\n\n___1. DList.h___\n```\n\n#include \"global_enum_macro.h\"\n\ntypedef struct _DList\n{\n  struct _DList* DList_Pre_Ptr;\n  struct _DList* DList_Next_Ptr;\n  void* data;\n  int key;\n}DList;\n\nDList* DList_Create(void);\ntypedef Ret (*DList_Print)(DList*);\nRet DList_Print_all(DList*, DList_Print);\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index);\nRet DList_Delete_Node_ByIndex(DList*, int index);\n\n```\n\n___2. DList.c___\n\n```\n#include \"DList.h\"\n#include \"stdlib.h\"\n\n\nDList* DList_Create(void)\n{\n  // Create the Head Node for Double Link List\n  DList* HeadNode = (DList*)malloc(sizeof(DList));\n  \n  check_pointer_return_value(HeadNode,NULL);\n\n  HeadNode->DList_Pre_Ptr = NULL;\n  HeadNode->DList_Next_Ptr = NULL;\n  \n  return HeadNode;\n\n}\n\nRet DList_Print_all(DList* HeadNode, DList_Print Print)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(Print, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ? \n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  DList* DList_Ptr = HeadNode;\n\n  while (DList_Ptr->DList_Next_Ptr != NULL)\n  {\n    // if the node is HEAD, we skip that node\n    if (DList_Ptr->DList_Pre_Ptr != NULL)\n    {\n      Print(DList_Ptr);\n    }\n      DList_Ptr = DList_Ptr->DList_Next_Ptr;\n  }\n\n  // Print the Tail Node's data\n  Print(DList_Ptr);\n\n}\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(InsertNode, Ret_Fail);\n\n  // check the Double Link List is EMPTY ??\n  if (HeadNode->DList_Pre_Ptr == NULL && HeadNode->DList_Next_Ptr == NULL)\n  {\n    HeadNode->DList_Next_Ptr = InsertNode;\n    InsertNode->DList_Next_Ptr = NULL;\n    InsertNode->DList_Pre_Ptr = HeadNode;\n    printf(\"Because the Double Link List is EMPTY, so I force the index to be 1 \\n\");\n    return Ret_Success;\n  }\n  \n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n\n  do\n  {\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n    if (cnt == index)\n    {\n      InsertNode->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      InsertNode->DList_Pre_Ptr->DList_Next_Ptr = InsertNode;\n      Temp_Ptr->DList_Pre_Ptr = InsertNode;\n      InsertNode->DList_Next_Ptr = Temp_Ptr;\n      return Ret_Success;\n    }\n    \n  } while ( Temp_Ptr->DList_Next_Ptr != NULL);\n\n  // If the index is large than the length of Double link list, just add the NODE into the tail of Double Link List.\n\n  printf(\"Because the index is large than the length of Double Link List, just insert the NODE into the tail of Double LInke List \\n\");\n  Temp_Ptr->DList_Next_Ptr = InsertNode;\n  InsertNode->DList_Next_Ptr = NULL;\n  return Ret_Success;\n}\n\nRet DList_Delete_Node_ByIndex(DList* HeadNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n  while (Temp_Ptr->DList_Next_Ptr != NULL)\n  {\n    if (cnt == index)\n    {\n      Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = Temp_Ptr->DList_Next_Ptr;\n      Temp_Ptr->DList_Next_Ptr->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      printf(\"Free the Node of Indx[%d] \\n\", index);\n      free(Temp_Ptr->data);\n      free(Temp_Ptr);\n      return Ret_Success;\n    }\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n  }\n\n  // Because the index is large than the length of Double Link List && the Node which you want to delete is TAIL Node. \n\n  printf(\"Free the TAIL NODE \\n\");\n  Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = NULL;\n  free(Temp_Ptr->data);\n  free(Temp_Ptr);\n  return Ret_Success;\n}\n\n```\n\n___3.main.c___\n\n```\n#include <stdlib.h>\n#include \"DList.h\"\n\nRet MyPrint(DList* MyDList)\n{\n  check_pointer_return_value(MyDList, Ret_Fail);\n  // This place tell how to print the DLinkList's data type\n  printf(\"MyDList->key=%d, *(int*)(MyDList->data)=%d \\r\\n\", MyDList->key, *(int*)(MyDList->data));\n}\n\nDList* Create_Node(int data)\n{\n  DList* myNode = (DList*)malloc(sizeof(DList));\n  myNode->data = (int*)malloc(sizeof(int));\n  *(int*)(myNode->data) = data; \n  return myNode;\n}\n\nvoid main(void)\n{\n  DList* HeadNode = DList_Create();\n\n  // Create Node && Insert to the Double Link List\n  DList_Insert_Node_ByIndex(HeadNode,Create_Node(10),1);\n  DList_Insert_Node_ByIndex(HeadNode,Create_Node(20),1);\n  DList_Insert_Node_ByIndex(HeadNode,Create_Node(30),1);\n  DList_Insert_Node_ByIndex(HeadNode,Create_Node(40),3);\n  DList_Insert_Node_ByIndex(HeadNode,Create_Node(50),1);\n\n  // Delete the Node\n  DList_Delete_Node_ByIndex(HeadNode, 2);\n  DList_Delete_Node_ByIndex(HeadNode, 5);\n  DList_Delete_Node_ByIndex(HeadNode, 1);\n\n  // Print all the Nodes of Double Link List\n  DList_Print_all(HeadNode, MyPrint);\n}\n\n```\n\n___4.global_enum_macro.h___\n\n```\n#include <stdio.h>\n\n// Define GLobal Enum\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None,\n}Ret;\n\n// Define Global Macro\n#define SR_DBG(fmt,args ...) printf(\"[Sheldon debug][%s][%d] \"fmt,__FUNCTION__,__LINE__,##args)\n#define SR_ERR(fmt,args ...) printf(\"ERROR !!! [%s][%d ] \"fmt, __FUNCTION__,__LINE__,##args)\n#define check_pointer_return_value(ptr,value) if(ptr==NULL) \\\n                                                  { printf(\"ERROR!!! #ptr is NULL, return #value \\r\\n\"); \\\n                                                  return value;} \\\n\n\n\n\n```\n\n\n","source":"_posts/C-DB-Double-Link-List-Exercise-the-Double-Link-List.md","raw":"title: \"[C][DB][Double Link List] Exercise the Double Link List\"\ndate: 2015-05-02 21:20:04\ncategories:\n- Double Link List\ntags:\n- C\n- DB\n- Double Link List\ntoc: true\n---\n\n# Purpose \n\n最近好奇要怎麼實作Stack 和 queue,看了一本書，他是用double link list來實作, \n\n爲了要自我鍛鍊一下,所以自己寫了一個double link list的實作.\n\n之後，會再補上stack/heap的組合變化. \n\n# Explain what I DO\n\n## Concept  \n\n___1. DList.h___\n\n我將API 對外的function都放在這裏.\n\n基本上就是產生一個D_Link_List,和Print D_Link_List, 新增刪除Node.\n\n新增和刪除node的方式,就是參考index. index 你可以把當作D_Link_List的Node個數\n\n我現在實作的D_Link_List 最少有一個Head Node, index可以把他當作是0.\n\n```\nDList* DList_Create(void);\ntypedef Ret (*DList_Print)(DList*);\nRet DList_Print_all(DList*, DList_Print);\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index);\nRet DList_Delete_Node_ByIndex(DList*, int index);\n```\n\n在DList 的struct裏面, 我特意將data 存成 pointer to void.\n目的其實,就是由上層來決定Double Link List裏面的Node,資料是存什麼.\n\n```\ntypedef struct _DList\n{\n  struct _DList* DList_Pre_Ptr;\n  struct _DList* DList_Next_Ptr;\n  void* data;\n  int key;\n}DList;\n```\n\n___2.DList.c___\n\n大部分實作放在這裏.\n\n___3. main.c___\n\n由於我把data要存什麼type,交給上層來決定,\n所以必須要實作存data和display data的function.\n可以參考底下這兩個function,所以我要換Node 的data type也會非常方便.\n```\nRet MyPrint(DList* MyDList);\nDList* Create_Node(int data);\n```\n我在DList struct 裏面多存了一個key的東西,爲了日後方便,可以search關鍵字.\n就可以找到你要的node,但是API還沒寫好.現在只支援Index的方式.XD\n\n在main的後面,有多補一些測試的部分.\n\n\n## FULL CODE\n\n___1. DList.h___\n```\n\n#include \"global_enum_macro.h\"\n\ntypedef struct _DList\n{\n  struct _DList* DList_Pre_Ptr;\n  struct _DList* DList_Next_Ptr;\n  void* data;\n  int key;\n}DList;\n\nDList* DList_Create(void);\ntypedef Ret (*DList_Print)(DList*);\nRet DList_Print_all(DList*, DList_Print);\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index);\nRet DList_Delete_Node_ByIndex(DList*, int index);\n\n```\n\n___2. DList.c___\n\n```\n#include \"DList.h\"\n#include \"stdlib.h\"\n\n\nDList* DList_Create(void)\n{\n  // Create the Head Node for Double Link List\n  DList* HeadNode = (DList*)malloc(sizeof(DList));\n  \n  check_pointer_return_value(HeadNode,NULL);\n\n  HeadNode->DList_Pre_Ptr = NULL;\n  HeadNode->DList_Next_Ptr = NULL;\n  \n  return HeadNode;\n\n}\n\nRet DList_Print_all(DList* HeadNode, DList_Print Print)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(Print, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ? \n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  DList* DList_Ptr = HeadNode;\n\n  while (DList_Ptr->DList_Next_Ptr != NULL)\n  {\n    // if the node is HEAD, we skip that node\n    if (DList_Ptr->DList_Pre_Ptr != NULL)\n    {\n      Print(DList_Ptr);\n    }\n      DList_Ptr = DList_Ptr->DList_Next_Ptr;\n  }\n\n  // Print the Tail Node's data\n  Print(DList_Ptr);\n\n}\nRet DList_Insert_Node_ByIndex(DList* HeadNode, DList* InsertNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n  check_pointer_return_value(InsertNode, Ret_Fail);\n\n  // check the Double Link List is EMPTY ??\n  if (HeadNode->DList_Pre_Ptr == NULL && HeadNode->DList_Next_Ptr == NULL)\n  {\n    HeadNode->DList_Next_Ptr = InsertNode;\n    InsertNode->DList_Next_Ptr = NULL;\n    InsertNode->DList_Pre_Ptr = HeadNode;\n    printf(\"Because the Double Link List is EMPTY, so I force the index to be 1 \\n\");\n    return Ret_Success;\n  }\n  \n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n\n  do\n  {\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n    if (cnt == index)\n    {\n      InsertNode->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      InsertNode->DList_Pre_Ptr->DList_Next_Ptr = InsertNode;\n      Temp_Ptr->DList_Pre_Ptr = InsertNode;\n      InsertNode->DList_Next_Ptr = Temp_Ptr;\n      return Ret_Success;\n    }\n    \n  } while ( Temp_Ptr->DList_Next_Ptr != NULL);\n\n  // If the index is large than the length of Double link list, just add the NODE into the tail of Double Link List.\n\n  printf(\"Because the index is large than the length of Double Link List, just insert the NODE into the tail of Double LInke List \\n\");\n  Temp_Ptr->DList_Next_Ptr = InsertNode;\n  InsertNode->DList_Next_Ptr = NULL;\n  return Ret_Success;\n}\n\nRet DList_Delete_Node_ByIndex(DList* HeadNode, int index)\n{\n  check_pointer_return_value(HeadNode, Ret_Fail);\n\n  // Check the Double Link List is only Head Node ?\n  if (HeadNode->DList_Next_Ptr == NULL && HeadNode->DList_Pre_Ptr == NULL)\n  {\n    printf(\"The Double Link List Is EMPTY \\n\");\n    check_pointer_return_value(NULL, Ret_Fail);\n  }\n\n  int cnt=0;\n  DList* Temp_Ptr = HeadNode;\n  while (Temp_Ptr->DList_Next_Ptr != NULL)\n  {\n    if (cnt == index)\n    {\n      Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = Temp_Ptr->DList_Next_Ptr;\n      Temp_Ptr->DList_Next_Ptr->DList_Pre_Ptr = Temp_Ptr->DList_Pre_Ptr;\n      printf(\"Free the Node of Indx[%d] \\n\", index);\n      free(Temp_Ptr->data);\n      free(Temp_Ptr);\n      return Ret_Success;\n    }\n    cnt ++;\n    Temp_Ptr = Temp_Ptr->DList_Next_Ptr;\n  }\n\n  // Because the index is large than the length of Double Link List && the Node which you want to delete is TAIL Node. \n\n  printf(\"Free the TAIL NODE \\n\");\n  Temp_Ptr->DList_Pre_Ptr->DList_Next_Ptr = NULL;\n  free(Temp_Ptr->data);\n  free(Temp_Ptr);\n  return Ret_Success;\n}\n\n```\n\n___3.main.c___\n\n```\n#include <stdlib.h>\n#include \"DList.h\"\n\nRet MyPrint(DList* MyDList)\n{\n  check_pointer_return_value(MyDList, Ret_Fail);\n  // This place tell how to print the DLinkList's data type\n  printf(\"MyDList->key=%d, *(int*)(MyDList->data)=%d \\r\\n\", MyDList->key, *(int*)(MyDList->data));\n}\n\nDList* Create_Node(int data)\n{\n  DList* myNode = (DList*)malloc(sizeof(DList));\n  myNode->data = (int*)malloc(sizeof(int));\n  *(int*)(myNode->data) = data; \n  return myNode;\n}\n\nvoid main(void)\n{\n  DList* HeadNode = DList_Create();\n\n  // Create Node && Insert to the Double Link List\n  DList_Insert_Node_ByIndex(HeadNode,Create_Node(10),1);\n  DList_Insert_Node_ByIndex(HeadNode,Create_Node(20),1);\n  DList_Insert_Node_ByIndex(HeadNode,Create_Node(30),1);\n  DList_Insert_Node_ByIndex(HeadNode,Create_Node(40),3);\n  DList_Insert_Node_ByIndex(HeadNode,Create_Node(50),1);\n\n  // Delete the Node\n  DList_Delete_Node_ByIndex(HeadNode, 2);\n  DList_Delete_Node_ByIndex(HeadNode, 5);\n  DList_Delete_Node_ByIndex(HeadNode, 1);\n\n  // Print all the Nodes of Double Link List\n  DList_Print_all(HeadNode, MyPrint);\n}\n\n```\n\n___4.global_enum_macro.h___\n\n```\n#include <stdio.h>\n\n// Define GLobal Enum\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None,\n}Ret;\n\n// Define Global Macro\n#define SR_DBG(fmt,args ...) printf(\"[Sheldon debug][%s][%d] \"fmt,__FUNCTION__,__LINE__,##args)\n#define SR_ERR(fmt,args ...) printf(\"ERROR !!! [%s][%d ] \"fmt, __FUNCTION__,__LINE__,##args)\n#define check_pointer_return_value(ptr,value) if(ptr==NULL) \\\n                                                  { printf(\"ERROR!!! #ptr is NULL, return #value \\r\\n\"); \\\n                                                  return value;} \\\n\n\n\n\n```\n\n\n","slug":"C-DB-Double-Link-List-Exercise-the-Double-Link-List","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp27y003u35gg7h6cnsz9"},{"title":"[AtoI/ItoA] Sample Code","date":"2015-05-27T23:03:06.000Z","toc":true,"_content":"\n# Purpose \n\n每天寫一點小程式,雖然簡單,但是也讓我心情開心,慢慢的讓程式實作能力,變得更有自信.\n\n昨天寫了基本常用的 atoi和itoa 的基本 c api.也算是面試常見用的考古題.\n\n順便複習一下,也是好事情.\n\n# My ATOi \n\n```\nRet my_atoi(int* num, const char* char_num) \n{\n  // 檢查 poineter 是否爲空的, 是的話, return fail\n  check_pointer_return_value(char_num, Ret_Fail);\n\n  // init the total value\n  int total = 0; \n  \n  // 檢查是否爲負數\n  int is_positive = 1;\n  if (char_num[0] == '-')\n  {\n    //若爲負數的話,就記錄下來\n    is_positive = -1;\n    char_num ++;\n  }\n\n  // 將每個字元,減去'0',這樣就可以得到字元的value, \n  // 舉例: '0' = 30, '9' = 39 , 若是我要得到字元9的值, 就用 '9'-'0'=39-30=9 \n  while ( *char_num != '\\0')\n  {\n    // 將10進位的數往左推一個\n    total *= 10;\n    total += *char_num - '0';\n    char_num++;\n  }\n\n  *num = total*is_positive;\n\n  return Ret_Success;\n}\n```\n\n# My IToA\n\n```\nRet my_itoa(int num, char* char_num)\n{\n  check_pointer_return_value(char_num, Ret_Fail);\n\n  int is_negative = 0;\n  char* return_char = char_num;\n\n  // 處理負數\n  if (num < 0)\n  {\n    is_negative = 1;\n    num *= -1;\n    \n  }\n\n  // 處理0\n  if (num == 0)\n  {\n    *char_num = '0';\n    return Ret_Success;\n  }\n\n  while ( num != 0)\n  {\n    // 將0~9的值轉成字元,其實很間單,就是加上'0' 或是 30\n    *char_num = '0' + (num % 10);\n    num /= 10;\n    char_num++;\n  }\n  \n  if (is_negative)\n  {\n    // 若爲負數的話,將'-'加入字串中\n    *char_num = '-';\n    char_num++;\n  }\n  \n  // Revert string \n  Revert(return_char);\n\n  return Ret_Success;\n\n}\n\nRet Revert(char* num_char)\n{\n  check_pointer_return_value(num_char, Ret_Fail);\n\n  int length = strlen(num_char);\n  \n  int i;\n  // 將字串中的字元整份顛倒\n  for (i=0; i<length/2; i++)\n  {\n    char temp_char ;\n    temp_char = num_char[i] ;\n    // swap \n    num_char[i] = num_char[length-1-i];\n    num_char[length-1-i] = temp_char;\n  }\n\n  return Ret_Success;\n}\n\n```\n\n# Testing \n\n```\n#include <stdio.h>\n#include <string.h>\n\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None\n}Ret;\n\nRet my_atoi(int* num, const char*);\nRet my_itoa(int num, char* char_num);\n\n#define check_pointer_return_value(ptr,value) if(ptr==NULL) \\\n                                              { printf(\" pointer is NULL !!!\"); \\\n                                                return value; } \\\n\nvoid main(void)\n{\n  char test_char[] = \"-159\";\n  char test_char2[] = \"269\";\n  int temp_num ;\n  my_atoi(&temp_num,test_char);\n  printf(\"my_atoi : strlen(test_char) = %zu, test = %d \\r\\n\", strlen(test_char),temp_num );\n  my_atoi(&temp_num,test_char2);\n  printf(\"my_atoi : strlen(test_char2) = %zu, test2 = %d \\r\\n\", strlen(test_char2), temp_num);\n\n  char test_char3[255] = \"\";\n  my_itoa(128, test_char3);\n  printf(\"my_itoa : %s \\r\\n\", test_char3);\n  memset(test_char3,'\\0',strlen(test_char3));\n  my_itoa(-259, test_char3);\n  printf(\"my_itoa : %s \\r\\n\", test_char3);\n\n}\n\n```\n","source":"_posts/AtoI-ItoA-Sample-Code.md","raw":"title: \"[AtoI/ItoA] Sample Code\"\ndate: 2015-05-28 07:03:06\ncategories:\n- c\ntags:\n- atoi\n- itoa\ntoc: true\n---\n\n# Purpose \n\n每天寫一點小程式,雖然簡單,但是也讓我心情開心,慢慢的讓程式實作能力,變得更有自信.\n\n昨天寫了基本常用的 atoi和itoa 的基本 c api.也算是面試常見用的考古題.\n\n順便複習一下,也是好事情.\n\n# My ATOi \n\n```\nRet my_atoi(int* num, const char* char_num) \n{\n  // 檢查 poineter 是否爲空的, 是的話, return fail\n  check_pointer_return_value(char_num, Ret_Fail);\n\n  // init the total value\n  int total = 0; \n  \n  // 檢查是否爲負數\n  int is_positive = 1;\n  if (char_num[0] == '-')\n  {\n    //若爲負數的話,就記錄下來\n    is_positive = -1;\n    char_num ++;\n  }\n\n  // 將每個字元,減去'0',這樣就可以得到字元的value, \n  // 舉例: '0' = 30, '9' = 39 , 若是我要得到字元9的值, 就用 '9'-'0'=39-30=9 \n  while ( *char_num != '\\0')\n  {\n    // 將10進位的數往左推一個\n    total *= 10;\n    total += *char_num - '0';\n    char_num++;\n  }\n\n  *num = total*is_positive;\n\n  return Ret_Success;\n}\n```\n\n# My IToA\n\n```\nRet my_itoa(int num, char* char_num)\n{\n  check_pointer_return_value(char_num, Ret_Fail);\n\n  int is_negative = 0;\n  char* return_char = char_num;\n\n  // 處理負數\n  if (num < 0)\n  {\n    is_negative = 1;\n    num *= -1;\n    \n  }\n\n  // 處理0\n  if (num == 0)\n  {\n    *char_num = '0';\n    return Ret_Success;\n  }\n\n  while ( num != 0)\n  {\n    // 將0~9的值轉成字元,其實很間單,就是加上'0' 或是 30\n    *char_num = '0' + (num % 10);\n    num /= 10;\n    char_num++;\n  }\n  \n  if (is_negative)\n  {\n    // 若爲負數的話,將'-'加入字串中\n    *char_num = '-';\n    char_num++;\n  }\n  \n  // Revert string \n  Revert(return_char);\n\n  return Ret_Success;\n\n}\n\nRet Revert(char* num_char)\n{\n  check_pointer_return_value(num_char, Ret_Fail);\n\n  int length = strlen(num_char);\n  \n  int i;\n  // 將字串中的字元整份顛倒\n  for (i=0; i<length/2; i++)\n  {\n    char temp_char ;\n    temp_char = num_char[i] ;\n    // swap \n    num_char[i] = num_char[length-1-i];\n    num_char[length-1-i] = temp_char;\n  }\n\n  return Ret_Success;\n}\n\n```\n\n# Testing \n\n```\n#include <stdio.h>\n#include <string.h>\n\ntypedef enum _Ret\n{\n  Ret_Success,\n  Ret_Fail,\n  Ret_None\n}Ret;\n\nRet my_atoi(int* num, const char*);\nRet my_itoa(int num, char* char_num);\n\n#define check_pointer_return_value(ptr,value) if(ptr==NULL) \\\n                                              { printf(\" pointer is NULL !!!\"); \\\n                                                return value; } \\\n\nvoid main(void)\n{\n  char test_char[] = \"-159\";\n  char test_char2[] = \"269\";\n  int temp_num ;\n  my_atoi(&temp_num,test_char);\n  printf(\"my_atoi : strlen(test_char) = %zu, test = %d \\r\\n\", strlen(test_char),temp_num );\n  my_atoi(&temp_num,test_char2);\n  printf(\"my_atoi : strlen(test_char2) = %zu, test2 = %d \\r\\n\", strlen(test_char2), temp_num);\n\n  char test_char3[255] = \"\";\n  my_itoa(128, test_char3);\n  printf(\"my_itoa : %s \\r\\n\", test_char3);\n  memset(test_char3,'\\0',strlen(test_char3));\n  my_itoa(-259, test_char3);\n  printf(\"my_itoa : %s \\r\\n\", test_char3);\n\n}\n\n```\n","slug":"AtoI-ItoA-Sample-Code","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp28b004235ggu4v9s1xt"},{"title":"[Ubuntu]如何在Ubuntu底下安裝LINE","date":"2015-02-28T17:08:03.000Z","toc":true,"_content":"\n## 目的\n\n我每次要用line的時候,都需要把virtual box的windows打開，這樣才能使用\nPC上的line,這樣真的太耗時了,所以今天研究了在ubuntu底下如何使用LINE.\n\n\n___1. Ubuntu 版本___\n\n```\nsheldon$ cat /etc/issue\nUbuntu 14.04.2 LTS \\n \\l\n```\n\n___2. Wine 版本___\n\n```\nsheldon$ wine --version\nwine-1.6.2\n```\n\n## 方法\n\n我參考了這個[聯結](http://askubuntu.com/questions/517932/how-can-i-install-line)\n\n___0. 安裝p7zip以及vcrun2008___\n\n```\nsudo apt-get install p7zip  # [p7zip](http://packages.ubuntu.com/zh-tw/lucid/utils/p7zip-full)是具有高壓縮率的套件\nwget http://winetricks.org/winetricks # [winetricks](http://www.ubuntu-tw.org/modules/newbb/viewtopic.php?post_id=66666) 是wine自動安裝函式庫的好工具XD\nchmod +x winetricks # 賦予執行的權利\n./winetricks #執行winetricks\n\n```\n\n___參考底下圖片安裝vcrun2008___\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/winetricks1.png %}\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/winetricks2.png %}\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/winetricks3.png %}\n\n\n___1. 產生一個暫存的line_tmp, 並cd 進去___\n\n```\nmkdir line_tmp\ncd line_tmp\n```\n\n___2. wget 最新的LINE version, 並且利用7z去extract 資料出來___\n\n```\nwget http://dl.desktop.line.naver.jp/naver/LINE/win/LineInst.exe\n7z x -y LineInst.exe\n# x      eXtract with full paths\n# -y     Assume Yes on all queries\n```\n\n___3. 由於你7z extract 出來的三個資料夾都是亂碼, 所以用node number去將名字改成LINE/resources,並將resources 放到LINE folder中___\n\n```\ninode1=$(ls -ilab | awk 'FNR == 4 {print $1}')\ninode2=$(ls -ilab | awk 'FNR == 6 {print $1}')\nfind . -inum $inode1 -exec mv {} LINE \\;       #將inode1的folder更名成LINE\nfind . -inum $inode2 -exec mv {} resources \\;  #將indoe2的folder更名成resources\nmv ./resources/res ./LINE\nmv ./LINE ../\ncd ..\nrm -R line_tmp\n\n```\n\n___4. 用wine執行 Line.exe___\n\n```\nwine Line.exe\n```\n\n","source":"_posts/-Ubuntu-如何在Ubuntu底下安裝LINE.md","raw":"title: \"[Ubuntu]如何在Ubuntu底下安裝LINE\"\ndate: 2015-03-01 01:08:03\ncategories: Ubuntu\ntags: \n- Line \n- Ubuntu\ntoc: true\n---\n\n## 目的\n\n我每次要用line的時候,都需要把virtual box的windows打開，這樣才能使用\nPC上的line,這樣真的太耗時了,所以今天研究了在ubuntu底下如何使用LINE.\n\n\n___1. Ubuntu 版本___\n\n```\nsheldon$ cat /etc/issue\nUbuntu 14.04.2 LTS \\n \\l\n```\n\n___2. Wine 版本___\n\n```\nsheldon$ wine --version\nwine-1.6.2\n```\n\n## 方法\n\n我參考了這個[聯結](http://askubuntu.com/questions/517932/how-can-i-install-line)\n\n___0. 安裝p7zip以及vcrun2008___\n\n```\nsudo apt-get install p7zip  # [p7zip](http://packages.ubuntu.com/zh-tw/lucid/utils/p7zip-full)是具有高壓縮率的套件\nwget http://winetricks.org/winetricks # [winetricks](http://www.ubuntu-tw.org/modules/newbb/viewtopic.php?post_id=66666) 是wine自動安裝函式庫的好工具XD\nchmod +x winetricks # 賦予執行的權利\n./winetricks #執行winetricks\n\n```\n\n___參考底下圖片安裝vcrun2008___\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/winetricks1.png %}\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/winetricks2.png %}\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/winetricks3.png %}\n\n\n___1. 產生一個暫存的line_tmp, 並cd 進去___\n\n```\nmkdir line_tmp\ncd line_tmp\n```\n\n___2. wget 最新的LINE version, 並且利用7z去extract 資料出來___\n\n```\nwget http://dl.desktop.line.naver.jp/naver/LINE/win/LineInst.exe\n7z x -y LineInst.exe\n# x      eXtract with full paths\n# -y     Assume Yes on all queries\n```\n\n___3. 由於你7z extract 出來的三個資料夾都是亂碼, 所以用node number去將名字改成LINE/resources,並將resources 放到LINE folder中___\n\n```\ninode1=$(ls -ilab | awk 'FNR == 4 {print $1}')\ninode2=$(ls -ilab | awk 'FNR == 6 {print $1}')\nfind . -inum $inode1 -exec mv {} LINE \\;       #將inode1的folder更名成LINE\nfind . -inum $inode2 -exec mv {} resources \\;  #將indoe2的folder更名成resources\nmv ./resources/res ./LINE\nmv ./LINE ../\ncd ..\nrm -R line_tmp\n\n```\n\n___4. 用wine執行 Line.exe___\n\n```\nwine Line.exe\n```\n\n","slug":"-Ubuntu-如何在Ubuntu底下安裝LINE","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp28i004935gg59h6w0sg"},{"title":"[Raspberry Pi] 要如何自動的進入shell裏面, 而不需要輸入密碼","date":"2015-02-25T15:35:19.000Z","toc":true,"_content":"\n## 目的\n\n假如你寫了一程式， 但是你希望他能在Pi上, 從一上電後自己能夠執行. \n要怎麼做呢?\n\n## 方法\n\n我參考了這篇. [auto_login](http://dreamgreenhouse.com/projects/2013/picar/)\n\n___1. 將/etc/inittab 裏面的, 下面這行mark.___\n\n```\nLine 54 ==> #1:2345:respawn:/sbin/getty --noclear 38400 tty1\n```\n\n___2. 並將底下這行附在剛剛mark的地方___\n\n```\nLine 55 ==> 1:2345:respawn:/bin/login -f pi tty1 </dev/tty1 >/dev/tty1 2>&1\n```\n\n不知道有沒有人會跟我一樣好奇, 爲什麼上面這行, 沒有帶密碼但是卻能夠, 自動的登入. \n我google了一下, 有[網友說](http://www.raspberrypi.org/forums/viewtopic.php?f=63&t=66251)\n\n> The commands in inittab are run as root and root does not need passwords for many things.\n\n也就是說， 在執行inittab的時候, 程式就是root了, 所以根本不需要密碼. \n\n\n___3. 將你要跑的script 放在.bashrc 裏面.___\n\n例如底下\n\n```\n./your_script.sh &\n```\n","source":"_posts/-Raspberry-Pi-要如何自動的進入shell裏面-而不需要輸入密碼.md","raw":"title: \"[Raspberry Pi] 要如何自動的進入shell裏面, 而不需要輸入密碼\"\ndate: 2015-02-25 23:35:19\ncategories: Raspberry Pi\ntags:\n- Raspberry Pi\ntoc: true\n---\n\n## 目的\n\n假如你寫了一程式， 但是你希望他能在Pi上, 從一上電後自己能夠執行. \n要怎麼做呢?\n\n## 方法\n\n我參考了這篇. [auto_login](http://dreamgreenhouse.com/projects/2013/picar/)\n\n___1. 將/etc/inittab 裏面的, 下面這行mark.___\n\n```\nLine 54 ==> #1:2345:respawn:/sbin/getty --noclear 38400 tty1\n```\n\n___2. 並將底下這行附在剛剛mark的地方___\n\n```\nLine 55 ==> 1:2345:respawn:/bin/login -f pi tty1 </dev/tty1 >/dev/tty1 2>&1\n```\n\n不知道有沒有人會跟我一樣好奇, 爲什麼上面這行, 沒有帶密碼但是卻能夠, 自動的登入. \n我google了一下, 有[網友說](http://www.raspberrypi.org/forums/viewtopic.php?f=63&t=66251)\n\n> The commands in inittab are run as root and root does not need passwords for many things.\n\n也就是說， 在執行inittab的時候, 程式就是root了, 所以根本不需要密碼. \n\n\n___3. 將你要跑的script 放在.bashrc 裏面.___\n\n例如底下\n\n```\n./your_script.sh &\n```\n","slug":"-Raspberry-Pi-要如何自動的進入shell裏面-而不需要輸入密碼","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp294004f35ggu5jxdu3c"},{"title":"[Raspberry Pi] 製作PI的衣服 (Case)","date":"2015-02-26T09:59:37.000Z","toc":true,"_content":"## 目的\n\n最近想把PI帶出去外面走走, 但是只帶裸機, 未免有點不體面. \n所以想他找找有沒有比較他便宜他的外殼可以用, 而且還要有cam module 的外殼.\n網拍找了找, 都是出奇的貴鬆鬆, 都要能夠他買個一個新的PI了. WTF,\n爲了省錢, 所以只能來個DIY.... \n\n## 方法\n\n___1. 準被材料___\n\na. 瓦楞紙 20 NTD\n\nb. 印一張A4 紙 2 NTD --> {% link 下載草稿 http://sheldonrush.github.io/sheldon.is.a.geek/doc/raspberry_case.pdf %}\n\nc. 白膠和橡皮筋 (家裏就有了, 不用錢)\n\n比一下PI跟草稿圖是不是很合. XD\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/IMG_1242.JPG%}\n\n\n___2.痛苦又有趣的開始___\n\na. 將A4紙粘貼在瓦楞紙的上面, 並沿着實線將不要的瓦楞紙剪下來.\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/IMG_1249.JPG %}\n\nb. 我把CAM年粘在正中央, \n   並用常識把應該折的地方折好, 使力的讓你的PI適應新的衣服 QQ. \n   就大功告成了\n\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/IMG_1250.JPG %}\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/IMG_1251.JPG %}\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/IMG_1252.JPG %}\n\n\n___3. 結論 ___\n\n我果然不適合做手工藝的東西, 弄的太醜了, 或許應該來買一臺3D printer\n弄個模子之類的, 就不用這麼花時了. \n剩下的就等着明天來實際, 測試一下我的車用行車記錄器. \nHaHa\n\n\n","source":"_posts/-Raspberry-Pi-製作PI的衣服-Case.md","raw":"title: \"[Raspberry Pi] 製作PI的衣服 (Case)\"\ndate: 2015-02-26 17:59:37\ncategories: Raspberry Pi\ntags: \n- Raspberry Pi\n- Case\ntoc: true\n---\n## 目的\n\n最近想把PI帶出去外面走走, 但是只帶裸機, 未免有點不體面. \n所以想他找找有沒有比較他便宜他的外殼可以用, 而且還要有cam module 的外殼.\n網拍找了找, 都是出奇的貴鬆鬆, 都要能夠他買個一個新的PI了. WTF,\n爲了省錢, 所以只能來個DIY.... \n\n## 方法\n\n___1. 準被材料___\n\na. 瓦楞紙 20 NTD\n\nb. 印一張A4 紙 2 NTD --> {% link 下載草稿 http://sheldonrush.github.io/sheldon.is.a.geek/doc/raspberry_case.pdf %}\n\nc. 白膠和橡皮筋 (家裏就有了, 不用錢)\n\n比一下PI跟草稿圖是不是很合. XD\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/IMG_1242.JPG%}\n\n\n___2.痛苦又有趣的開始___\n\na. 將A4紙粘貼在瓦楞紙的上面, 並沿着實線將不要的瓦楞紙剪下來.\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/IMG_1249.JPG %}\n\nb. 我把CAM年粘在正中央, \n   並用常識把應該折的地方折好, 使力的讓你的PI適應新的衣服 QQ. \n   就大功告成了\n\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/IMG_1250.JPG %}\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/IMG_1251.JPG %}\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/IMG_1252.JPG %}\n\n\n___3. 結論 ___\n\n我果然不適合做手工藝的東西, 弄的太醜了, 或許應該來買一臺3D printer\n弄個模子之類的, 就不用這麼花時了. \n剩下的就等着明天來實際, 測試一下我的車用行車記錄器. \nHaHa\n\n\n","slug":"-Raspberry-Pi-製作PI的衣服-Case","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp29e004k35gg4i6rfn0d"},{"title":"[Raspberry Pi] Socket Programming and GPIO","date":"2015-03-01T00:30:29.000Z","toc":true,"_content":"\n\n## 目的\n\n很久之前, 曾經做過 socket programming在樹梅派的應用. \n也做了個demo影片留在youtube上, 當初只是好玩做做,沒想到有人需要source code.\n我找了一下, 所以就放上來了,有興趣的可以看一下囉，沒意外的話,應該也是一個拼裝車XDDD\n\n這個Demo 影片, 是讓樹梅派當client, 讓laptop 當server 收訊號. 因爲我只有一個樹梅派, 但是我又想模擬mutlit-client的情況, \n所以我在laptop又多起一個task去送訊號給server. \n\n\n## Demo on Youtube\n\nThis  demo tell how to control GPIO and send the data to server.\nAbout socket programming, server can receive the data from multi client.\n\n{% youtube i2Jig5vebBk %}\n\n\n## Source code.\n\n{% link 下載Download http://sheldonrush.github.io/sheldon.is.a.geek/doc/Pi_is_client_PC_is_server.tar.7z %}\n\n___1. server端___\n\n// sr_server.c\n\n```\n/*\nFunction : socket code for server\nArthur : SheldonRush Peng\nDate : 2013/7/26\n*/\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\nint main(int argc, char *argv[])\n{\n    int connfd = 0, n = 0, listenfd = socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in serv_addr;\n\n    char charBuff[1024];\n    char recvBuff[1024];\n    time_t ticks;\n\n    // init the data structure of serv_addr\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    memset(charBuff, '\\0', sizeof(charBuff));\n    memset(recvBuff, '\\0', sizeof(recvBuff));\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    serv_addr.sin_port = htons(8998);\n\n    // assign the scket port to socket\n    bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n\n    listen(listenfd, 20);\n\n    while (1)\n    {\n        connfd = accept(listenfd, (struct sockaddr*)NULL, NULL);\n   \n        printf(\"%s %d \\n\", \"server: connfd is\", connfd);\n        ticks = time(NULL);\n        snprintf(charBuff, sizeof(charBuff), \"%s\\n\", ctime(&ticks));\n        printf(\"server: %s\\n\", charBuff);\n        \n        while ( (n = read(connfd, recvBuff, sizeof(recvBuff)-1)) > 0)\n        {\n           recvBuff[n] = 0;\n           printf(\"server: read %d bytes \\n\", n);\n           printf(\"server: EOF = %d \\n\", EOF);\n           if ( fputs(recvBuff, stdout) == EOF)\n           {\n                printf(\"Error : Fputs error \\n\");\n           }\n        }\n\n        if (n < 0)\n        {\n            printf(\"Error : read errpr \\n\");\n        }\n       //  write(connfd, sendBuff, strlen(sendBuff));\n        close(connfd);\n        sleep(1); \n    }\n}\n\n```\n\n___2. Clinet 端___\n\n// main.c\n\n```\n/*\nFunction : Detect whether GPIO[17] is high or low\nArthur : Sheldon RUsh Peng\nDate : 2013/7/27\n*/\n\n#include <wiringPi.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n#include \"sr_clinit.h\" \n\n\n#define False 0\n#define True 0\n#define pin 0 //GPIO[17]\n\nint main(int argc, char *argv[])\n{\n    int pin_value = False;\n    time_t current_time;\n    int count = 0;\n    \n    if (argc != 4)\n    {\n        printf(\"Usage : %s <ip> <port> <station id> \\n\", argv[0]);\n        return 1;\n    }\n  \n    if (-1 == wiringPiSetup())\n        exit(1);\n\n    // init GPIO[17] to be INPUT port \n    pinMode(pin, INPUT);\n    \n    while (1)\n    {\n        current_time = time(NULL); \n        pin_value = digitalRead(pin);\n        if (True == pin_value)\n        {\n            count ++;\n            printf(\"\\n\\n%s\\n\", ctime(&current_time));\n            printf(\"Work station call help [%d] time\\n\", count);\n            \n            if (0 != socket_clinit_main(argc,argv))\n            {\n                printf(\"cannot call help \\n\");\n                return 1;\n            }\n            sleep(5);\n        }\n    }\n}\n\n```\n\n// sr_clinit.h \n\n```\nextern int socket_clinit_main(int argc, char *argv[]);\n\n```\n\n\n// sr_clinit.c \n\n```\n/*\nFunction : Socket code for clinit\nArthur : SheldonRush Peng\nDate : 2013/7/26\n*/\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"sr_clinit.h\"\n\nint socket_clinit_main(int argc, char *argv[])\n{\n    int sockfd = 0, n = 0;\n    char sendBuff[1024];\n\n    struct sockaddr_in serv_addr;\n\n    if (argc != 4)\n    {\n        printf(\"Usage : %s <ip> <port> <station id>\\n\", argv[0]);\n        return 1;\n    }\n    \n    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n    {\n        printf(\"Error : cannot create a socket\\n\"); \n        return 1;\n    }\n    memset(sendBuff, '\\0', sizeof(sendBuff));\n    \n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(atoi(argv[2]));\n\n    if (inet_pton(AF_INET, argv[1], &serv_addr.sin_addr) <= 0 )\n    {\n        printf(\"%s \\n\" , \" Error : cannot convert text to ip binary\");\n        return 1;\n    }\n\n    if ( connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0 )\n    {\n        printf(\"Error : canot connect server\\n\");\n    }\n\n    printf(\"Clinit: Send data to server, station id = %d\\n\", atoi(argv[3]));\n    snprintf(sendBuff,  sizeof(sendBuff), \"hi Sheldon, I am station id [%d]\\n\", atoi(argv[3]));\n    printf(\"Clint: data is {%s}\\n\", sendBuff);\n    write(sockfd, sendBuff, strlen(sendBuff));\n\n    close(sockfd);\n/*\n    while ( (n = read(sockfd, recvBuff, sizeof(recvBuff)-1)) > 0)\n    {\n        recvBuff[n] =0;\n        if ( fputs(recvBuff, stdout) == EOF)\n        {\n           printf(\"Error : Fputs error \\n\");\n        }\n    }\n\n   if (n < 0)\n   {\n        printf(\"Error : read error \\n\");\n        return 1;\n   }\n*/\n   return 0;\n}\n```\n\n\n","source":"_posts/-Raspberry-Pi-Socket-Programming-and-GPIO.md","raw":"title: \"[Raspberry Pi] Socket Programming and GPIO\"\ndate: 2015-03-01 08:30:29\ncategories: Raspberry Pi\ntags: \n- Socket \n- GPIO\n- Raspberry Pi\ntoc: true\n---\n\n\n## 目的\n\n很久之前, 曾經做過 socket programming在樹梅派的應用. \n也做了個demo影片留在youtube上, 當初只是好玩做做,沒想到有人需要source code.\n我找了一下, 所以就放上來了,有興趣的可以看一下囉，沒意外的話,應該也是一個拼裝車XDDD\n\n這個Demo 影片, 是讓樹梅派當client, 讓laptop 當server 收訊號. 因爲我只有一個樹梅派, 但是我又想模擬mutlit-client的情況, \n所以我在laptop又多起一個task去送訊號給server. \n\n\n## Demo on Youtube\n\nThis  demo tell how to control GPIO and send the data to server.\nAbout socket programming, server can receive the data from multi client.\n\n{% youtube i2Jig5vebBk %}\n\n\n## Source code.\n\n{% link 下載Download http://sheldonrush.github.io/sheldon.is.a.geek/doc/Pi_is_client_PC_is_server.tar.7z %}\n\n___1. server端___\n\n// sr_server.c\n\n```\n/*\nFunction : socket code for server\nArthur : SheldonRush Peng\nDate : 2013/7/26\n*/\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\nint main(int argc, char *argv[])\n{\n    int connfd = 0, n = 0, listenfd = socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in serv_addr;\n\n    char charBuff[1024];\n    char recvBuff[1024];\n    time_t ticks;\n\n    // init the data structure of serv_addr\n    memset(&serv_addr, '0', sizeof(serv_addr));\n    memset(charBuff, '\\0', sizeof(charBuff));\n    memset(recvBuff, '\\0', sizeof(recvBuff));\n\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    serv_addr.sin_port = htons(8998);\n\n    // assign the scket port to socket\n    bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));\n\n    listen(listenfd, 20);\n\n    while (1)\n    {\n        connfd = accept(listenfd, (struct sockaddr*)NULL, NULL);\n   \n        printf(\"%s %d \\n\", \"server: connfd is\", connfd);\n        ticks = time(NULL);\n        snprintf(charBuff, sizeof(charBuff), \"%s\\n\", ctime(&ticks));\n        printf(\"server: %s\\n\", charBuff);\n        \n        while ( (n = read(connfd, recvBuff, sizeof(recvBuff)-1)) > 0)\n        {\n           recvBuff[n] = 0;\n           printf(\"server: read %d bytes \\n\", n);\n           printf(\"server: EOF = %d \\n\", EOF);\n           if ( fputs(recvBuff, stdout) == EOF)\n           {\n                printf(\"Error : Fputs error \\n\");\n           }\n        }\n\n        if (n < 0)\n        {\n            printf(\"Error : read errpr \\n\");\n        }\n       //  write(connfd, sendBuff, strlen(sendBuff));\n        close(connfd);\n        sleep(1); \n    }\n}\n\n```\n\n___2. Clinet 端___\n\n// main.c\n\n```\n/*\nFunction : Detect whether GPIO[17] is high or low\nArthur : Sheldon RUsh Peng\nDate : 2013/7/27\n*/\n\n#include <wiringPi.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n#include \"sr_clinit.h\" \n\n\n#define False 0\n#define True 0\n#define pin 0 //GPIO[17]\n\nint main(int argc, char *argv[])\n{\n    int pin_value = False;\n    time_t current_time;\n    int count = 0;\n    \n    if (argc != 4)\n    {\n        printf(\"Usage : %s <ip> <port> <station id> \\n\", argv[0]);\n        return 1;\n    }\n  \n    if (-1 == wiringPiSetup())\n        exit(1);\n\n    // init GPIO[17] to be INPUT port \n    pinMode(pin, INPUT);\n    \n    while (1)\n    {\n        current_time = time(NULL); \n        pin_value = digitalRead(pin);\n        if (True == pin_value)\n        {\n            count ++;\n            printf(\"\\n\\n%s\\n\", ctime(&current_time));\n            printf(\"Work station call help [%d] time\\n\", count);\n            \n            if (0 != socket_clinit_main(argc,argv))\n            {\n                printf(\"cannot call help \\n\");\n                return 1;\n            }\n            sleep(5);\n        }\n    }\n}\n\n```\n\n// sr_clinit.h \n\n```\nextern int socket_clinit_main(int argc, char *argv[]);\n\n```\n\n\n// sr_clinit.c \n\n```\n/*\nFunction : Socket code for clinit\nArthur : SheldonRush Peng\nDate : 2013/7/26\n*/\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"sr_clinit.h\"\n\nint socket_clinit_main(int argc, char *argv[])\n{\n    int sockfd = 0, n = 0;\n    char sendBuff[1024];\n\n    struct sockaddr_in serv_addr;\n\n    if (argc != 4)\n    {\n        printf(\"Usage : %s <ip> <port> <station id>\\n\", argv[0]);\n        return 1;\n    }\n    \n    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n    {\n        printf(\"Error : cannot create a socket\\n\"); \n        return 1;\n    }\n    memset(sendBuff, '\\0', sizeof(sendBuff));\n    \n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(atoi(argv[2]));\n\n    if (inet_pton(AF_INET, argv[1], &serv_addr.sin_addr) <= 0 )\n    {\n        printf(\"%s \\n\" , \" Error : cannot convert text to ip binary\");\n        return 1;\n    }\n\n    if ( connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0 )\n    {\n        printf(\"Error : canot connect server\\n\");\n    }\n\n    printf(\"Clinit: Send data to server, station id = %d\\n\", atoi(argv[3]));\n    snprintf(sendBuff,  sizeof(sendBuff), \"hi Sheldon, I am station id [%d]\\n\", atoi(argv[3]));\n    printf(\"Clint: data is {%s}\\n\", sendBuff);\n    write(sockfd, sendBuff, strlen(sendBuff));\n\n    close(sockfd);\n/*\n    while ( (n = read(sockfd, recvBuff, sizeof(recvBuff)-1)) > 0)\n    {\n        recvBuff[n] =0;\n        if ( fputs(recvBuff, stdout) == EOF)\n        {\n           printf(\"Error : Fputs error \\n\");\n        }\n    }\n\n   if (n < 0)\n   {\n        printf(\"Error : read error \\n\");\n        return 1;\n   }\n*/\n   return 0;\n}\n```\n\n\n","slug":"-Raspberry-Pi-Socket-Programming-and-GPIO","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp29i004p35ggwt1ozdhs"},{"title":"[Raspberry Pi] How to get the root","date":"2015-02-25T14:08:00.000Z","toc":true,"_content":"\n___How to get the root on Raspberry Pi  ?  ___\n\nJust use the following command.\n\n``` \nsudo su\n```\n","source":"_posts/-Raspberry-Pi-How-to-get-the-root.md","raw":"title: \"[Raspberry Pi] How to get the root\"\ndate: 2015-02-25 22:08:00\ncategories: Raspberry Pi\ntags: \n- Raspberry Pi\n- root \ntoc: true\n---\n\n___How to get the root on Raspberry Pi  ?  ___\n\nJust use the following command.\n\n``` \nsudo su\n```\n","slug":"-Raspberry-Pi-How-to-get-the-root","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp29m004w35gg3dou0buj"},{"title":"[Raspberry Pi] Demod_Video","date":"2015-03-01T00:01:13.000Z","toc":true,"_content":"\n## 以下是我以前所做的demo 影片, 由於之前有換過站台, 大部分東西沒留下來QQ, 只剩下youtube的影片, 列出來留作紀念XD...\n\n___1. [Raspberry Pi] Connedted with PCA9505 I2C IO Expander ___\n\n{% youtube vy-eMS_tIrY %}\n\n\n___2. [Raspberry Pi] Face Detection by OpenCV ___\n{% youtube g7UCIlbSUdY %}\n\n___3. [Raspberry Pi] Socket Programming and GPIO ___\n\nThis  demon tell how to control GPIO and send the data to server.\nAbout socket programming, server can receive the data from multi client.\n\n{% youtube i2Jig5vebBk %}\n\n___4. [Raspberry Pi ] [Cam Module] ___\n\n\n{% youtube dSsiKKEKirw %}\n\n\n___5.[Raspberry Pi] Video Codec of OpenMAX ___\n\n{% youtube m483eicpwlI%}\n\n\n___6. [Raspberry Demo] Control DHT22 and update data to google ___\n\n{% youtube BnvaexbA8qU %}\n","source":"_posts/-Raspberry-Pi-Demod-Video.md","raw":"title: \"[Raspberry Pi] Demod_Video\"\ndate: 2015-03-01 08:01:13\ncategories: Raspberry Pi\ntags: \n- Raspberry Pi\ntoc: true\n---\n\n## 以下是我以前所做的demo 影片, 由於之前有換過站台, 大部分東西沒留下來QQ, 只剩下youtube的影片, 列出來留作紀念XD...\n\n___1. [Raspberry Pi] Connedted with PCA9505 I2C IO Expander ___\n\n{% youtube vy-eMS_tIrY %}\n\n\n___2. [Raspberry Pi] Face Detection by OpenCV ___\n{% youtube g7UCIlbSUdY %}\n\n___3. [Raspberry Pi] Socket Programming and GPIO ___\n\nThis  demon tell how to control GPIO and send the data to server.\nAbout socket programming, server can receive the data from multi client.\n\n{% youtube i2Jig5vebBk %}\n\n___4. [Raspberry Pi ] [Cam Module] ___\n\n\n{% youtube dSsiKKEKirw %}\n\n\n___5.[Raspberry Pi] Video Codec of OpenMAX ___\n\n{% youtube m483eicpwlI%}\n\n\n___6. [Raspberry Demo] Control DHT22 and update data to google ___\n\n{% youtube BnvaexbA8qU %}\n","slug":"-Raspberry-Pi-Demod-Video","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp29r005135ggjhw6pfnl"},{"title":"[Raspberry Pi][Cam Module] 行車記錄器","date":"2015-02-28T23:19:58.000Z","toc":true,"_content":"\n## 目的\n\n自從桃園一場大水以後, \n\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/11245.jpg %}\n\n我的小佛浮起來了,行車記錄器也跟着消失了...\n最近一直聽到有關行車糾紛,心理怕怕,但是又不想花錢買行車記錄器.\n所以想說用免錢的PI camera module 來玩玩.\n\n## 方法\n\n___1.製作免費的case,在[上一篇文章](http://sheldonrush.github.io/sheldon.is.a.geek/2015/02/26/-Raspberry-Pi-%E8%A3%BD%E4%BD%9CPI%E7%9A%84%E8%A1%A3%E6%9C%8D-Case/)中, 可以參考一下. ___\n\n\n___2. 我主要[參考這篇](http://dreamgreenhouse.com/projects/2013/picar/) ___\n\n這篇功能超級多...但是我現在其實只要錄制的功能, 所以我把大部分的東西都拔掉了.\n假如想要玩更高階的行車記錄器,可以仔細研究聯結.\n\n```\n#!/bin/sh\n# Purpose : Just test for recording video on cam module of raspberry pi\n# Author : Sheldon\necho `date +%D` \", Start the test for cam module !!\"\n\ncd /home/pi\n# set limit of rolling videos to 16GB\nlimit=4000000\n\nwhile [ true ]; do \n        # Video disk space used\n        used=$(du Video | tail -1 | awk '{print $1}')\n        #echo `date +%s` \"U Video\" $used\n        \n        # Free up disk space if needed\n        while [ $limit -le $used ]\n        do\n                remove=$(ls -1tr Video | grep .h264 | head -n 1)\n                echo `date +%D` \"-\" $remove\n                rm Video/$remove\n                # Calculate disk space used\n                used=$(du Video | tail -1 | awk '{print $1}')\n        done\n\n        # New file name\n        current=$(date +\"%Y_%m_%d_%H:%M:%S.h264\")\n        echo `date +%s` \"+\" $current\n\n        # Capture a 5 minute segment of video\n        raspivid -n -b 9000000 -w 1280 -h 720 -o Video/$current -t 300000\ndone\n\n```\n\n\n## 成果\n\nRaspberry Pi 放反了,..主要是來測試cam module, 基本功能看起來work...XDD\n\n{% youtube dSsiKKEKirw %}\n\n","source":"_posts/-Raspberry-Pi-Cam-Module-行車記錄器.md","raw":"title: \"[Raspberry Pi][Cam Module] 行車記錄器\"\ndate: 2015-03-01 07:19:58\ncategories: Raspberry Pi \ntags: \n- Cam Module\n- Raspberry Pi\ntoc: true\n---\n\n## 目的\n\n自從桃園一場大水以後, \n\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/11245.jpg %}\n\n我的小佛浮起來了,行車記錄器也跟着消失了...\n最近一直聽到有關行車糾紛,心理怕怕,但是又不想花錢買行車記錄器.\n所以想說用免錢的PI camera module 來玩玩.\n\n## 方法\n\n___1.製作免費的case,在[上一篇文章](http://sheldonrush.github.io/sheldon.is.a.geek/2015/02/26/-Raspberry-Pi-%E8%A3%BD%E4%BD%9CPI%E7%9A%84%E8%A1%A3%E6%9C%8D-Case/)中, 可以參考一下. ___\n\n\n___2. 我主要[參考這篇](http://dreamgreenhouse.com/projects/2013/picar/) ___\n\n這篇功能超級多...但是我現在其實只要錄制的功能, 所以我把大部分的東西都拔掉了.\n假如想要玩更高階的行車記錄器,可以仔細研究聯結.\n\n```\n#!/bin/sh\n# Purpose : Just test for recording video on cam module of raspberry pi\n# Author : Sheldon\necho `date +%D` \", Start the test for cam module !!\"\n\ncd /home/pi\n# set limit of rolling videos to 16GB\nlimit=4000000\n\nwhile [ true ]; do \n        # Video disk space used\n        used=$(du Video | tail -1 | awk '{print $1}')\n        #echo `date +%s` \"U Video\" $used\n        \n        # Free up disk space if needed\n        while [ $limit -le $used ]\n        do\n                remove=$(ls -1tr Video | grep .h264 | head -n 1)\n                echo `date +%D` \"-\" $remove\n                rm Video/$remove\n                # Calculate disk space used\n                used=$(du Video | tail -1 | awk '{print $1}')\n        done\n\n        # New file name\n        current=$(date +\"%Y_%m_%d_%H:%M:%S.h264\")\n        echo `date +%s` \"+\" $current\n\n        # Capture a 5 minute segment of video\n        raspivid -n -b 9000000 -w 1280 -h 720 -o Video/$current -t 300000\ndone\n\n```\n\n\n## 成果\n\nRaspberry Pi 放反了,..主要是來測試cam module, 基本功能看起來work...XDD\n\n{% youtube dSsiKKEKirw %}\n\n","slug":"-Raspberry-Pi-Cam-Module-行車記錄器","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp29v005435ggayijbizs"},{"title":"[QT][GUI][Ubuntu] Hello World !","date":"2015-03-15T08:38:42.000Z","toc":true,"_content":"\n## 目的\n\n最近在學習用QT這個third party 來寫GUI界面.\n\n之前有用過 QT creator 這個IDE， 用拖曳的方式產生GUI 的component\n\n用起來挺順手的. 但是整個project 怎麼生出來的, .pro 檔市幹嗎用的, qmke 和make有什麼差異\n\n完全不清楚在做什麼. 所以今天花了一點時間, 查了要如何透過command line的方式\n\n一步一步的靠近. [我參考這篇](http://www.wikihow.com/Create-Your-First-Qt-Program-on-Ubuntu-Linux)\n\n## Sample Code\n\n___qt_demo.cpp___\n\n```\n#include <QApplication>\n#include <QLabel>\n#include <QWidget>\n\nint main(int argc, char* argv)\n{\n  QApplication app(argc, argv);\n  QLabel hello(<center>This is my first QT hello world!!</center>);\n  hello.setWindowTitle(\"My First Qt Program\");\n  hello.resize(400,400);\n  hello.show();\n  return app.exec();\n}\n\n```\n\n## How to compile QT program by command line \n\n___1. copy qt_demo.cpp to your directory.___\n\n```\n  cp qt_demo.cpp [your directory]\n```\n\n___2. generate the .pro file for QT project setting___\n\n```\n  qmake -project\n```\n\n___3. 將你程式需要的QT module, 放到 .pro file (前一步, 產生出來的)___\n\n底下是將 core gui widgets 這三個加入要用的module list 裡面. \n當 compiler 要做compile/link 的時候, 才會找得到.\n\n```\n######################################################################\n# Automatically generated by qmake (3.0) ?? 3? 15 16:33:14 2015\n######################################################################\n\nTEMPLATE = app\nTARGET = qt_tutorial\nINCLUDEPATH += .\n\n\nQT += core gui\nQT += widgets\n\n# Input\nSOURCES += qt_demo.cpp\n\n```\n\n___4.利用qmake 指令, 將make 產生出來___\n\n```\nqmake\n```\n\n你會發現, 你現在這個folder 底下, 會產生一個make 檔\n\n___5. Compile___\n\n就直接下 make 囉!!!\n就會產生一個執行檔.\n\n___6. 成果___\n\n```\n./qt_tutorial\n```\n\n這樣就產生了hello world 了.., 假如要省事的話, \n\n還是用qt creator 吧... kerker\n\n\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/qt_tutoral.png%}\n\n\n\n\n","source":"_posts/-QT-GUI-Hello-World.md","raw":"title: \"[QT][GUI][Ubuntu] Hello World !\"\ndate: 2015-03-15 16:38:42\ncategories: \n- QT\ntags:\n- QT\n- GUI\n- compiler\n- Ubuntu\ntoc: true\n---\n\n## 目的\n\n最近在學習用QT這個third party 來寫GUI界面.\n\n之前有用過 QT creator 這個IDE， 用拖曳的方式產生GUI 的component\n\n用起來挺順手的. 但是整個project 怎麼生出來的, .pro 檔市幹嗎用的, qmke 和make有什麼差異\n\n完全不清楚在做什麼. 所以今天花了一點時間, 查了要如何透過command line的方式\n\n一步一步的靠近. [我參考這篇](http://www.wikihow.com/Create-Your-First-Qt-Program-on-Ubuntu-Linux)\n\n## Sample Code\n\n___qt_demo.cpp___\n\n```\n#include <QApplication>\n#include <QLabel>\n#include <QWidget>\n\nint main(int argc, char* argv)\n{\n  QApplication app(argc, argv);\n  QLabel hello(<center>This is my first QT hello world!!</center>);\n  hello.setWindowTitle(\"My First Qt Program\");\n  hello.resize(400,400);\n  hello.show();\n  return app.exec();\n}\n\n```\n\n## How to compile QT program by command line \n\n___1. copy qt_demo.cpp to your directory.___\n\n```\n  cp qt_demo.cpp [your directory]\n```\n\n___2. generate the .pro file for QT project setting___\n\n```\n  qmake -project\n```\n\n___3. 將你程式需要的QT module, 放到 .pro file (前一步, 產生出來的)___\n\n底下是將 core gui widgets 這三個加入要用的module list 裡面. \n當 compiler 要做compile/link 的時候, 才會找得到.\n\n```\n######################################################################\n# Automatically generated by qmake (3.0) ?? 3? 15 16:33:14 2015\n######################################################################\n\nTEMPLATE = app\nTARGET = qt_tutorial\nINCLUDEPATH += .\n\n\nQT += core gui\nQT += widgets\n\n# Input\nSOURCES += qt_demo.cpp\n\n```\n\n___4.利用qmake 指令, 將make 產生出來___\n\n```\nqmake\n```\n\n你會發現, 你現在這個folder 底下, 會產生一個make 檔\n\n___5. Compile___\n\n就直接下 make 囉!!!\n就會產生一個執行檔.\n\n___6. 成果___\n\n```\n./qt_tutorial\n```\n\n這樣就產生了hello world 了.., 假如要省事的話, \n\n還是用qt creator 吧... kerker\n\n\n{% image http://sheldonrush.github.io/sheldon.is.a.geek/imgs/qt_tutoral.png%}\n\n\n\n\n","slug":"-QT-GUI-Hello-World","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp2a1005935gg0t8poq02"},{"title":"[Pointer] Simple concept","date":"2015-01-29T15:10:14.000Z","toc":true,"_content":"\n# (&\\*ptr) 等於 (\\*&ptr) ??\n\n最近看到有人在問這個問題, 所以就簡單分析一下這個概念. \n\n```\nint a = 10, *ptr = &a;\n&*ptr 等於 &(*ptr) ??\n// 假如 a 所在的位置是0x7fffffffd9e4\n// 假如 ptr 的位置是0x7fffffffd9e8\n```\n因式分解 \n\n___&*ptr___\n1. *ptr  ->  這個指的是pointer ptr 所指向位置的值, 也就是10.\n2. &(*ptr) = &(a) -> 也就是a的位置 0x7fffffffd9e4\n\n___*&ptr___\n\n1. &ptr -> pointer ptr 的位置0x7fffffffd9e8\n2. *&ptr = *(&ptr) = *(0x7fffffffd9e8) = (將這個位置的值取出來) = &a = 0x7fffffffd9e4\n\n因此\n```\n&*ptr 等於 *&ptr \n```\n\n\n","source":"_posts/-Pointer-Simple-concept.md","raw":"title: \"[Pointer] Simple concept\"\ndate: 2015-01-29 23:10:14\ncategories: \n- pointer\ntags:\n- C\n- pointer\ntoc: true\n---\n\n# (&\\*ptr) 等於 (\\*&ptr) ??\n\n最近看到有人在問這個問題, 所以就簡單分析一下這個概念. \n\n```\nint a = 10, *ptr = &a;\n&*ptr 等於 &(*ptr) ??\n// 假如 a 所在的位置是0x7fffffffd9e4\n// 假如 ptr 的位置是0x7fffffffd9e8\n```\n因式分解 \n\n___&*ptr___\n1. *ptr  ->  這個指的是pointer ptr 所指向位置的值, 也就是10.\n2. &(*ptr) = &(a) -> 也就是a的位置 0x7fffffffd9e4\n\n___*&ptr___\n\n1. &ptr -> pointer ptr 的位置0x7fffffffd9e8\n2. *&ptr = *(&ptr) = *(0x7fffffffd9e8) = (將這個位置的值取出來) = &a = 0x7fffffffd9e4\n\n因此\n```\n&*ptr 等於 *&ptr \n```\n\n\n","slug":"-Pointer-Simple-concept","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp2aa005j35ggb6dksty0"},{"title":"[Network] fping的用法","date":"2015-02-25T10:04:09.000Z","toc":true,"_content":"\n# 目的\n\n之前遇到了一個問題, 假如我現在在一個封閉的區域網路內, \n我要如何得知在這個網域裏面, 有存在哪些其他電腦. \n\n\n# 做法\n\n這時後就可以用ubuntu 裏面的fpring 來解決這個問題. \n\n___1.先利用ifconfig 來觀察, 你現在所在的網域.___\n\n{% img http://sheldonrush.github.io/sheldon.is.a.geek/imgs/ifconfig.jpeg %}\n\n___2. 再利用fping 來觀察其他電腦IP___\n\n{% img http://sheldonrush.github.io/sheldon.is.a.geek/imgs/fping.jpeg %}\n\n___-g addr/mask___\n\n   Generate a target list from a supplied IP netmask, or a starting and ending IP.  Specify the netmask or start/end in the targets\n   portion of the command line. If a network with netmask is given, the network and broadcast addresses will be excluded. ex. To ping the\n   network 192.168.1.0/24, the specified command line could look like either:\n\n   fping -g 192.168.1.0/24 or fping -g 192.168.1.1 192.168.1.254\n\n","source":"_posts/-Network-fping的用法.md","raw":"title: \"[Network] fping的用法\"\ndate: 2015-02-25 18:04:09\ncategories: \n- Network\ntags: \n- network \n- ubuntu\ntoc: true\n---\n\n# 目的\n\n之前遇到了一個問題, 假如我現在在一個封閉的區域網路內, \n我要如何得知在這個網域裏面, 有存在哪些其他電腦. \n\n\n# 做法\n\n這時後就可以用ubuntu 裏面的fpring 來解決這個問題. \n\n___1.先利用ifconfig 來觀察, 你現在所在的網域.___\n\n{% img http://sheldonrush.github.io/sheldon.is.a.geek/imgs/ifconfig.jpeg %}\n\n___2. 再利用fping 來觀察其他電腦IP___\n\n{% img http://sheldonrush.github.io/sheldon.is.a.geek/imgs/fping.jpeg %}\n\n___-g addr/mask___\n\n   Generate a target list from a supplied IP netmask, or a starting and ending IP.  Specify the netmask or start/end in the targets\n   portion of the command line. If a network with netmask is given, the network and broadcast addresses will be excluded. ex. To ping the\n   network 192.168.1.0/24, the specified command line could look like either:\n\n   fping -g 192.168.1.0/24 or fping -g 192.168.1.1 192.168.1.254\n\n","slug":"-Network-fping的用法","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp2ag005p35gg5g6icnjx"},{"title":"[GDB] 基本指令","date":"2015-02-04T00:22:05.000Z","toc":true,"_content":"\nGDB 是一個很好的除錯指令, 這給了一個方法, 去快速知道你的程式發生了闍麼問題. \n\n而不要一直使用___printf___去做debug. gdb 可以用在 server/client 的online debug 模式,\n\n或是僅僅offline 的觀察coredump. \n\n使用gdb 除錯, 你必須在編code的時候, 在gcc 的compiler option 多加___-g___\n\n底下是我最近練習到的gdb指令.\n\n```\n(gdb) r     \\\\ 開始執行程式\n(gdb) c     \\\\ 假如你現在停在breakpoint, 接着執行程式（continue） \n(gdb) b function  \\\\ 設定中斷點\n(gdb) b file:line \\\\ 設定中斷點的另一個方法\n(gdb) layout src  \\\\ 將現在程式跑到的位置,  跟src code做一個mapping.\n(gdb) stack \\\\ 觀察現在的stack\n(gdb) info all-registers \\\\ 觀察現在所有的registers\n(gdb) p $r0      \\\\ 讀取現在的cpu $r0 registers\n(gdb) threads    \\\\ 觀察program 裏面, 所有的thread 運行的情況卒. (有點像ps)\n(gdb) s          \\\\ 單步執行, 遇到function的時候, 進入function的stack. \n(gdb) n          \\\\ 單步執行, 遇到function的時候, 不進入function的stack\n(gdb) return     \\\\ 離開現在的fucntion, 返回calling\n(gdb) jump line  \\\\ 將PC 指向程式的line的位置\n(gdb) info locals \\\\ 列出現在的local變數\n(gdb) info args \\\\列出引數\n(gdb) bt \\\\ bracktrace\n\n```\n","source":"_posts/-GDB-基本指令.md","raw":"title: \"[GDB] 基本指令\"\ndate: 2015-02-04 08:22:05\ncategories: \n- GDB\ntags:\n- GDB\ntoc: true\n---\n\nGDB 是一個很好的除錯指令, 這給了一個方法, 去快速知道你的程式發生了闍麼問題. \n\n而不要一直使用___printf___去做debug. gdb 可以用在 server/client 的online debug 模式,\n\n或是僅僅offline 的觀察coredump. \n\n使用gdb 除錯, 你必須在編code的時候, 在gcc 的compiler option 多加___-g___\n\n底下是我最近練習到的gdb指令.\n\n```\n(gdb) r     \\\\ 開始執行程式\n(gdb) c     \\\\ 假如你現在停在breakpoint, 接着執行程式（continue） \n(gdb) b function  \\\\ 設定中斷點\n(gdb) b file:line \\\\ 設定中斷點的另一個方法\n(gdb) layout src  \\\\ 將現在程式跑到的位置,  跟src code做一個mapping.\n(gdb) stack \\\\ 觀察現在的stack\n(gdb) info all-registers \\\\ 觀察現在所有的registers\n(gdb) p $r0      \\\\ 讀取現在的cpu $r0 registers\n(gdb) threads    \\\\ 觀察program 裏面, 所有的thread 運行的情況卒. (有點像ps)\n(gdb) s          \\\\ 單步執行, 遇到function的時候, 進入function的stack. \n(gdb) n          \\\\ 單步執行, 遇到function的時候, 不進入function的stack\n(gdb) return     \\\\ 離開現在的fucntion, 返回calling\n(gdb) jump line  \\\\ 將PC 指向程式的line的位置\n(gdb) info locals \\\\ 列出現在的local變數\n(gdb) info args \\\\列出引數\n(gdb) bt \\\\ bracktrace\n\n```\n","slug":"-GDB-基本指令","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp2at005v35ggkk00z120"},{"title":"[GCC][MACRO-LOG]","date":"2015-01-29T00:21:34.000Z","toc":true,"_content":"\n以前一直是用printf來debug, 每次都寫差不多格式的log,\n所以去查了一下, 在巨集裏面要如何把default foramt 添加上去,\n是時後要學點GDB了.... XD.\n\n```\n#define DBG(fmt, vars...) printf(\"[%s][%d] \"fmt, __FUNCTION__, __LINE__, ##vars)\n\n```\n","source":"_posts/-GCC-MACRO-LOG.md","raw":"title: \"[GCC][MACRO-LOG]\"\ndate: 2015-01-29 08:21:34\ncategories: GCC\ntags:\n- GCC\ntoc: true\n---\n\n以前一直是用printf來debug, 每次都寫差不多格式的log,\n所以去查了一下, 在巨集裏面要如何把default foramt 添加上去,\n是時後要學點GDB了.... XD.\n\n```\n#define DBG(fmt, vars...) printf(\"[%s][%d] \"fmt, __FUNCTION__, __LINE__, ##vars)\n\n```\n","slug":"-GCC-MACRO-LOG","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp2b1006035ggpzh9fcl8"},{"title":"[C++][Virtual Function/Inherit] My Animal World","date":"2015-03-09T17:22:34.000Z","toc":true,"_content":"\n## 目的\n最近爲了學習QT, 所以重新練習C++的程式, C++的精華就在於封裝、繼承、多型. \n我寫了一個 My Animal World 來練習這些觀念. 這支程式也非常單純, \n可以來記錄你養寵物的體重. 以及每天都喂他飼料的話, \n他們的體重會變成幾公斤. \n\n## 練習\n\n___1. main.h___\n\n我在main.h 裏面放了base class 以及 extended class. \n\n分別帶表了動物和貓以及鼠鼠的屬性.\n\n要注意底下的一些重點. \n\n1. overload 結構子\n2. virutal function的用法. \n3. 我把實作都放到.c 黨裏面了\n\n```\n//***********************************\n//**********************************\n// Arthur : Sheldon Peng\n// Date : 2015.3.9\n// Purpose : Try the understand the virtual function in C++\n//*********************************\n//**********************************\n\n#define MAX_ANIMAL_NUMBER 2\nenum {\n  BIG_CAT,\n  SMALL_NAUGHTY,\n  MAX_ANIMAL = MAX_ANIMAL_NUMBER,\n};\n\nclass Animal\n{\n  public :\n    Animal();\n    Animal(double,double);\n    void feed(int);\n    double get_weight(void);\n    double get_increase_per_day(void);\n    virtual void show_name(void);\n\n  private :\n    double weight;\n    double increase_per_day;\n};\n\nclass Cat: public Animal\n{\n  public :\n    Cat(double,double);\n    virtual void show_name(void);\n};\n\nclass Mouse: public Animal\n{\n  public :\n    Mouse(double,double);\n    virtual void show_name(void);\n};\n\n\n```\n\n___2.1 main.c___\n\n2.1 的部分, 我放了class 成員的實作, 很間單的體重以及增重的vlaue.\n\n這裡很妙的是假如你 base和extended 有相同的member function (show_name)的話, \n\n你又想使用extended class 的member function (show_name), 你可以在member function 加上virtual\n\n假如你只想用base class的member function, 就把virtual 去除掉吧.\n\n底下這個範例是留下virtual, 畢竟我想要每個動物東有自己的名字XDDD\n\n我這邊還多定義了一個 pointer array 是放所有的動物的pointer. \n\n這樣比較好操作. 要注意, 宣告array的member , 我是用 base class的poiner (重要)\n\n這樣就非常方便了. 我就可以利用base class pointer 來操作所有extend class. 讃拉！！\n\n\n```\n//***********************************\n//**********************************\n// Arthur : Sheldon Peng\n// Date : 2015.3.9\n// Purpose : Try the understand the virtual function in C++\n//*********************************\n//**********************************\n\n#include <iostream>\n#include \"main.h\"\n\nusing namespace std;\n\nAnimal* animal_list[MAX_ANIMAL_NUMBER];\n\nAnimal::Animal()\n{\n  cout << \"This is First Animal constructor\" << endl; \n}\n\nAnimal::Animal(double weight_value, double increase_per_day_value)\n{\n  weight = weight_value;\n  increase_per_day = increase_per_day_value ; \n  cout << \"This is Second Animal constructor\" << endl; \n}\n\nvoid Animal::feed(int food)\n{\n  for (int i=0;i<food;i++)\n  {\n    weight += increase_per_day;\n  }\n}\n\ndouble Animal::get_weight(void)\n{\n  return weight;\n}\n\ndouble Animal::get_increase_per_day(void)\n{\n  return increase_per_day;\n}\n\nvoid Animal::show_name(void)\n{\n  cout << \"Hello, I don't have name, please give me a name .\" << endl; \n}\n\nCat::Cat(double a,double b):Animal(a, b) \n{\n  cout << \"This is Cat's constructor\" << endl;\n}\n\nvoid Cat::show_name(void)\n{\n  cout << \"Hello, My name is Lazy Cat .\" << endl;\n}\n\nMouse::Mouse(double a,double b):Animal(a, b) \n{\n  cout << \"This is Mouse's constructor .\" <<endl;\n}\n\nvoid Mouse::show_name(void)\n{\n  cout << \"Hello, My name is Sweet mouse .\" <<endl;\n}\n\n```\n\n___2.2 main.c (main function)___\n\n這是程式主題. 一開始會先init cat/mouse, 然後就進去while loop\n\n等待主人詢問是否要餵食你的可愛動物 XDDD . \n\n\n```\nint main(void)\n{\n  int type;\n  int food_value;\n\n  Animal* animal_ptr;\n  Cat cat(7,0.05);\n  Mouse mouse(0.05,0.001);\n  animal_list[BIG_CAT] = &cat; \n  animal_list[SMALL_NAUGHTY] = &mouse;\n\n  cout << \" Welcom to my animal house \" << endl;\n\n  do  \n  {\n    cout <<\" please chose the animal you want to feed \" << endl;\n    cout <<\" [0] for cat, [1] for mouse, [2] check the weight of all cute animals !!\" << endl;\n    cin >> type ;\n\n    if (type == 0)\n    {\n       animal_ptr = &cat;\n       cout << \" 喵喵 !!!\" << endl;\n       animal_ptr->show_name();\n    }\n    else if (type == 1)\n    {\n       animal_ptr = &mouse;\n       cout << \"唧唧 !!!\" << endl;\n       animal_ptr->show_name();\n    }\n    else if (type == 2)\n    {\n      cout << \"======體重表=======\"<<endl;\n      \n      for (int i=0; i< MAX_ANIMAL_NUMBER; i++)\n      {\n        animal_ptr = animal_list[i];\n        animal_ptr->show_name();\n        cout << \"我的重量是 \" << animal_ptr->get_weight()<<\"(kg)\" <<endl;\n      }\n      cout << \"===================\"<<endl;\n      continue;\n    }\n    else \n    {\n       cout << \" wow, qq, We don't have your animal !!\" <<endl;\n       continue; \n    }\n\n    cout << \" How many days you want to feed ?? \" << endl;\n    cin >> food_value; \n    animal_ptr->feed(food_value);\n\n  }while(1);\n\n  return 0;\n}\n\n```\n\n\n","source":"_posts/-C-Virtual-Function-Inherit-My-Animal-World.md","raw":"title: \"[C++][Virtual Function/Inherit] My Animal World\"\ndate: 2015-03-10 01:22:34\ncategories: C++\ntags:\n- Virtual Function\n- C++\n- Inherit\n- Dynamical Binding\ntoc: true\n---\n\n## 目的\n最近爲了學習QT, 所以重新練習C++的程式, C++的精華就在於封裝、繼承、多型. \n我寫了一個 My Animal World 來練習這些觀念. 這支程式也非常單純, \n可以來記錄你養寵物的體重. 以及每天都喂他飼料的話, \n他們的體重會變成幾公斤. \n\n## 練習\n\n___1. main.h___\n\n我在main.h 裏面放了base class 以及 extended class. \n\n分別帶表了動物和貓以及鼠鼠的屬性.\n\n要注意底下的一些重點. \n\n1. overload 結構子\n2. virutal function的用法. \n3. 我把實作都放到.c 黨裏面了\n\n```\n//***********************************\n//**********************************\n// Arthur : Sheldon Peng\n// Date : 2015.3.9\n// Purpose : Try the understand the virtual function in C++\n//*********************************\n//**********************************\n\n#define MAX_ANIMAL_NUMBER 2\nenum {\n  BIG_CAT,\n  SMALL_NAUGHTY,\n  MAX_ANIMAL = MAX_ANIMAL_NUMBER,\n};\n\nclass Animal\n{\n  public :\n    Animal();\n    Animal(double,double);\n    void feed(int);\n    double get_weight(void);\n    double get_increase_per_day(void);\n    virtual void show_name(void);\n\n  private :\n    double weight;\n    double increase_per_day;\n};\n\nclass Cat: public Animal\n{\n  public :\n    Cat(double,double);\n    virtual void show_name(void);\n};\n\nclass Mouse: public Animal\n{\n  public :\n    Mouse(double,double);\n    virtual void show_name(void);\n};\n\n\n```\n\n___2.1 main.c___\n\n2.1 的部分, 我放了class 成員的實作, 很間單的體重以及增重的vlaue.\n\n這裡很妙的是假如你 base和extended 有相同的member function (show_name)的話, \n\n你又想使用extended class 的member function (show_name), 你可以在member function 加上virtual\n\n假如你只想用base class的member function, 就把virtual 去除掉吧.\n\n底下這個範例是留下virtual, 畢竟我想要每個動物東有自己的名字XDDD\n\n我這邊還多定義了一個 pointer array 是放所有的動物的pointer. \n\n這樣比較好操作. 要注意, 宣告array的member , 我是用 base class的poiner (重要)\n\n這樣就非常方便了. 我就可以利用base class pointer 來操作所有extend class. 讃拉！！\n\n\n```\n//***********************************\n//**********************************\n// Arthur : Sheldon Peng\n// Date : 2015.3.9\n// Purpose : Try the understand the virtual function in C++\n//*********************************\n//**********************************\n\n#include <iostream>\n#include \"main.h\"\n\nusing namespace std;\n\nAnimal* animal_list[MAX_ANIMAL_NUMBER];\n\nAnimal::Animal()\n{\n  cout << \"This is First Animal constructor\" << endl; \n}\n\nAnimal::Animal(double weight_value, double increase_per_day_value)\n{\n  weight = weight_value;\n  increase_per_day = increase_per_day_value ; \n  cout << \"This is Second Animal constructor\" << endl; \n}\n\nvoid Animal::feed(int food)\n{\n  for (int i=0;i<food;i++)\n  {\n    weight += increase_per_day;\n  }\n}\n\ndouble Animal::get_weight(void)\n{\n  return weight;\n}\n\ndouble Animal::get_increase_per_day(void)\n{\n  return increase_per_day;\n}\n\nvoid Animal::show_name(void)\n{\n  cout << \"Hello, I don't have name, please give me a name .\" << endl; \n}\n\nCat::Cat(double a,double b):Animal(a, b) \n{\n  cout << \"This is Cat's constructor\" << endl;\n}\n\nvoid Cat::show_name(void)\n{\n  cout << \"Hello, My name is Lazy Cat .\" << endl;\n}\n\nMouse::Mouse(double a,double b):Animal(a, b) \n{\n  cout << \"This is Mouse's constructor .\" <<endl;\n}\n\nvoid Mouse::show_name(void)\n{\n  cout << \"Hello, My name is Sweet mouse .\" <<endl;\n}\n\n```\n\n___2.2 main.c (main function)___\n\n這是程式主題. 一開始會先init cat/mouse, 然後就進去while loop\n\n等待主人詢問是否要餵食你的可愛動物 XDDD . \n\n\n```\nint main(void)\n{\n  int type;\n  int food_value;\n\n  Animal* animal_ptr;\n  Cat cat(7,0.05);\n  Mouse mouse(0.05,0.001);\n  animal_list[BIG_CAT] = &cat; \n  animal_list[SMALL_NAUGHTY] = &mouse;\n\n  cout << \" Welcom to my animal house \" << endl;\n\n  do  \n  {\n    cout <<\" please chose the animal you want to feed \" << endl;\n    cout <<\" [0] for cat, [1] for mouse, [2] check the weight of all cute animals !!\" << endl;\n    cin >> type ;\n\n    if (type == 0)\n    {\n       animal_ptr = &cat;\n       cout << \" 喵喵 !!!\" << endl;\n       animal_ptr->show_name();\n    }\n    else if (type == 1)\n    {\n       animal_ptr = &mouse;\n       cout << \"唧唧 !!!\" << endl;\n       animal_ptr->show_name();\n    }\n    else if (type == 2)\n    {\n      cout << \"======體重表=======\"<<endl;\n      \n      for (int i=0; i< MAX_ANIMAL_NUMBER; i++)\n      {\n        animal_ptr = animal_list[i];\n        animal_ptr->show_name();\n        cout << \"我的重量是 \" << animal_ptr->get_weight()<<\"(kg)\" <<endl;\n      }\n      cout << \"===================\"<<endl;\n      continue;\n    }\n    else \n    {\n       cout << \" wow, qq, We don't have your animal !!\" <<endl;\n       continue; \n    }\n\n    cout << \" How many days you want to feed ?? \" << endl;\n    cin >> food_value; \n    animal_ptr->feed(food_value);\n\n  }while(1);\n\n  return 0;\n}\n\n```\n\n\n","slug":"-C-Virtual-Function-Inherit-My-Animal-World","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp2bk006535ggkwfiusvw"},{"title":"[C++][Virtual Function] Exercises","date":"2015-03-10T15:07:33.000Z","toc":true,"_content":"\n## 目的\n最近在練習基本的clss的用法, 突然想到一些問題. \n\n1. 我們利用關鍵字virtual 來使用extend 的function member 的時候,\n   base class 是否需要有相同引數的function member? \n   \n   -->  ___答案是要的___\n\n2. extend class 要如何存取 base class 的 member data\n\n   --> ___將base class的member data 從private 改成protected___\n\n3. extend class 在用 virtual 關鍵字的時候, 是否需要在function 宣告的前面加上 virtual\n\n   --> ___不用___\n\n## Exercise\n\n底下是間單的測試code.\n\n```\n//***********************************\n//**********************************\n// Arthur : Sheldon Peng\n// Date : 2015.3.10\n// Purpose : Try the understand the virtual function in C++\n//*********************************\n//**********************************\n\n#include <iostream>\nusing namespace std;\n\nclass base_class \n{\n  public :\n      base_class(void);\n      virtual void set_value(int);\n      virtual void set_value(int, int);\n      void print_value(void);\n\n  protected : \n      int v1; \n      int v2; \n};\n\nbase_class :: base_class(void)\n{\n  v1 = 0;\n  v2 = 0;\n  cout << \"base_class constructor !!\" <<endl;\n}\n\nvoid base_class :: set_value(int a)\n{\n  cout << \"base class to set_value1\" <<endl;\n  v1 += a ; \n}\n\nvoid base_class :: set_value(int a, int b)\n{\n  cout << \"base class to set_value\" <<endl;\n  v1 = 0;\n  v2 = 0;\n} \n\nvoid base_class :: print_value(void)\n{\n  cout << \"v1 = \" << v1 <<endl;\n  cout << \"v2 = \" << v2 <<endl;\n}\n\nclass extend_class : public base_class\n{\n  public :\n    extend_class(void);  \n    void set_value(int, int);\n};\n\nextend_class :: extend_class(void) : base_class()\n{\n  cout << \"extend clss constructor\" << endl; \n}\n\nvoid extend_class::set_value(int a, int b)\n{\n  cout << \"extend class to set_value\" <<endl;\n  v1 += a;\n  v2 += b;\n}\n\nint main(void)\n{\n  base_class BC;\n  extend_class EC;\n\n  base_class* base_ptr;\n\n  // base class\n  base_ptr = &BC;\n  base_ptr->set_value(10);\n  base_ptr->print_value();\n\n  // extended class\n  base_ptr = &EC;\n  base_ptr->set_value(5, 5);\n  base_ptr->print_value();\n\n  return 0;\n}\n\n```\n\n\n","source":"_posts/-C-Virtual-Function-Exercisels.md","raw":"title: \"[C++][Virtual Function] Exercises\"\ndate: 2015-03-10 23:07:33\ncategories: C++\ntags:\n- C++\n- Virtual Function\n- Dynamic Binding\ntoc: true\n---\n\n## 目的\n最近在練習基本的clss的用法, 突然想到一些問題. \n\n1. 我們利用關鍵字virtual 來使用extend 的function member 的時候,\n   base class 是否需要有相同引數的function member? \n   \n   -->  ___答案是要的___\n\n2. extend class 要如何存取 base class 的 member data\n\n   --> ___將base class的member data 從private 改成protected___\n\n3. extend class 在用 virtual 關鍵字的時候, 是否需要在function 宣告的前面加上 virtual\n\n   --> ___不用___\n\n## Exercise\n\n底下是間單的測試code.\n\n```\n//***********************************\n//**********************************\n// Arthur : Sheldon Peng\n// Date : 2015.3.10\n// Purpose : Try the understand the virtual function in C++\n//*********************************\n//**********************************\n\n#include <iostream>\nusing namespace std;\n\nclass base_class \n{\n  public :\n      base_class(void);\n      virtual void set_value(int);\n      virtual void set_value(int, int);\n      void print_value(void);\n\n  protected : \n      int v1; \n      int v2; \n};\n\nbase_class :: base_class(void)\n{\n  v1 = 0;\n  v2 = 0;\n  cout << \"base_class constructor !!\" <<endl;\n}\n\nvoid base_class :: set_value(int a)\n{\n  cout << \"base class to set_value1\" <<endl;\n  v1 += a ; \n}\n\nvoid base_class :: set_value(int a, int b)\n{\n  cout << \"base class to set_value\" <<endl;\n  v1 = 0;\n  v2 = 0;\n} \n\nvoid base_class :: print_value(void)\n{\n  cout << \"v1 = \" << v1 <<endl;\n  cout << \"v2 = \" << v2 <<endl;\n}\n\nclass extend_class : public base_class\n{\n  public :\n    extend_class(void);  \n    void set_value(int, int);\n};\n\nextend_class :: extend_class(void) : base_class()\n{\n  cout << \"extend clss constructor\" << endl; \n}\n\nvoid extend_class::set_value(int a, int b)\n{\n  cout << \"extend class to set_value\" <<endl;\n  v1 += a;\n  v2 += b;\n}\n\nint main(void)\n{\n  base_class BC;\n  extend_class EC;\n\n  base_class* base_ptr;\n\n  // base class\n  base_ptr = &BC;\n  base_ptr->set_value(10);\n  base_ptr->print_value();\n\n  // extended class\n  base_ptr = &EC;\n  base_ptr->set_value(5, 5);\n  base_ptr->print_value();\n\n  return 0;\n}\n\n```\n\n\n","slug":"-C-Virtual-Function-Exercisels","published":1,"updated":"2018-01-08T15:44:26.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc6dp2by006f35gg9edja3sh"}],"PostAsset":[],"PostCategory":[{"post_id":"cjc6dp22b000035gg3t699hlf","category_id":"cjc6dp22n000135gg3uyc1cby","_id":"cjc6dp22t000435ggynp82s76"},{"post_id":"cjc6dp23p000b35ggmypydxz3","category_id":"cjc6dp23s000c35ggfzjat1a5","_id":"cjc6dp23t000f35ggnyd40zlc"},{"post_id":"cjc6dp23z000g35gg478cthw9","category_id":"cjc6dp240000h35ggxmog3lmi","_id":"cjc6dp242000k35ggji3mghbd"},{"post_id":"cjc6dp24n000r35gggmqwtriv","category_id":"cjc6dp24o000s35gg0ds9zecq","_id":"cjc6dp24s000v35ggsfah1pgr"},{"post_id":"cjc6dp24w000w35gg9zup0u21","category_id":"cjc6dp24z000x35ggz6wc1a7w","_id":"cjc6dp258001035ggcir7qomu"},{"post_id":"cjc6dp25b001535gg17gdmbzo","category_id":"cjc6dp25e001635gg4gnv7nrz","_id":"cjc6dp25h001935ggjvvp8pgt"},{"post_id":"cjc6dp25p001g35gg3zed1xhy","category_id":"cjc6dp25v001h35ggsd6rq7p1","_id":"cjc6dp25x001m35gg8jvp3izt"},{"post_id":"cjc6dp25p001g35gg3zed1xhy","category_id":"cjc6dp25w001k35gg199xr777","_id":"cjc6dp25y001o35ggdtmls7po"},{"post_id":"cjc6dp262001q35ggkwnh5ysn","category_id":"cjc6dp265001r35gg6zsx3hz1","_id":"cjc6dp267001u35ggc1ussyzm"},{"post_id":"cjc6dp269001x35ggyc67iikp","category_id":"cjc6dp26c001y35gglgt7ecaf","_id":"cjc6dp26d002135ggbwitp86y"},{"post_id":"cjc6dp26g002635ggxqahh0ei","category_id":"cjc6dp26h002735ggrv01qiry","_id":"cjc6dp26i002a35ggjvl882wx"},{"post_id":"cjc6dp26k002d35ggqh0rlh2s","category_id":"cjc6dp26m002e35gg1a92dva2","_id":"cjc6dp26n002h35gga8lr3x6t"},{"post_id":"cjc6dp26s002l35gg99etej9b","category_id":"cjc6dp26u002m35ggn0gzthx7","_id":"cjc6dp26v002p35ggr63143n9"},{"post_id":"cjc6dp26y002u35gg7cd8tfth","category_id":"cjc6dp26m002e35gg1a92dva2","_id":"cjc6dp270002y35ggp1d3yq3z"},{"post_id":"cjc6dp26y002u35gg7cd8tfth","category_id":"cjc6dp26z002v35gg2k16c836","_id":"cjc6dp270002z35ggnaqkrbi8"},{"post_id":"cjc6dp272003335ggfaxzzvcv","category_id":"cjc6dp274003435gggq99nlw2","_id":"cjc6dp276003735ggda9vqi3n"},{"post_id":"cjc6dp27c003c35gguvotozg2","category_id":"cjc6dp27f003d35ggc2te5yr5","_id":"cjc6dp27g003g35ggpp01onex"},{"post_id":"cjc6dp27n003m35gg7g5xtphf","category_id":"cjc6dp27s003n35gglq5pm3f1","_id":"cjc6dp27v003q35gg2qdkla10"},{"post_id":"cjc6dp27y003u35gg7h6cnsz9","category_id":"cjc6dp283003v35gg7gzxb4uo","_id":"cjc6dp287003y35gglvmtly3o"},{"post_id":"cjc6dp28b004235ggu4v9s1xt","category_id":"cjc6dp28f004335ggehx02p6v","_id":"cjc6dp28g004635gg5e7xydhk"},{"post_id":"cjc6dp28i004935gg59h6w0sg","category_id":"cjc6dp28k004a35ggnewdiga2","_id":"cjc6dp28m004d35gg0n1zqcjf"},{"post_id":"cjc6dp294004f35ggu5jxdu3c","category_id":"cjc6dp29a004g35ggkqw1ooi0","_id":"cjc6dp29b004j35ggpdfpr9ld"},{"post_id":"cjc6dp29e004k35gg4i6rfn0d","category_id":"cjc6dp29a004g35ggkqw1ooi0","_id":"cjc6dp29f004l35ggl3ggo8ca"},{"post_id":"cjc6dp29i004p35ggwt1ozdhs","category_id":"cjc6dp29a004g35ggkqw1ooi0","_id":"cjc6dp29j004q35ggw64o5tpd"},{"post_id":"cjc6dp29m004w35gg3dou0buj","category_id":"cjc6dp29a004g35ggkqw1ooi0","_id":"cjc6dp29o004x35ggtj4fymgk"},{"post_id":"cjc6dp29r005135ggjhw6pfnl","category_id":"cjc6dp29a004g35ggkqw1ooi0","_id":"cjc6dp29t005235ggkgrnwxmi"},{"post_id":"cjc6dp29v005435ggayijbizs","category_id":"cjc6dp29a004g35ggkqw1ooi0","_id":"cjc6dp29z005535gge4flbi7o"},{"post_id":"cjc6dp2a1005935gg0t8poq02","category_id":"cjc6dp2a2005a35ggllyx91de","_id":"cjc6dp2a4005d35gg51jwozce"},{"post_id":"cjc6dp2aa005j35ggb6dksty0","category_id":"cjc6dp2ab005k35ggtld6jjhl","_id":"cjc6dp2ad005n35ggjd51ewrn"},{"post_id":"cjc6dp2ag005p35gg5g6icnjx","category_id":"cjc6dp2ah005q35ggm2j6figc","_id":"cjc6dp2aj005t35gg636n4toe"},{"post_id":"cjc6dp2at005v35ggkk00z120","category_id":"cjc6dp2au005w35ggr2nnmsny","_id":"cjc6dp2ay005z35gghpd68kxd"},{"post_id":"cjc6dp2b1006035ggpzh9fcl8","category_id":"cjc6dp2b6006135ggri7lq2an","_id":"cjc6dp2bd006435gg4f73vu96"},{"post_id":"cjc6dp2bk006535ggkwfiusvw","category_id":"cjc6dp2bm006635gg0g4rgdkp","_id":"cjc6dp2bn006935gg0cx8tl0h"},{"post_id":"cjc6dp2by006f35gg9edja3sh","category_id":"cjc6dp2bm006635gg0g4rgdkp","_id":"cjc6dp2bz006g35gg3saiwg64"}],"PostTag":[{"post_id":"cjc6dp22b000035gg3t699hlf","tag_id":"cjc6dp22n000235ggev5jx8ry","_id":"cjc6dp22w000735ggip5q67na"},{"post_id":"cjc6dp22b000035gg3t699hlf","tag_id":"cjc6dp22s000335ggkxu7oaes","_id":"cjc6dp22w000835ggfgh8ja7r"},{"post_id":"cjc6dp22b000035gg3t699hlf","tag_id":"cjc6dp22u000535gg032be0bs","_id":"cjc6dp22w000935gg2b4dgjvh"},{"post_id":"cjc6dp22b000035gg3t699hlf","tag_id":"cjc6dp22v000635gg0aeltg7g","_id":"cjc6dp22x000a35ggt8azli4d"},{"post_id":"cjc6dp23p000b35ggmypydxz3","tag_id":"cjc6dp23s000d35ggxd66rkd0","_id":"cjc6dp23t000e35ggukps5ybk"},{"post_id":"cjc6dp23z000g35gg478cthw9","tag_id":"cjc6dp241000i35ggd7plxwyd","_id":"cjc6dp243000m35ggdffmkhhh"},{"post_id":"cjc6dp23z000g35gg478cthw9","tag_id":"cjc6dp241000j35gg1ahy21nq","_id":"cjc6dp244000n35gg032gss7i"},{"post_id":"cjc6dp23z000g35gg478cthw9","tag_id":"cjc6dp242000l35gg6f1lb0bf","_id":"cjc6dp245000o35ggiz3l9xam"},{"post_id":"cjc6dp24n000r35gggmqwtriv","tag_id":"cjc6dp24o000t35ggr17sjw5c","_id":"cjc6dp24s000u35gg9823mgzp"},{"post_id":"cjc6dp24w000w35gg9zup0u21","tag_id":"cjc6dp24z000y35gg7qkwkgoz","_id":"cjc6dp259001235ggxoe3uvh7"},{"post_id":"cjc6dp24w000w35gg9zup0u21","tag_id":"cjc6dp257000z35ggycpg30cj","_id":"cjc6dp259001335gg5er6kt35"},{"post_id":"cjc6dp24w000w35gg9zup0u21","tag_id":"cjc6dp258001135ggejl569uc","_id":"cjc6dp259001435gg5q4woxsb"},{"post_id":"cjc6dp25b001535gg17gdmbzo","tag_id":"cjc6dp25e001735ggiy17j6x2","_id":"cjc6dp25m001c35gg6vdwnhhd"},{"post_id":"cjc6dp25b001535gg17gdmbzo","tag_id":"cjc6dp25h001835gg59rj5qpj","_id":"cjc6dp25m001d35ggcza3w7hk"},{"post_id":"cjc6dp25b001535gg17gdmbzo","tag_id":"cjc6dp25j001a35gg0jnf98oz","_id":"cjc6dp25n001e35ggp5br1zej"},{"post_id":"cjc6dp25b001535gg17gdmbzo","tag_id":"cjc6dp25l001b35gga2zhto5g","_id":"cjc6dp25n001f35ggczn9okey"},{"post_id":"cjc6dp25p001g35gg3zed1xhy","tag_id":"cjc6dp22n000235ggev5jx8ry","_id":"cjc6dp25x001l35ggngr4c494"},{"post_id":"cjc6dp25p001g35gg3zed1xhy","tag_id":"cjc6dp25v001i35ggr0x8csxl","_id":"cjc6dp25x001n35ggl2565bip"},{"post_id":"cjc6dp25p001g35gg3zed1xhy","tag_id":"cjc6dp25w001j35gglxw51z61","_id":"cjc6dp25y001p35ggm11awz9z"},{"post_id":"cjc6dp262001q35ggkwnh5ysn","tag_id":"cjc6dp25l001b35gga2zhto5g","_id":"cjc6dp266001t35gg09pu4nl3"},{"post_id":"cjc6dp262001q35ggkwnh5ysn","tag_id":"cjc6dp265001s35ggjinb674f","_id":"cjc6dp267001v35ggzecpywcx"},{"post_id":"cjc6dp262001q35ggkwnh5ysn","tag_id":"cjc6dp25h001835gg59rj5qpj","_id":"cjc6dp268001w35ggnv971zvs"},{"post_id":"cjc6dp269001x35ggyc67iikp","tag_id":"cjc6dp26c001z35ggm7469qtv","_id":"cjc6dp26d002335ggcd3q2lk4"},{"post_id":"cjc6dp269001x35ggyc67iikp","tag_id":"cjc6dp26c002035ggq61qrutk","_id":"cjc6dp26d002435ggo1wg8wv5"},{"post_id":"cjc6dp269001x35ggyc67iikp","tag_id":"cjc6dp26d002235ggsi3k4uwp","_id":"cjc6dp26e002535ggxupvwxq7"},{"post_id":"cjc6dp26g002635ggxqahh0ei","tag_id":"cjc6dp26i002835gg34n0zklk","_id":"cjc6dp26i002b35gg3vot7erd"},{"post_id":"cjc6dp26g002635ggxqahh0ei","tag_id":"cjc6dp26i002935ggpib5k1pu","_id":"cjc6dp26i002c35gg2hbtr72u"},{"post_id":"cjc6dp26k002d35ggqh0rlh2s","tag_id":"cjc6dp22n000235ggev5jx8ry","_id":"cjc6dp26q002i35gg4pytdk23"},{"post_id":"cjc6dp26k002d35ggqh0rlh2s","tag_id":"cjc6dp26n002f35ggv1z88j22","_id":"cjc6dp26q002j35ggwbzqfgi3"},{"post_id":"cjc6dp26k002d35ggqh0rlh2s","tag_id":"cjc6dp26n002g35ggynzdt3ta","_id":"cjc6dp26q002k35ggaa13t9ms"},{"post_id":"cjc6dp26s002l35gg99etej9b","tag_id":"cjc6dp26u002n35ggmm42xa1y","_id":"cjc6dp26v002r35ggob4al194"},{"post_id":"cjc6dp26s002l35gg99etej9b","tag_id":"cjc6dp26v002o35ggiudgk2b4","_id":"cjc6dp26v002s35ggxckwg8lv"},{"post_id":"cjc6dp26s002l35gg99etej9b","tag_id":"cjc6dp26v002q35gg81l0jykn","_id":"cjc6dp26v002t35gg8e218u0j"},{"post_id":"cjc6dp26y002u35gg7cd8tfth","tag_id":"cjc6dp22n000235ggev5jx8ry","_id":"cjc6dp270003035ggiqgmbava"},{"post_id":"cjc6dp26y002u35gg7cd8tfth","tag_id":"cjc6dp26z002w35ggg7jb7r45","_id":"cjc6dp270003135ggdna6sive"},{"post_id":"cjc6dp26y002u35gg7cd8tfth","tag_id":"cjc6dp270002x35gg3zdvnefd","_id":"cjc6dp270003235ggrxo4yr3n"},{"post_id":"cjc6dp272003335ggfaxzzvcv","tag_id":"cjc6dp22n000235ggev5jx8ry","_id":"cjc6dp276003835ggch0kpkvt"},{"post_id":"cjc6dp272003335ggfaxzzvcv","tag_id":"cjc6dp275003535ggsbmj5qx6","_id":"cjc6dp277003935ggf512e3f0"},{"post_id":"cjc6dp272003335ggfaxzzvcv","tag_id":"cjc6dp25v001i35ggr0x8csxl","_id":"cjc6dp277003a35ggbdx6pm31"},{"post_id":"cjc6dp272003335ggfaxzzvcv","tag_id":"cjc6dp275003635ggr68b7e9w","_id":"cjc6dp277003b35ggx39s6jbo"},{"post_id":"cjc6dp27c003c35gguvotozg2","tag_id":"cjc6dp22n000235ggev5jx8ry","_id":"cjc6dp27h003i35ggytej5e9z"},{"post_id":"cjc6dp27c003c35gguvotozg2","tag_id":"cjc6dp27f003e35ggkr95up04","_id":"cjc6dp27h003j35gg06wx21it"},{"post_id":"cjc6dp27c003c35gguvotozg2","tag_id":"cjc6dp27g003f35ggtaayhprx","_id":"cjc6dp27h003k35gglvcqhdkt"},{"post_id":"cjc6dp27c003c35gguvotozg2","tag_id":"cjc6dp27g003h35ggr0bx38xl","_id":"cjc6dp27h003l35gg6oksx2f6"},{"post_id":"cjc6dp27n003m35gg7g5xtphf","tag_id":"cjc6dp22n000235ggev5jx8ry","_id":"cjc6dp27v003r35ggwv7vwfv0"},{"post_id":"cjc6dp27n003m35gg7g5xtphf","tag_id":"cjc6dp27u003o35ggvp2cmv9q","_id":"cjc6dp27v003s35gghzlrquay"},{"post_id":"cjc6dp27n003m35gg7g5xtphf","tag_id":"cjc6dp27v003p35gglf6alhq3","_id":"cjc6dp27w003t35gg4n4p7kdb"},{"post_id":"cjc6dp27y003u35gg7h6cnsz9","tag_id":"cjc6dp22n000235ggev5jx8ry","_id":"cjc6dp287003z35ggvijhug82"},{"post_id":"cjc6dp27y003u35gg7h6cnsz9","tag_id":"cjc6dp283003w35ggnog48f7s","_id":"cjc6dp289004035ggqsivgp0v"},{"post_id":"cjc6dp27y003u35gg7h6cnsz9","tag_id":"cjc6dp284003x35gg9bm122fr","_id":"cjc6dp289004135ggj1uqp6ly"},{"post_id":"cjc6dp28b004235ggu4v9s1xt","tag_id":"cjc6dp28f004435gg13qfq8ae","_id":"cjc6dp28g004735ggz13hol6d"},{"post_id":"cjc6dp28b004235ggu4v9s1xt","tag_id":"cjc6dp28f004535ggsnf65cv0","_id":"cjc6dp28g004835ggqeme0g46"},{"post_id":"cjc6dp28i004935gg59h6w0sg","tag_id":"cjc6dp28k004b35gglksop29n","_id":"cjc6dp28l004c35ggbwt9t0s1"},{"post_id":"cjc6dp28i004935gg59h6w0sg","tag_id":"cjc6dp242000l35gg6f1lb0bf","_id":"cjc6dp28m004e35ggxx4wm1jm"},{"post_id":"cjc6dp294004f35ggu5jxdu3c","tag_id":"cjc6dp29b004h35ggudkv3nmt","_id":"cjc6dp29b004i35ggejm9jqvm"},{"post_id":"cjc6dp29e004k35gg4i6rfn0d","tag_id":"cjc6dp29b004h35ggudkv3nmt","_id":"cjc6dp29g004n35gg4citqwmo"},{"post_id":"cjc6dp29e004k35gg4i6rfn0d","tag_id":"cjc6dp29f004m35gg2rgdqrf2","_id":"cjc6dp29g004o35gghkyhubpn"},{"post_id":"cjc6dp29i004p35ggwt1ozdhs","tag_id":"cjc6dp29j004r35ggkpxsf2qj","_id":"cjc6dp29l004t35ggv0kfqak4"},{"post_id":"cjc6dp29i004p35ggwt1ozdhs","tag_id":"cjc6dp29k004s35ggps0lhcws","_id":"cjc6dp29l004u35ggnuy9v2dw"},{"post_id":"cjc6dp29i004p35ggwt1ozdhs","tag_id":"cjc6dp29b004h35ggudkv3nmt","_id":"cjc6dp29l004v35gg39kzsv6k"},{"post_id":"cjc6dp29m004w35gg3dou0buj","tag_id":"cjc6dp29b004h35ggudkv3nmt","_id":"cjc6dp29o004z35ggqbreeh20"},{"post_id":"cjc6dp29m004w35gg3dou0buj","tag_id":"cjc6dp29o004y35ggs9fbpexz","_id":"cjc6dp29p005035ggyfv7212b"},{"post_id":"cjc6dp29r005135ggjhw6pfnl","tag_id":"cjc6dp29b004h35ggudkv3nmt","_id":"cjc6dp29t005335gggiyi45r8"},{"post_id":"cjc6dp29v005435ggayijbizs","tag_id":"cjc6dp29z005635ggetrxqqwr","_id":"cjc6dp2a0005735gg25pd4v11"},{"post_id":"cjc6dp29v005435ggayijbizs","tag_id":"cjc6dp29b004h35ggudkv3nmt","_id":"cjc6dp2a0005835ggsjhh8jpi"},{"post_id":"cjc6dp2a1005935gg0t8poq02","tag_id":"cjc6dp2a3005b35ggnc0k64b5","_id":"cjc6dp2a6005f35ggip0u1yty"},{"post_id":"cjc6dp2a1005935gg0t8poq02","tag_id":"cjc6dp2a3005c35ggyxd3gxbu","_id":"cjc6dp2a6005g35ggbzrgme13"},{"post_id":"cjc6dp2a1005935gg0t8poq02","tag_id":"cjc6dp2a4005e35gghjm74b89","_id":"cjc6dp2a6005h35ggjk61i0l5"},{"post_id":"cjc6dp2a1005935gg0t8poq02","tag_id":"cjc6dp242000l35gg6f1lb0bf","_id":"cjc6dp2a6005i35gg4los24sj"},{"post_id":"cjc6dp2aa005j35ggb6dksty0","tag_id":"cjc6dp22n000235ggev5jx8ry","_id":"cjc6dp2ad005m35gg5fdl3f1i"},{"post_id":"cjc6dp2aa005j35ggb6dksty0","tag_id":"cjc6dp2ac005l35ggxcnytckn","_id":"cjc6dp2ad005o35ggmcehqbds"},{"post_id":"cjc6dp2ag005p35gg5g6icnjx","tag_id":"cjc6dp26c002035ggq61qrutk","_id":"cjc6dp2aj005s35ggetau33uo"},{"post_id":"cjc6dp2ag005p35gg5g6icnjx","tag_id":"cjc6dp2ah005r35gg62bc4gc6","_id":"cjc6dp2an005u35gg44z8hh54"},{"post_id":"cjc6dp2at005v35ggkk00z120","tag_id":"cjc6dp2ax005x35gg8srfpftr","_id":"cjc6dp2ay005y35ggynrnwt8b"},{"post_id":"cjc6dp2b1006035ggpzh9fcl8","tag_id":"cjc6dp2b6006235ggmy61pvpy","_id":"cjc6dp2bd006335gg9iclqagg"},{"post_id":"cjc6dp2bk006535ggkwfiusvw","tag_id":"cjc6dp2bm006735gg1abjg2zq","_id":"cjc6dp2bn006b35ggsiyv80bl"},{"post_id":"cjc6dp2bk006535ggkwfiusvw","tag_id":"cjc6dp26n002f35ggv1z88j22","_id":"cjc6dp2bo006c35gg4t9kcoft"},{"post_id":"cjc6dp2bk006535ggkwfiusvw","tag_id":"cjc6dp2bn006835ggus84mdou","_id":"cjc6dp2bo006d35ggzkzc0bc5"},{"post_id":"cjc6dp2bk006535ggkwfiusvw","tag_id":"cjc6dp2bn006a35ggdfl3mxbf","_id":"cjc6dp2bo006e35ggwvr2633g"},{"post_id":"cjc6dp2by006f35gg9edja3sh","tag_id":"cjc6dp26n002f35ggv1z88j22","_id":"cjc6dp2c1006i35ggmkbp5nrw"},{"post_id":"cjc6dp2by006f35gg9edja3sh","tag_id":"cjc6dp2bm006735gg1abjg2zq","_id":"cjc6dp2c1006j35ggytpwkiyy"},{"post_id":"cjc6dp2by006f35gg9edja3sh","tag_id":"cjc6dp2c1006h35ggejuasm3k","_id":"cjc6dp2c1006k35ggss9cib7i"}],"Tag":[{"name":"C","_id":"cjc6dp22n000235ggev5jx8ry"},{"name":"ELF","_id":"cjc6dp22s000335ggkxu7oaes"},{"name":"Attribute Section","_id":"cjc6dp22u000535gg032be0bs"},{"name":"readelf","_id":"cjc6dp22v000635gg0aeltg7g"},{"name":"Finance","_id":"cjc6dp23s000d35ggxd66rkd0"},{"name":"Stock","_id":"cjc6dp241000i35ggd7plxwyd"},{"name":"R","_id":"cjc6dp241000j35gg1ahy21nq"},{"name":"Ubuntu","_id":"cjc6dp242000l35gg6f1lb0bf"},{"name":"VIM","_id":"cjc6dp24o000t35ggr17sjw5c"},{"name":"vim","_id":"cjc6dp24z000y35gg7qkwkgoz"},{"name":"CTag","_id":"cjc6dp257000z35ggycpg30cj"},{"name":"Cscope","_id":"cjc6dp258001135ggejl569uc"},{"name":"stack","_id":"cjc6dp25e001735ggiy17j6x2"},{"name":"double link list","_id":"cjc6dp25h001835gg59rj5qpj"},{"name":"c","_id":"cjc6dp25j001a35gg0jnf98oz"},{"name":"data structure","_id":"cjc6dp25l001b35gga2zhto5g"},{"name":"Mutex","_id":"cjc6dp25v001i35ggr0x8csxl"},{"name":"Read/Write Lock","_id":"cjc6dp25w001j35gglxw51z61"},{"name":"queue","_id":"cjc6dp265001s35ggjinb674f"},{"name":"nmap","_id":"cjc6dp26c001z35ggm7469qtv"},{"name":"network","_id":"cjc6dp26c002035ggq61qrutk"},{"name":"fping","_id":"cjc6dp26d002235ggsi3k4uwp"},{"name":"geek","_id":"cjc6dp26i002835gg34n0zklk"},{"name":"resume","_id":"cjc6dp26i002935ggpib5k1pu"},{"name":"C++","_id":"cjc6dp26n002f35ggv1z88j22"},{"name":"class","_id":"cjc6dp26n002g35ggynzdt3ta"},{"name":"POST","_id":"cjc6dp26u002n35ggmm42xa1y"},{"name":"HTTP","_id":"cjc6dp26v002o35ggiudgk2b4"},{"name":"ASP","_id":"cjc6dp26v002q35gg81l0jykn"},{"name":"readlink","_id":"cjc6dp26z002w35ggg7jb7r45"},{"name":"ls","_id":"cjc6dp270002x35gg3zdvnefd"},{"name":"Pthread","_id":"cjc6dp275003535ggsbmj5qx6"},{"name":"Interface","_id":"cjc6dp275003635ggr68b7e9w"},{"name":"pthread_create","_id":"cjc6dp27f003e35ggkr95up04"},{"name":"pthread_join","_id":"cjc6dp27g003f35ggtaayhprx"},{"name":"multi-thread","_id":"cjc6dp27g003h35ggr0bx38xl"},{"name":"Dynamic Array","_id":"cjc6dp27u003o35ggvp2cmv9q"},{"name":"realloc","_id":"cjc6dp27v003p35gglf6alhq3"},{"name":"DB","_id":"cjc6dp283003w35ggnog48f7s"},{"name":"Double Link List","_id":"cjc6dp284003x35gg9bm122fr"},{"name":"atoi","_id":"cjc6dp28f004435gg13qfq8ae"},{"name":"itoa","_id":"cjc6dp28f004535ggsnf65cv0"},{"name":"Line","_id":"cjc6dp28k004b35gglksop29n"},{"name":"Raspberry Pi","_id":"cjc6dp29b004h35ggudkv3nmt"},{"name":"Case","_id":"cjc6dp29f004m35gg2rgdqrf2"},{"name":"Socket","_id":"cjc6dp29j004r35ggkpxsf2qj"},{"name":"GPIO","_id":"cjc6dp29k004s35ggps0lhcws"},{"name":"root","_id":"cjc6dp29o004y35ggs9fbpexz"},{"name":"Cam Module","_id":"cjc6dp29z005635ggetrxqqwr"},{"name":"QT","_id":"cjc6dp2a3005b35ggnc0k64b5"},{"name":"GUI","_id":"cjc6dp2a3005c35ggyxd3gxbu"},{"name":"compiler","_id":"cjc6dp2a4005e35gghjm74b89"},{"name":"pointer","_id":"cjc6dp2ac005l35ggxcnytckn"},{"name":"ubuntu","_id":"cjc6dp2ah005r35gg62bc4gc6"},{"name":"GDB","_id":"cjc6dp2ax005x35gg8srfpftr"},{"name":"GCC","_id":"cjc6dp2b6006235ggmy61pvpy"},{"name":"Virtual Function","_id":"cjc6dp2bm006735gg1abjg2zq"},{"name":"Inherit","_id":"cjc6dp2bn006835ggus84mdou"},{"name":"Dynamical Binding","_id":"cjc6dp2bn006a35ggdfl3mxbf"},{"name":"Dynamic Binding","_id":"cjc6dp2c1006h35ggejuasm3k"}]}}